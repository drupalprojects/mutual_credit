<?php
// $Id:
//much of this module could be hived off into an inc file

define ('TRANSACTION_STATE_PENDING', -1);

function mcapi_signatures_help($path) {
  if ($path != 'admin/accounting/signatures') return;
  $help = t('Require signatures for certain transaction types before they are cleared.');
  return $help;
}

/*
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table and marked 'signed'
 * Signatures happen via menu callbacks
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * Also to sign all a user's transactions.
 * There is also a 'cancel' operation for pending transactions, permissions defined in the currency.
  */
function mcapi_signatures_menu() {
  //this item makes it possible to sign on someone elses behalf, if the link is provided.
  //That's not in the scope of this module
  $items['admin/accounting/signatures'] = array(
    'title' => 'Signatures',
    'description' => 'Require signatures before transactions enter pending state',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signatures_config'),
    'access arguments' => array('design transaction forms'),
    'file' => 'mcapi_signatures.inc'
  );
  return $items;
}

/*
 * Will implement hook_entity_load or some such
 */
function mcapi_signatures_entity_load($entities, $type) {
  if ($type != 'transaction')return;
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $key => $transaction) {
    $transaction->pending_signatures = mcapi_get_signatories($transaction->serial);
  }
}

/*
 * Will implement hook_entity_delete or some such
 */
function mcapi_signatures_entity_delete($transaction, $type) {
  if ($type == 'transaction') {
    db_delete("mcapi_signatures")
    ->condition('serial', $transaction->serial)
    ->execute();
  }
}


/*
 * Implements hook_mcapi_info_states
 */
function mcapi_signatures_mcapi_info_states() {
  return array(
    //must be defined with lower case
    TRANSACTION_STATE_PENDING => array(
      'name' => t("Pending"),
      'description' => t("awaiting signatures before becoming 'finished'."),
      'default_access_callbacks' => array('transaction_access_callback_signatory')
    )
  );
}

function mcapi_signatures_config($form, $form_state) {
  module_load_include('inc', 'mcapi');
  //some types we know about will never be pending
  $types = _get_signable_transaction_types();
  $w = 0;
  $form = array('#tree' => TRUE);
  foreach ($types as $type) {
    $var_name = 'mcapi_signatures_'.$type;
    $settings = @$form_state['values'][$var_name] ? $form_state['values'][$var_name] : variable_get($var_name, array());
    $form[$var_name] = array(
      '#title' => $type,
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#id' => $type,
      'participants' => array(
        '#title' => t('Both participants must sign'),
        '#description' => t("Logged in user signs automatically"),
        '#type' => 'checkbox',
        '#default_value' => isset($settings['participants']) ? $settings['participants'] : TRUE
      ),
      'countersignatories' => array(
        '#title' => t('Counter-signers'),
        '#description' => t('Choose one or more users'),
        '#type' => 'user_chooser_roles',
        '#args' => array(DRUPAL_AUTHENTICATED_RID),
        '#default_value' => isset($settings['countersignatories']) ? $settings['countersignatories'] : array(),
        '#multiple' => TRUE,
        '#allow_me' =>TRUE
      ),
      'complete' => array(
        '#title' => t('Send notification'),
        '#description' => t("Use the email template on this page to notify all signatories"),
        '#type' => 'checkbox',
        '#default_value' => isset($settings['complete']) ? $settings['complete'] : FALSE,
        '#weight' => 5
      ),
      '#weight' => $w++
    );
  }
  $mail_def = variable_get('mcapi_sign_notify_template', array());
  $form['mcapi_sign_notify_template'] = array(
    '#title' => t('Signature notification'),
    '#description' => implode(' ', array(
      t('Compose the email notifying signatories that a transaction needs their attention'),
      t('Use the tokens provided')
    )),
    '#type' => 'fieldset',
    'subject' => array(
      '#title' => t('Subject'),
      '#type' => 'textfield',
      '#default_value' => isset($mail_def['subject']) ? $mail_def['subject'] : t('Your signature required'),
      '#required' => TRUE,
    ),
    'body' => array(
      '#title' => t('Body'),
      '#type' => 'textarea',
      '#default_value' => isset($mail_def['body']) ? $mail_def['body'] : '[transaction:url:absolute]',
      '#required' => TRUE,
      '#weight' => 1
    ),
    '#weight' => $w++
  );
  $mail_def = variable_get('mcapi_signed_off_notify_template', array());
  $form['mcapi_signed_off_notify_template'] = array(
    '#title' => t('Completed notification'),
    '#description' => implode(' ', array(
      t('Compose the email sent to all signatories when a pending transaction completes.'),
      t('Use the tokens provided')
    )),
    '#type' => 'fieldset',
    'subject' => array(
      '#title' => t('Subject'),
      '#type' => 'textfield',
      '#default_value' => isset($mail_def['subject']) ? $mail_def['subject'] : t('Transaction signed off'),
      '#required' => TRUE,
    ),
    'body' => array(
      '#title' => t('Body'),
      '#type' => 'textarea',
      '#default_value' => isset($mail_def['body']) ? $mail_def['body'] : '[transaction:url:absolute]',
      '#required' => TRUE,
      '#weight' => 1
    ),
    '#weight' => $w++
  );
  $form['token_tree'] = array(
    '#theme' => 'token_tree',
    '#token_types' => array('transaction', 'user', 'site'),
    '#global_types' => FALSE,
    '#weight' => $w++
  );
  return system_settings_form($form);
}




//returns a list of the user objects who are yet to sign
//will take EITHER a serial OR a uid, returns a list of the other
function mcapi_get_signatories($serial = NULL, $uid = NULL) {
  if ($serial && $uid) {
    drupal_set_message('Bad arguments to mcapi_get_signatories', 'error');
    return;
  }
  $signatures = array();
  $query = db_select('mcapi_signatures', 's');
  if ($serial) {
    $result = $query->fields('s', array('uid', 'pending'))->condition('serial', $serial)->execute()->fetchAllKeyed(0);
  }
  else {
    $result = $query->fields('s', array('serial'))->condition('pending', 1)->condition('uid', $uid)->execute()->fetchCol();
  }

  return $result;
}


/*
 * implements hook_form_FORM_ID_alter
 * changing state of all transaction forms EXCEPT those made with mcapi_forms module
 */
function mcapi_signatures_form_transaction_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'mcapi_forms_form') return;
  _set_form_state_to_pending($form, $form_state);
}


//check whether this transaction type needs signatures and change the state accordingly
//changes the status in the transaction form according to the settings for the transaction_type
function _set_form_state_to_pending(&$form, $form_state) {
    //read the settings and set the $form['state'] hidden widget
  $type = isset($form['type']['#value']) ? $form['type']['#value'] : $form['type']['#default_value'];//yuk
  if (in_array($type, _get_signable_transaction_types())) {
    $config = variable_get('mcapi_signatures_'.$type, array());
    if (@$config['participants'] || count(@$config['countersignatories'])) {
      $form['state'] = array(
        '#type' => 'value',
        '#value' => TRANSACTION_STATE_PENDING
      );
    }
  }
}

function mcapi_signatures_block_info() {
  //this is very hard to do in views
  return array(
    'user_pending' => array(
      'info' => t('All pending transactions (per user)')
    ),
    'waiting_on_uid' => array(
      'info' => t('Signatures for user to sign')
    )
  );
}

function mcapi_signatures_block_view($delta) {
  module_load_include('inc', 'mcapi');
  $settings = _mcapi_block_settings($delta, 'user_aggregated_view');
  module_load_include('inc', 'mcapi_signatures');
  if ($delta == 'user_pending') {
    return array(
      'subject' => t('Pending transactions'),
      'content' => list_pending_for_uid($settings['account']->uid, $settings['currcodes'])
    );
  }
  elseif($delta == 'waiting_on_uid') {
    return array(
      'subject' => t('Awaiting my signature'),
      'content' => list_waiting_on_uid($settings['account']->uid, $settings['currcodes'])
    );
  }
}

function mcapi_signatures_block_configure($delta) {
  return mcapi_block_configure($delta);
}
function mcapi_signatures_block_save($delta, $values) {
  return mcapi_block_save($delta, $values);
}

/*
 * implements hook_block_info_alter
 * adjusts the blocks declared by the default view
 */
function mcapi_signatures_block_info_alter(&$blocks) {
  //because this view requires an argument which probably comes from the url
  if (isset($blocks['views']['signatures-user_pending'])) {
    $blocks['views']['signatures-user_pending']['visibility'] = 1;
    $blocks['views']['signatures-user_pending']['pages'] = 'user*';
  }
}

/*
 * implements hook_block_view_alter
 * appends the 'signatures needed' view to the mcapi-balance block
 */
function mcapi_signatures_block_view_alter(&$data, $block) {
  if ($block->delta == 'balances' && $block->module == 'mcapi' && isset($data['#settings']['account'])) {
    $render = list_waiting_on_uid($data['#settings']['account']->uid);
    if (empty($render)) return;
    $data['content']= array(
      $data['content'],
      array('#markup' => '<h5>'.t('Awaiting my signature...').'</h5>'),
      $render
    );
  }
}

/*
 * implements hook_cron
 * checks integrity of signatures and transactions
 */
function mcapi_signatures_cron() {
  //call me paranoid, but I'd like to just check data integrity
  $serials = db_query("SELECT t.serial FROM {mcapi_transactions} t LEFT JOIN {mcapi_signatures} s ON t.serial = s.serial WHERE s.pending = 1 AND t.state = :state", array(':state' => TRANSACTION_STATE_FINISHED))->fetchCol();
  if (count($serials)){
    watchdog('mcapi_signatures', 'Some completed transactions still have signatures pending, please report to matslats: @serials', array('@serials' => implode(', ', $serials)), WATCHDOG_ERROR);
  }
}


/*
 * implements mcapi hook_transactions_state
 * saves the signatures and sends any notifications needed
 * The incoming $transaction clusters have already been saved and reloade,
 * all have the same state and serial number
 * so we process one a time children which aren't needed here
 */
function mcapi_signatures_transactions_state($transactions, $new_state) {
  //check the module settings for the transaction type
  foreach ($transactions as $transaction) {
    $config = variable_get('mcapi_signatures_'.$transaction->type, array('participants' => TRUE, 'countersignatories' => array()));
    $params = array('transaction' => $transaction);
    $uid = &$GLOBALS['user']->uid;
    if ($new_state == TRANSACTION_STATE_PENDING) {
      if ($config['participants']) {
        $transaction->pending_signatures[$transaction->payer] = $uid == $transaction->payer ? 0 : 1;
        $transaction->pending_signatures[$transaction->payee] = $uid == $transaction->payee ? 0 : 1;
      }
      $config['countersignatories']= array_filter((array)$config['countersignatories']);
      foreach($config['countersignatories'] as $counter_uid) {
        $transaction->pending_signatures[$counter_uid] = $uid == $counter_uid ? 0 : 1;
      }
      module_load_include('inc', 'mcapi_signatures');
      mcapi_signatures_save($transaction);
      $key = 'participants';
      $params['conf'] = variable_get('mcapi_sign_notify_template', array());
    }
    //moving from pending to finished
    elseif($new_state == TRANSACTION_STATE_FINISHED && $transaction->state == TRANSACTION_STATE_PENDING) {
      $key = 'complete';
      $params['conf'] = variable_get('mcapi_signed_off_notify_template', array());
    }
    //send the mail, using the module settings for this transaction
    if (!empty($params['conf']) && $config[$key]) {
      foreach(user_load_multiple(array_keys(array_filter($transaction->pending_signatures))) as $account) {
        $params['user'] = $account;
        drupal_mail('mcapi_signatures', $key, $account->mail, user_preferred_language($account), $params);
      }
    }
  }
}

function mcapi_signatures_mail($key, &$message, $params) {
  $options = array('language' => $message['language'], 'sanitize' => FALSE);
  $message['subject'] = token_replace($params['conf']['subject'], $params, $options);
  $message['body'][] = token_replace($params['conf']['body'], $params, $options);
}


/*
 * implements hook_theme
 */
function mcapi_signatures_theme() {
  $items['pending_signatures'] = array(
    'template' => 'pending_signatures',
    'variables' => array(
      'transaction' => NULL,//raw data pulled from the transaction
    )
  );
  return $items;
}

/*
 * implements hook_theme_registry_alter
 * adds the pending section to the transaction certificate
 */
function mcapi_signatures_theme_registry_alter(&$items) {
  $items['certificate']['variables']['pending'] = array();
}

/*
 * Bit of a one off, this one
 */
function _mcapi_sig_format_usernames($accounts) {
  foreach($accounts as $account) {
    $names[] = format_username($account);
  }
  return implode(' & ' ,$names);
}

function signatures_can_signall_for($uid) {
  $needed = transactions_needing_sig_of_user($uid);
  if (count($needed)) {
    if ($uid == $GLOBALS['user']->uid || user_access('manage all transactions')) return TRUE;
  }
  return FALSE;
}
function transactions_needing_sig_of_user($uid) {
  return db_query("SELECT serial FROM {mcapi_signatures} where uid = $uid AND pending = 1")->fetchCol();
}

function mcapi_signatures_transaction_view_alter(&$build) {
  foreach ($build as $render_array) {
    if ($render_array['#view_mode'] == 'certificate' && $render_array['#transaction']->state == TRANSACTION_STATE_PENDING) {
      $file = url(drupal_get_path('module', 'mcapi_signatures'))."/pending.png";
      $css = ".state--1{background-image:url($file);background-repeat: no-repeat; background-position: center;}";
      drupal_add_css($css, array('type' => 'inline'));
    }
  }
}

/*
 * implements theming hook_process_transaction
 * adds the sign_link to the transaction certificate, in accordance with mcapi_signatures_theme_registry_alter
 */
function mcapi_signatures_preprocess_certificate(&$variables) {
  $transaction = &$variables['transaction'];
  if ($transaction->state == TRANSACTION_STATE_PENDING && isset($transaction->pending_signatures)) {
    $variables['pending'] = array(
      '#theme' => 'pending_signatures',
      '#transaction' => $transaction
    );
  }
}


function _get_signoff_link($transaction) {
  if (transaction_signoff_access($transaction)) {
    $build['sign'] = array(
      '#theme' => 'link',
      '#text' => t('Sign off'),
      '#path' => 'transaction/'.$transaction->serial.'/signoff',
      '#options' => array(
        'attributes' => array(
          'title' => t('Sign the transaction on behalf of everyone'),
          'class' => 'link'
         ),
        'html' => TRUE,//required
       ),
    );
    return $build;
  }
}
function _get_sign_link($transaction) {
  if (transaction_sign_access($transaction)) {
    $build['sign'] = array(
      '#theme' => 'link',
      '#text' => t('Sign'),
      '#path' => 'transaction/'.$transaction->serial.'/sign',
      '#options' => array(
        'attributes' => array(
          'title' => t('Sign the transaction'),
          'class' => 'link'
         ),
        'html' => TRUE,//required
       ),
    );
    return $build;
  }
}


//utility function
//gets all the transaction types and excludes a few that we know aren't suitable for configuring
function _get_signable_transaction_types() {
  $types = array_diff(mcapi_get_types(), array('child', 'undo', 'undone', 'remote payment', 'remote receipt', 'mass'));
  sort($types);
  return $types;
}

/*
 * implements mcapi hook ransaction_operations
 * each callback refers to 2 functions - itself and CALLBACK_views
 */
function mcapi_signatures_transaction_operations() {
  return array(
    'sign' => array(
      'imperative' => 'Sign',
      'description' => 'Sign a pending transaction',
      'sure_message' => t('Are you sure you want to sign?'),
      'weight' => 2,
      'file_extension' => 'inc'
    ),
    'undo_pending' => array(
      'imperative' => 'Undo',
      'description' => t('Undo pending transactions'),
      'sure_message' => t('Are you sure you want to cancel this pending transaction?'),
      'weight' => 3,
      'redirect' => 'user',
      'file_extension' => 'inc'
    ),
    'signoff' => array(
      'imperative' => 'Sign off',
      'description' => 'Sign a pending transaction on behalf of all signatories',
      'sure_message' => t('Are you sure you want to sign off this transaction?'),
      'weight' => 5,
      'file_extension' => 'inc'
    )
  );
}

/*
 * implements mcapi hook transaction_access_callbacks
 * each callback refers to 2 functions - itself and CALLBACK_views
 * each callback recieves 3 arguments
 */
function mcapi_signatures_transaction_access_callbacks() {
  return array(
    'transaction_access_callback_signatory' => t('Signatories to the transaction'),
  );
}
/*
 * callback for transaction_access
 */
function transaction_access_callback_signatory($transaction) {
  return in_array($GLOBALS['user']->uid, array_keys((array)$transaction->pending_signatures));
}
/*
 * callback for transaction view access for views
 */
function transaction_access_callback_signatory_views($query, $condition, $state) {
  //no harm in joining the same table more than once
  //But there is a harm in joining only once because the query builder runs more than once for some reason.
  $query->addJoin('LEFT', 'mcapi_signatures', 'mcapi_signatures', 'mcapi_signatures.serial = mcapi_transactions.serial');
  $condition->condition('mcapi_signatures.uid', $GLOBALS['user']->uid);
}

/*
 * implements hook_mcapicurrencies_default_alter
 */
function mcapi_signatures_mcapicurrencies_default_alter(&$currencies) {
  foreach ($currencies as $name => $currency) {
    $currencies[$name]->data->transaction_view_access[TRANSACTION_STATE_PENDING] = drupal_map_assoc(
      array('transaction_access_callback_signatory', 'transaction_access_callback_perm_manage_all')
    );
  }
}

/*
 * implements hook_form_FORMID_alter
 * this has to run AFTER the mcapi_forms implementation
 */
function mcapi_signatures_form_mcapi_forms_form_alter(&$form, &$form_state) {
  //changing state of all ONLY transaction forms made with mcapi_forms module
  if (isset($form['#step']) && $form['#step'] == 1) {
    _set_form_state_to_pending($form, $form_state);
  }

}



/*
 * implements hook_trigger_info
 */
function mcapi_signatures_trigger_info() {
  //needs to be handled as a transaction operation
  return array(
    'mcapi' => array(
      'transaction_sign' => array(
        'label' => t('A signature is added to a transaction'),
      ),
    )
  );
}
<?php


define ('TRANSACTION_STATE_PENDING', -1);

/**
 * TODO put all this in hook_help
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table with the date of signing
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * There is also a 'cancel' transition for pending transactions, permissions defined in the currency.
 */


/**
 * implements hook_menu()
 */
function mcapi_signatures_menu() {
  //TODO put this in mcapi_signatures.routing.yml
  $items['user/%user/signall'] = array(
    'title' => 'Sign all your transactions?',
    'description' => 'Put your signature on all transactions which require it',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signall', 1),
    'access callback' => 'mcapi_signall_access',
    'access arguments' => array(1),
    'file' => 'mcapi_signatures.inc'
  );
  return $items;
}

function mcapi_signall_access($account) {
  if (db_query("SELECT TRUE FROM {mcapi_signatures} WHERE uid = $account->uid AND pending = 1")->fetchField()) {
    return $account->uid == \Drupal::currentUser()->id() || user_access('configure mcapi');
  }
}

/**
 * Implements hook_ENTITY_load()
 * put the signatories into the transaction entity
 */
function mcapi_signatures_mcapi_transaction_load($entities) {
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $key => $transaction) {
    if ($transaction->type->value != 'signatures') continue;
    $transaction->signatures = db_select('mcapi_signatures', 's')
      ->fields('s', array('uid', 'signed'))
      ->condition('serial', $transaction->serial->value)//or $transaction->serial??
      ->execute()->fetchAllKeyed(0);
  }
}

/**
 * implement mcapi hook_ENTITY_delete
 * this doesn't happen with the undo transition, which merely changes the state.
 * ensures that signatures for undone transactions are not left pending.
 */
function mcapi_signatures_mcapi_transaction_delete(TransactionInterface $transaction) {
	db_delete('mcapi_signatures')
	->condition('serial', $transaction->serial->value)
	->execute();
}

/**
 * implements hook_ENTITY_insert
 * saves the signatures after the entity has been written
 */
function mcapi_signatures_mcapi_transaction_insert($transaction) {
  if (isset($transaction->signatures)) {
    $config = transaction_transitions('sign')->config->get('special');
    $signatories = array_merge($config['countersignatories'], array(
        $transaction->payee->value,
        $transaction->payer->value
    ));
    foreach ($signatories as $uid) {
      //assume the current user has already signed
      $transaction->signatures[$uid] = \Drupal::currentUser()->id() == $uid ? REQUEST_TIME : 0;
    }
    $q = db_insert('mcapi_signatures')->fields(array('serial', 'uid', 'signed'));
    foreach ($transaction->signatures as $uid => $signed) {
      $q->values(array($transaction->serial->value, $uid, $signed));
    }
    $q->execute();
  }
}

/**
 * implements hook_ENTITY_update
 * resaves the signatures
 */
function mcapi_signatures_mcapi_transaction_update($transaction) {
  if (isset($transaction->signatures)) {
    foreach ($transaction->signatures as $uid => $signed) {
      db_merge('mcapi_signatures')
      ->keys(array('serial' => $transaction->serial->value, 'uid' => $uid))
      ->fields(array('signed' => $signed))->execute();
    }
  }
}


/**
 * OBSOLETE
 *
 * implements hook_block_view_BASE_BLOCK_ID_alter()
 * appends the 'signatures needed' view to the mcapi-balance block
 * //TODO actually this doesn't 'work if the user summaries are not showing in a block, but in the user profile
 * we'll need to drupal_alter the user summaries and perhaps other things
 * GORDON is this a good idea? Or we could allow developers to theme_alter instead?
 */
function mcapi_signatures_block_view_mcapi_user_summary_alter(array &$build, \Drupal\block\BlockPluginInterface $block) {
  module_load_include('inc', 'mcapi_signatures');
  die('testing this block works');
  //TODO test this with a pending transaction
  if ($content = list_waiting_on_uid($build['content']['#account'])) {
    $build['content'][] = array('#markup' => '<strong>'.t('Awaiting my signature...').'</strong>');
    $build['content'][] = $content;
  }
}


/**
 * implements hook_theme
 */
function mcapi_signatures_theme() {
  $items['mcapi_signatures'] = array(
    'template' => 'mcapi_signatures',
    'variables' => array(
      'transaction' => NULL,
    )
  );
  return $items;
}

/**
 * implements hook_THEMEHOOK_view_alter
 */
function mcapi_signatures_mcapi_transaction_view_alter(&$build) {
  if (@$build['#theme'] == 'certificate' && isset($build['#mcapi_transaction']->signatures)) {
    $build['mcapi_signatures'] = array(
      '#theme' => 'mcapi_signatures',
      '#transaction' => $build['#mcapi_transaction'],
      '#attached' => array('css' => array(drupal_get_path('module', 'mcapi_signatures') .'/templates/signatures.css'))
    );
  }
}

/**
 * implements template_preprocess_THEMEHOOK
 */
function template_preprocess_mcapi_signatures(&$vars) {
  $plugin = transaction_transitions('sign');
  foreach ($vars['transaction']->signatures as $uid => $signed) {
    $account = user_load($uid);
    $vars['signatures'][$uid] = array(
      'account' => $account,
      'class' => 'signature '. (empty($signed) ? 'pending' : 'signed'),
      'name' =>  $account->getUsername(),
    );
  }
}

/**
 * implements hook_mcapicurrencies_default_alter
 * //TODO How is config altered in D8?
 */
function mcapi_signatures_mcapicurrencies_default_alter(&$currencies) {
  //todo, loop these coz they are the same
  foreach ($currencies as $curr_id => $currency) {
    $callbacks = array(
      'transaction_access_callback_signatory',
      'transaction_access_callback_perm_manage_all'
    );
    $currencies[$curr_id]->data->access_view[TRANSACTION_STATE_PENDING] = array_combine($callbacks, $callbacks);
    $currencies[$curr_id]->data->undo_states[TRANSACTION_STATE_PENDING] = array_combine($callbacks, $callbacks);
  }
}

/**
 * sign a transaction
 * change the state if no more signatures are left
 */
function transaction_sign(TransactionInterface $transaction, $account) {
  if (array_key_exists($account->id(), $transaction->signatures)) {
    $transaction->signatures[$account->id()] = REQUEST_TIME;
    //set the state to finished if there are no outstanding signatures
    if (array_search(0, $transaction->signatures) === FALSE) {
      $transaction->set('state', TRANSACTION_STATE_FINISHED);
    }
    $transaction->save();
  }
  else {
    //this should never happen
    drupal_set_message('@name cannot sign this transaction', 'warning');
  }
}

/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_signatures_entity_extra_field_info() {
  return array(
    'user' => array(
      'user' => array(
        'display' => array(
          'mcapi_signatures' => array(
            'label' => t('Pending transactions'),
            'description' => t('Transactions yet to be signed'),
            'weight' => 0,
          ),
        )
      )
    )
  );
}

/**
 * implement hook_user_view().
 */
function mcapi_signatures_user_view($account, $mode, $language) {
  module_load_include('inc', 'mcapi_signatures');
  $account->content['mcapi_signatures'] = list_pending();
}

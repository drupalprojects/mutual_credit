<?php
/*
 * Drupal 7 intertrading client
 */
define('INTERTRADING_API_VERSION', 1.0);
define('INTERTRADING_REF_URL',
  str_replace('www.', '', @$_SERVER['HTTP_HOST']). str_replace('/index.php', '', $_SERVER['SCRIPT_NAME']) .'/?q=');
require('intertrading.inc'); //functions shared with server

/*
 * implements hook_menu
 */
function intertrading_menu() {
  $items['statement'] = array(
    'title' => 'Trading network',
    'description' => 'Display statistics about this exchange in the Community Forge network',
    'page callback' => 'statement',
    'access arguments' => array('access statement'),
    'menu_name' => 'secondary-links',
    'file' => 'intertrading.admin.inc',
    'weight' => 1
  );

  if ($currcode = variable_get('intertrading_currcode') && variable_get('intertrading_uid')) {
    mcapi_init();//
    $transaction =  entity_create('transaction', array(
      'currcode' => variable_get('intertrading_currcode', NULL),
      'quantity' => 0
    ));
    $items['transact/remote'] = array(
      'title' => 'Remote transaction',
      'description' => 'Trade with another exchange in the network',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('remote_1stpary_form', $transaction),
      'access arguments' => array('intertrade'),
      'file' => 'intertrading.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 1
    );
    $items['transact/remote/1stparty'] = array(
      'title' => '1st party',
      'description' => 'Transfer with another exchange',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => 1
    );
    $items['intertrade/replicate'] = array(
      'title' => 'Replicate transaction history to server',
      'page callback' => 'report_intertrading_history',
      'access callback' => 'intertrading_check_key',
      'access arguments' => array(),
      'type' => MENU_CALLBACK,
    );
  }
  $items['intertrade'] = array(
    'page callback' => 'intertrading_passive',
    'access callback' => 'intertrading_check_key',
    'type' => MENU_CALLBACK,
  );
  $items['admin/accounting/intertrade'] = array(
    'title' => 'Trading network',
    'description' => "Credit clearing systems are by nature closed systems. But it is possible to make meta credit-clearing systems, composed of local systems, each trusting the the credit of the others. This is called 'intertrading', It widens the scope of your market, and it brings with it a new level of governance and accountability. ",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('intertrading_settings'),
    'access arguments' => array('manage all transactions'),
    'file' => 'intertrading.admin.inc',
    'weight' => 4
  );
  return $items;
}


/*
 * implements hook_permission
 */
function intertrading_permission() {
  return array(
    'access statement' => array(
      'title' => t('access statement'),
      'description' => t('View the aggregating trading stats which show the activity of this exchange to the trading network.')
    ),
    'intertrade' => array(
      'title' => t('Intertrade'),
      'description' => t('Initiate transactions with other exchanges')
    )
  );
}

/*
 * implements hook_forms
 * $args[0] => $transaction
 */
function intertrading_forms($form_id, $args) {
  $forms['remote_incoming_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  $forms['remote_outgoing_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  $forms['remote_1stpary_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  return $forms;
}

/*
 * access callback for menu items
 */
function intertrading_check_key() {
  $post = intertrading_get_post();
  if (empty($post) || substr($_GET['q'], 0, 10) != 'intertrade' || $GLOBALS['user']->uid) {
    return FALSE;
  }
  if ($post['key'] != variable_get('intertrading_key', '')) {
    watchdog(
      'intertrading',
      'server passed wrong key, @key to this client. Actual key is @key1',
      array('@key' => $post['key'], '@key1' => variable_get('intertrading_key', '')),
      WATCHDOG_ERROR
    );
    mail('matslats@gmail.com', 'intertrading key mismatch', 'http://'.INTERTRADING_REF_URL);
    intertrading_respond(20, array('@server' => INTERTRADING_REF_URL, '@message' => 'wrong key'));
  }
  $GLOBALS['user'] = user_load(variable_get('intertrading_uid', 0));
  return TRUE;
}

/*
 * implements hook_form_FORM_ID_alter
 * injects the lat lon variables into the site_information form
 * no validation
 */
function intertrading_form_system_site_information_settings_alter(&$form) {
  $form['coordinates'] = array(
    '#title' => t('Geolocation'),
    '#description' => t('The intertrading server would like to know where you are.') .' '. t('To determine your coordinates, please visit !link', array('!link' => l('http://www.whatsmygps.com/', 'http://www.whatsmygps.com/'))),
    '#type' => 'fieldset',
    'site_latitude' => array(
      '#type' => 'textfield',
      '#title' => t('Latitude'),
      '#default_value' => variable_get('site_latitude', 0),
      '#element_validate' => array('intertrading_validate_coords'),
      '#weight' => 0,
    ),
    'site_longitude' => array(
      '#type' => 'textfield',
      '#title' => t('Longitude'),
      '#default_value' => variable_get('site_longitude', 0),
      '#element_validate' => array('intertrading_validate_coords'),
      '#weight' => 1,
    ),
    '#weight' => -5
  );
}

/*
 * implements hook_theme
 */
function intertrading_theme() {
  return array (
    'statement' => array(
      'arguments' =>array(
        'data' => array()
      )
    )
  );
}

//announce to the intertrading server
//always make a new key
function intertrading_handshake() {
  $data = _intertrading_handshake() + _intertrading_report();
  $new_key = md5(time() . user_password());//could be anything...
  $data['new_key'] = $new_key;
  $data['key'] = $new_key;
  $result = intertrading_json_client_request('exchange/handshake', $data);
  if ($result->code == 'OK') {
    //if the result is good then save the key
    variable_set('intertrading_key', $data['new_key']);
    watchdog('intertrading', 'server accepted new key: @key', array('@key' => $data['new_key']), WATCHDOG_INFO);
    $result->message = t('You have an account on the intertrading server.');
  }
  drupal_set_message($result->message, $result->code == 'OK' ? 'status' : 'warning');
}

function _intertrading_handshake() {
  $currency = currency_load(variable_get('intertrading_currcode', ''));
  if (!$currency) {
    drupal_set_message('Intertrading requires a currency to be specified', 'error');
    return array();
  }
  $stats['mail'] = variable_get('site_mail', '');
  $stats['api'] = INTERTRADING_API_VERSION;
  $stats['ticks'] = variable_get('intertrading_ticks', 0);
  if (isset($currency->divisions)) {
    //divisions is either string '01' or an keyed array
    $stats['divisions'] = $currency->divisions == '01' ? '01' : implode('|', array_keys($currency->divisions));
  }
  //I can't help think there's a better way of counting unique traders without using the optional transaction_index table
  $uids = array();
  $result = db_query("SELECT DISTINCT(payer) FROM {mcapi_transactions} UNION SELECT DISTINCT(payee) FROM {mcapi_transactions}")->fetchCol();
  foreach ($result as $uid) {
    $uids[$uid] = 1;
  }
  $stats['traders'] = count($uids);
  $stats['transactions'] = db_query(
    "SELECT COUNT(xid) from {mcapi_transactions} t
    LEFT JOIN {field_data_worth} fw ON t.xid = fw.entity_id
    WHERE t.state = :state AND fw.worth_currcode = :currcode AND created > :created",
    array(
      ':state' => TRANSACTION_STATE_FINISHED,
      ':currcode' => variable_get('intertrading_currcode', ''),
      ':created' => strtotime('-30 days')
    )
  )->FetchField();

  $stats['first_trade'] = db_query("SELECT min(created) FROM {mcapi_transactions}")->fetchField();
  $stats['name'] = variable_get('site_name', '');
  //the rest are optional
  $stats['visibility'] = db_query('SELECT rid FROM {role_permission} WHERE rid = :rid AND permission = :perm',
    array(':rid' => DRUPAL_ANONYMOUS_RID, ':perm' => 'access statement')
  )->fetchField();
  $stats['logo'] = theme_get_setting('logo');
  $stats['lat'] = variable_get('site_lat', 0);
  $stats['lon'] = variable_get('site_lon', 0);
  return $stats;
}

function _intertrading_report() {
  $currcode = variable_get('intertrading_currcode', '');
  $query = "SELECT COALESCE(SUM(fw.worth_quantity), 0) FROM {mcapi_transactions} t
    LEFT JOIN {field_data_worth} fw ON t.xid = fw.entity_id
    WHERE t.state > 0 AND fw.worth_currcode = :currcode AND created > :created";
  $replacements = array(
    ':created' => strtotime('-1 year'),
    ':currcode' => $currcode
  );
  $stats['volume'] = db_query($query, $replacements)->fetchField();
  //this isn't foolproof. but then nothing is
  //the intention is to identify an account or even group of accounts which are so far in debt (or credit)
  //that they will never return to zero
  //getting lots of balances is tricky in mcapi.module coz they are not cached
  if (module_exists('mcapi_index_views')) {
    //but balances can be easily calculated with the index module
    $bal = db_query("SELECT SUM(diff) FROM {mcapi_index} WHERE currcode = :currcode GROUP BY uid1 ORDER BY SUM(diff) ASC LIMIT 0,1", array(':currcode' => $currcode))->fetchField();
    $stats['deficit'] = floatval($bal);
  }
  else {
    //retrieve the smallest balance from a cunningly placed variable
    $stats['deficit'] = array_shift(variable_get('mcapi_deficit', array()));
  }
  //checks that all balances add up to zero
  //In mcapi.module for drupal 7, they must, because there is no caching of balances
  $stats['integrity'] = TRUE;
  $stats['balance'] = transaction_totals(variable_get('intertrading_uid', 0), $currcode)->balance;
  return $stats;
}


function intertrading_validate_coords(&$element, &$form_state) {
  if (!is_numeric($element['#value'])) {
    form_error($element, t('Coordinates must be numeric'));
  }
  if ($element['#value'] > 180 || $element['#value'] < -180) {
    form_error($element, t('Coordinates out of range: @val', array('@val' => $element['#value'])));
  }
}

/*
 * implements mcapi hook_info_types
 */
function intertrading_mcapi_info_types() {
  return array('remote');
}
/*
 * wrapper around intertrading json request
 * adds client validation criteria to the POST
 */
function intertrading_json_client_request($path, $data = array()) {
  $variables = array(
    'intertrading_uid' => t('Account for external transactions'),
    'intertrading_server' => t('Intertrading server'),
    'intertrading_currcode' => t('Intertrading currency'),
    'intertrading_ticks' => t('Ticks')
  );
  foreach ($variables as $varname => $title) {
    $$varname = variable_get($varname, 0);
    if (!$$varname) {
      return (object)array(
        'code' => -1,
        'message' => t('@varname not set. Configure intertrading at !link', array(
          '@varname' => $title,
          '!link' => l('admin/accounting/intertrade', 'admin/accounting/intertrade')
        ))
      );
    }
  }
  return intertrading_json_request(
    'http://'. $intertrading_server .'/'. $path,
    $data += array(
      'key' => variable_get('intertrading_key', ''),
      'src_url' => INTERTRADING_REF_URL
    )
  );
}
//menu callback
//force a deliberate choice of intertrading form
function intertrading_direction() {
  return array(
    array(
      '#markup' => t('Which way will the transaction go?')
    ),
    array(
      '#theme' => 'item_list',
      '#type' => 'ul',
      '#items' => array(
        l('Pay out to another site', 'transact/remote/outgoing'),
        l('Request in from another site', 'transact/remote/incoming'),
      )
    )
  );
}


/*
 * implements  hook_form_remote_1stparty_form_alter
 * heavily modifies the base transaction form
 */
function intertrading_form_remote_1stpary_form_alter(&$form, &$form_state) {
  if (empty($form_state['step']) || $form_state['step'] == 1)  {
    $form['direction'] = array(
      '#title' => t('Direction'),
      '#type' => 'select',
      '#options' => array(
        'incoming' => t('Request'),
        'outgoing' => t('Payment')
      )
    );
    if (!isset($form_state['server_params'])) {
      intertrading_form_prepare($form, $form_state);
    }
    unset($form['payee']);
    $form['1stperson'] = $form['payer'];
    unset($form['payer']);
    $form['1stperson']['#title'] = t('Local trader');
    $form['1stperson']['#default_value'] = $GLOBALS['user']->uid;
    $form['1stperson']['#hidden'] = !user_access('manage all transactions');
    $form['1stperson']['#weight'] = -10;
    $form['1stperson']['#exclude'] = variable_get('intertrading_uid');
    $form['#validate'] = array('intertrading_transaction_form_validate_1stparty');
    $form['#submit'] = array('intertrading_transaction_form_submit');
  }
  else {//step 2
    drupal_set_title(t('Are you sure?'));
    //clear the transaction fields because the value is in form_state['storage']
    foreach(element_children($form) as $fieldname) {
      if (in_array($fieldname, array('actions', 'form_id', 'form_build_id', 'form_token'))) continue;
      unset($form[$fieldname]);
    }
    $form['preview'] = array(
      '#type' => 'markup',
      '#markup' => drupal_render(transaction_view($form_state['transactions'], 'certificate'), 'token')
    );
    $form['buttons']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Confirm')
    );
    $form['#validate'] = array('intertrading_transaction_form_validate');
    $form['#submit'] = array('intertrading_transaction_form_submit');
  }
}


function intertrading_form_prepare(&$form, &$form_state) {
  $form_state['step'] = 1;
  if (!isset($form_state['server_params'])) {
    $result = intertrading_json_client_request('exchange/prepare', _intertrading_report());
    if ($result->code == 'OK') {
      $currcode = variable_get('intertrading_currcode', NULL);
      $form_state['server_params'] = $result->args;
      if (array_key_exists('#value', $form['direction'])) {
        if ($form['direction']['#value'] == 'incoming') {
          if (isset($form_state['server_params']['earn_limit'])) {
            if ($form_state['server_params']['earn_limit'] < 0) {
              form_set_error('', t('No receipts are possible at this time'));
              $form['#disabled'] = TRUE;
            }
            else {
              //$form['worth'][LANGUAGE_NONE][0]['#max'][$currcode] = $form_state['server_params']['earn_limit'];
              drupal_set_message(t('The most @name can receive is !amount', array(
                '@name' => variable_get('site_name', NULL),
                '!amount' => theme('worth_item', array('quantity' => $form_state['server_params']['earn_limit'], 'currcode' => $currcode))
              )));
            }
          }
        }
        elseif ($form['direction']['#value'] == 'outgoing') {
          if (isset($form_state['server_params']['spend_limit'])) {
            if ($form_state['server_params']['spend_limit'] < 0) {
              form_set_error('', t('No payments are possible at this time'));
              $form['#disabled'] = TRUE;
            }
            else {
              //$form['worth'][LANGUAGE_NONE][0]['#max'][$currcode] = $form_state['server_params']['spend_limit'];
              drupal_set_message(t('The most @name can pay is !amount', array(
                '@name' => variable_get('site_name', NULL),
                '!amount' => theme('worth_item', array('quantity' => $form_state['server_params']['spend_limit'], 'currcode' => $currcode))
              )));
            }
          }
        }
      }
    }
    else {
      //request failed
      drupal_set_message($result->message, 'error');
      $form['#disabled'] = TRUE;
      $form_state['server_params']['sites'] = array();
    }
  }
  $form['dest_user'] = array(
    '#title' => t('Email address of remote user'),
    '#type' => 'textfield',
    '#weight' => -3
    //this can't be validated because it's an address on another system
  );
  //tweak the default form; hide the state and set the transaction type
  $form['state']['#access'] = FALSE;
  $form['type']['#value'] = 'remote';
  $form['type']['#type'] = 'hidden';
  $form['dest_url'] = array(
    '#title' => t('Remote exchange'),
    '#description' => l(t('Not listed?'), 'intertrading/help'),
    '#type' => 'select',
    '#options' => array('' => t('Please choose...')) + $form_state['server_params']['sites'],
    '#required' => TRUE,
    '#weight' => -10,
  );
  unset($form['dest_url']['#options'][INTERTRADING_REF_URL]);
  //provides consistency with the forms module, particularly for function mcapi_signatures_form_transaction_form_alter
  $form['#step'] = $form_state['step'];
}

function intertrading_transaction_form_validate_1stparty(&$form, &$form_state) {
  $values = &$form_state['values'];
  if ($values['direction'] == 'incoming') {
    $values['payer'] = variable_get('intertrading_uid');
    $values['payee'] = $values['1stperson'];
  }
  else {
    $values['payee'] = variable_get('intertrading_uid');
    $values['payer'] = $values['1stperson'];
  }
  intertrading_transaction_form_validate($form, $form_state);

}

/*
 * form validation callback for intertrading_transaction_form
 * if the form has validated so far
 * build the transaction and send it to the intertrading server
 */
function intertrading_transaction_form_validate(&$form, &$form_state) {
  if ($form_state['step'] < 2) {
    if ($message = user_validate_mail($form_state['values']['dest_user'])) {
      form_set_error('dest_user', $message);
    }
    if (form_get_errors()) return;

    //make a local version of the transaction with the intertrading account, and validate it as normal
    transaction_form_validate($form, $form_state);
    if (form_get_errors()) return;
    //try the form submission with the intertrading server
    $result = intertrading_send_transaction($form_state['values'], $form_state['values']['direction'], FALSE);
    if ($result->code != 'OK') {
      form_set_error('', $result->message);
      return;
    }
    $form_state['step']++;
    $form_state['rebuild'] = TRUE;
    $copy = $form_state;
    //form_state_values_clean($copy);
    $form_state['storage'] = $copy['values'];
  }
}

/*
 * form submit callback for intertrading_transaction_form
 */
function intertrading_transaction_form_submit($form, &$form_state) {
  $values = &$form_state['storage'];
  $values['extra']['dest_url'] = $values['dest_url'];
  $values['extra']['dest_user'] = $values['dest_user'];

  if (intertrading_send_transaction($values, $values['direction'], TRUE)->code == 'OK') {//which should always be the case
    $transaction = entity_create('transaction', $values);
    transaction_cluster_create($transaction, TRUE);//returns $transactions
    drupal_set_message('Transaction saved with remote site.');
    $form_state['redirect'] = 'transaction/'.$transaction->serial;
  }
  else {
    drupal_set_message(t('There was a problem saving the transaction on the remote site.'), 'warning');
  }
}

function intertrading_send_transaction($values, $direction, $really = FALSE) {
  $incoming = $direction == 'incoming';
  $desc_field = variable_get('transaction_description_field', '');
  $data = array(
    'payer' => $incoming ? $values['dest_user'] : user_load($values['payer'])->mail,
    'payer_url' => $incoming ? $values['dest_url'] : INTERTRADING_REF_URL,
    'payee' => $incoming ? user_load($values['payer'])->mail : $values['dest_user'],
    'payee_url' => $incoming ? INTERTRADING_REF_URL :  $values['dest_url'],
    'quantity' => $values['worth'][LANGUAGE_NONE][0]['quantity'],
    'src_url' => INTERTRADING_REF_URL,
    'dest_url' => $values['dest_url'],
    'description' => $desc_field ? $values[$desc_field][LANGUAGE_NONE][0]['value'] : '',
    'date' => REQUEST_TIME,
    'really' => $really
  );
  //this should overwrite whichever of payer and payee is the local intertrading account
  return intertrading_json_client_request('transaction/try', $data);
}


/*
 * Main function for the server to send a transaction here.
 * converts, validates and saves the transaction.
 * returns usual json object format, with OK or an error code
 */
function intertrading_passive() {
  $post = intertrading_get_post();
  if ($error = intertrading_validate_transaction_post($post)) {
    intertrading_respond($error[0], $error[1]);
  }
  $local_trader_mail = $post['dest_url'] == $post['payer_url'] ? $post['payer'] : $post['payee'];
  if ($local_trader = user_load_by_mail($local_trader_mail)) {
    $outgoing = $post['dest_url'] == $post['payee_url'];
    $props = array(
      'creator' => variable_get('intertrading_uid'),
      'state' => TRANSACTION_STATE_FINISHED,
      'payer' => $outgoing ? variable_get('intertrading_uid', 0) : $local_trader->uid,
      'payee' => $outgoing ? $local_trader->uid : variable_get('intertrading_uid', 0),
      'type' => 'remote',
      'worth' => array(
        LANGUAGE_NONE => array(
          0 => array(
            'quantity' => $post['quantity'],
            'currcode' => variable_get('intertrading_currcode', '')
          )
        )
      ),
      'description' => urldecode($post['description'])
    );
    $transaction = entity_create('transaction', $props);
  }
  else {
    intertrading_respond(28, array('@client' => INTERTRADING_REF_URL, '@mail' => $local_trader_mail));
  }

  try {
    //should be using entity_API_create to create the transaction here
    transaction_cluster_create($transaction, $post['really']);
    intertrading_respond('OK');
  }
  catch (Exception $e) {
    if ($d = $e->getPrevious()) {
      $errors = unserialize($d->getMessage());//see limits exception handling
      //convert the values FROM minutes to the src systems currency
      intertrading_respond(24, array('@message' =>  $d->getMessage()));//the message is deprecated because it was too complicated
    }
    $code = 25;
    $args = array('@message' => $e->getMessage() . print_r($transaction, 1));

    watchdog('intertrading', '@message: @transaction', array(
      '@message' => intertrading_error_codes($code, $args),
      '@transaction' => print_r($transaction, 1) //this may repeat the above $transaction
    ), WATCHDOG_ERROR);
    //we should really convert the excess here
    intertrading_respond($code, $args);
  }
}

/*
 * implements hook_help
 */
function intertrading_help($path, $args) {
  if ($path == 'admin/accounting/intertrade') {
    $result = intertrading_json_client_request('intertrading/help/json');
    if ($result->code != 'OK') {
      drupal_set_message($result->message, 'error');
      return ;
    }
    $args = &$result->args;
    $args['@name'] = variable_get('site_name', '');
    $statuses = array(
      '-1' => t('No account'),
      '0' => t('Account blocked'),
      '1' => t('Account active')
    );
    $help = $args['@message'] . '<hr />';
    $help .= '<p>'.t('@name account status is: @status',
      array('@name' => $result->args['@name'], '@status' => $statuses[$args['@status']]));
    //following applies only if the account has been created already
    if ($args['@status'] != -1) {
      $args['!balance'] = theme('worth_item', array('quantity' => $args['@balance'], 'currcode' => variable_get('intertrading_currcode')));

      $help .= '<br />'.t('@name account balance is !balance', $result->args);
      if (isset($result->args['@min']) && isset($result->args['@max'])) {
        $help .= '<br />'.t('@name can trade between: @min & @max', $result->args);
      }
      else{
        if (isset($result->args['@min'])) {
          $help .= '<br />'.t('@name must trade above: @min', $result->args);
        }
        elseif(isset($result->args['@max'])) {
          $help .= '<br />'.t('@name must trade below: @max', $result->args);
        }
      }
      $help .= '<br />'.t('Transactions so far: @count', $result->args);
      $help .= '<br />Intertrading key: '. variable_get('intertrading_key', '00');
    }
    return $help;
  }
}

function report_intertrading_history() {
  $intertrading_uid = variable_get('intertrading_uid', 0);
  $intertrading_currcode = variable_get('intertrading_currcode', '');
  $output = array();

  $xids = array_keys(transaction_filter(array('involving' => $intertrading_uid, 'currcode' => $intertrading_currcode, 'state' => TRANSACTION_STATE_FINISHED)));
  foreach (entity_load('transaction', $xids) as $transaction) {
    $outgoing = FALSE;
    if ($transaction->payee == $intertrading_uid) $outgoing = TRUE;

    $output[$transaction->xid] = array(
      'payer' => $outgoing ? user_load($transaction->payer)->mail : '',
      'payer_url' => $outgoing ? INTERTRADING_REF_URL : '',
      'payee' => $outgoing ? 0 : user_load($transaction->payee)->mail,
      'payee_url' => $outgoing ? '' : INTERTRADING_REF_URL,
      'src_url' => INTERTRADING_REF_URL, //the url of the client OR blank
      'dest_url' => '', //the url of the client OR blank
      'quantity' => transaction_quant($transaction, $intertrading_currcode), //denominated in src units
      'date' => $transaction->created, //unixtime
    );
    if ($desc = variable_get('transaction_description_field', '')) {
      $field = field_view_field('transaction', $transaction, $desc);
    }
    //rendering the children removes the the title field and stuff
    $output[$transaction->xid]['description'] = isset($field) ? strip_tags(drupal_render_children($field)) : '';
  }
  watchdog('intertrading', 'Uploaded @num transactions to intertrading server', array('@num' => count($output)));

  intertrading_respond('OK', $output);
}

//returns the transaction quant for a given currency, or the first, if no curency is stated
//gets around the problem of not being sure of the language.
function transaction_quant($transaction, $currcode = NULL) {
  $flows = current($transaction->worth);
  if (empty($currcode)) return $flows[0]['quantity'];
  foreach ($flows as $item) {
    if ($item['currcode'] == $currcode) return $item['quantity'];
  }
}

/*
 * implements hook_accounting_validate
 * ensures that the the intertrading account isn't included inadvertently in any transactions
 */
function intertrading_accounting_validate($cluster) {
  foreach ($cluster as $key => $transaction) {
    if ($transaction->type == 'remote') {
      if (!in_array(variable_get('intertrading_uid'), array($transaction->payer, $transaction->payee))) {
        throw new Exception(t('Remote payments must involve the intertrading account'));
      }
    }
    else {//normal transactions
      if (in_array(variable_get('intertrading_uid'), array($transaction->payer, $transaction->payee))) {
        unset($cluster[$key]);
        drupal_set_message(t('Payment involving intertrading account was excluded'), 'warning', FALSE);
      }
    }
  }
}

/*
 * implements hook_form_transaction_form_alter
 * attempt to remove the intertrading account from the list of users
 */
function intertrading_form_transaction_form_alter($form) {
  foreach (array('payer', 'payee', 'secondperson') as $participant) {
    if (array_key_exists($participant, $form)) {
      $uid = variable_get('intertrading_uid');
      if (in_array($form[$participant]['#type'], array('user_chooser_few', 'user_chooser_many'))) {
        $form[$participant]['#exclude'][] = $uid;
      }
      elseif (array_key_exists('#options', $form[$participant])) {
        unset($form[$participant]['#options'][$uid]);
      }
    }
  }
}


/*
 * implements hook_theme_registry_alter
 * adds the remote transaction template suggestion to the theme registry
 */
function intertrading_theme_registry_alter(&$callbacks) {
  $callbacks['certificate__remote'] = array(
    'base hook' => 'node',
    'template' => 'certificate--remote',
    'path' => drupal_get_path('module', 'intertrading')
  ) + $callbacks['certificate'];
}

//create a string for the remote participant which can be used in the template without creating a new translatable string
function remote_participant($data) {
  extract($data); //should create $dest_url and $dest_user, an email address
  return t('@remoteuser at @remotesite',
    array(
      '@remoteuser' => user_access('manage all transactions') ? $dest_user : substr($dest_user, 0, strpos($dest_user, '@')),
      '@remotesite' => str_replace('/?q=', '', $dest_url)
    )
  );
}

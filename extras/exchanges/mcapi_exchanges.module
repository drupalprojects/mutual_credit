<?php

use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Wallet;
use Drupal\mcapi\Exchanges;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\TransactionInterface;
use Drupal\mcapi\WalletInterface;
use Drupal\mcapi\McapiTransactionException;
use Drupal\mcapi_exchanges\Entity\Exchange;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Form\FormStateInterface;
use Drupal\user\Entity\user;
use Drupal\og\Entity\OgMembership;
use Drupal\mcapi\Mcapi;


define('EXCHANGE_OG_REF', 'mcapi_exchange_og_ref');

/**
 * implements hook_entity_info_alter().
 * add new handlers for the Exchange entity
 */
function mcapi_exchanges_entity_type_alter(array &$entity_types) {
  $e = $entity_types['mcapi_exchange'];
  $e->setFormClass("add", "Drupal\mcapi_exchanges\Form\ExchangeWizard");
  $e->setFormClass("edit", "Drupal\mcapi_exchanges\Form\ExchangeForm");
  $e->setFormClass("masspay", "Drupal\mcapi_exchanges\Form\MassPay");
  $e->setFormClass("delete", "Drupal\mcapi_exchanges\Form\ExchangeDeleteConfirm");
  $e->setFormClass("enable", "Drupal\mcapi_exchanges\Form\ExchangeEnableConfirm");
  $e->setFormClass("disable", "Drupal\mcapi_exchanges\Form\ExchangeDisableConfirm");
  $e->setLinkTemplate("canonical", "mcapi.exchange.view");
  $e->setLinkTemplate("edit-form", "mcapi.exchange.edit");
  $e->setLinkTemplate("field_ui_base_route", "mcapi.admin_exchange_list");
  $e->setLinkTemplate("delete-form", "mcapi.exchange.delete_confirm");
  $e->setLinkTemplate("enable", "mcapi.exchange.enable_confirm");
  $e->setLinkTemplate("disable", "mcapi.exchange.disable_confirm");
  $e->setViewBuilderClass("Drupal\mcapi_exchanges\ExchangeViewBuilder");
  $e->setAccessClass("Drupal\mcapi_exchanges\ExchangeAccessControlHandler");
  $e->setListbuilderClass("Drupal\mcapi_exchanges\ExchangeListBuilder");
  //there isn't an explicit method for views_data yet
  $e->setHandlerClass('views_data', "Drupal\mcapi_exchanges\ExchangeViewsData");
  $e->set('field_ui_base_route', "mcapi.admin_exchange_list");
  if (array_key_exists('1stparty_editform', $entity_types)) {
    $entity_types['1stparty_editform']->setListbuilderClass("Drupal\mcapi_exchanges\FirstPartyEditFormListBuilderExchanges");
  }
  $entity_types['mcapi_currency']->setListbuilderClass("Drupal\mcapi_exchanges\CurrencyListBuilderExchanges");
}

/**
 * implements hook_ENTITY_TYPE_load().
 * add the 'exchange arguments to the transactions view
 * @param type $entities
 * @todo see if this works in mcapi"_exchanges.views.inc
 */
function mcapi_exchanges_view_load(&$entities) {

return;

  if (array_key_exists('mcapi_transactions', $entities)) {
    $display = $entities['mcapi_transactions']->getDisplay('default');
   
    $display['display_options']['arguments']['exchange'] = array (
      'id' => 'exchange',
      'table' => 'mcapi_transaction',
      'field' => 'exchange',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'dependencies' => array(
        'module' => array(
          0 => 'mcapi',
          1 => 'views',
        ),
      ),/*
      'default_action' => 'ignore',
      'exception' => array(
        'value' => 'all',
        'title_enable' => false,
        'title' => 'All',
      ),
      'title_enable' => false,
      'title' => '',
      'default_argument_type' => 'fixed',
      'default_argument_options' => array(
        'argument' => '1',
      ),
      'default_argument_skip_url' => false,
      'summary_options' => array(
        'base_path' => '',
        'count' => true,
        'items_per_page' => 25,
        'override' => false,
      ),
      'summary' => array(
        'sort_order' => 'asc',
        'number_of_records' => 0,
        'format' => 'default_summary',
      ),*/
      'specify_validation' => true,
      'validate' => array(
        'type' => 'entity:mcapi_exchange',
        'fail' => 'access denied',
      ),
      'validate_options' => array(
        'access' => '1',
        'operation' => 'view',
        'multiple' => '1',
        'bundles' => NULL,
      ),
      'break_phrase' => false,
      'not' => 0,
      'plugin_id' => 'transaction_exchange',
      'provider' => 'mcapi',
    );
    $display = $entities['mcapi_transactions']->addDisplay('default', $display);
    debug($display);
//    debug($entities['mcapi_transactions']->getDisplay('default')['display_options']['arguments']['exchange']);
  }
}

function mcapi_exchanges_menu_links_discovered_alter(&$definitions) {
  unset($definitions['mcapi.exchange.masspay']);
}

/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_exchanges_entity_extra_field_info() {
  $extra['mcapi_exchange']['mcapi_exchange']['display']['transactions'] = array(
    'label' => t('Intertrading'),
    'description' => t('Link to the wallets special intertrading wallet'),
    'weight' => 2,
  );
  $extra['mcapi_exchange']['mcapi_exchange']['display']['wallets'] = array(
    'label' => t('Wallets'),//this could be configured to show the display mode
    'weight' => 11
  );
  $extra['mcapi_exchange']['mcapi_exchange']['display']['people'] = array(
    'label' => t('People'),
    'description' => t('People involved in the exchange'),
    'weight' => 1,
  );
  return $extra;
}

/**
 * implements hook_form_alter()
 * add a submit callback to the wallet settings
 */
function mcapi_exchanges_form_mcapi_wallet_settings_form_alter(&$form, &$form_state) {
  debug(array_keys($form['creation']['entity_types']), 'filter the entity_types for only those entities with an EXCHANGE_OG_REF field');
  $form['creation']['#description'] = ' '. t('Only bundles which are in exchanges are shown here.');
  $form_state->loadInclude('install', 'mcapi_exchanges');
  $form['actions']['submit']['#submit'][] = 'mcapi_exchanges_check_og_fields';
}

/**
 * implements hook_entity_insert();
 * Ensure an entity's wallets are in the same exchange(s) as the entity
 */
function mcapi_exchanges_entity_insert($entity) {
  put_owned_wallets_in_exchanges($entity);
}
/**
 * implements hook_entity_update();
 * Ensure an entity's wallets are in the same exchange(s) as the entity
 */
function mcapi_exchanges_entity_update($entity) {
  put_owned_wallets_in_exchanges($entity);
}

/*
 * ensure that the wallets of every wallet-owning entity are in the same exchanges as their owner
 */
function put_owned_wallets_in_exchanges($entity) {
  $count = 0;
  if (Mcapi::walletable($entity)) {
    if ($wids = Wallet::ownedBy($entity)) {
      $belongsToExchanges = $entity->getEntityTypeId() == 'mcapi_exchange' ?
        [$entity] :
        $entity->get(EXCHANGE_OG_REF)->referencedEntities();//TODO 
      
      foreach (Wallet::loadMultiple($wids) as $wallet) {
        //each wallet is in exactly the same exchanges as the parent.
        $wallet->set(EXCHANGE_OG_REF, $belongsToExchanges);
        $wallet->save();
        $count++;
      }
      //todo check this after the OG api is written and implemented, and used above
      //foreach ($belongsToExchanges as $exchange)debug($wids, 'check these wallets are in exchanges: '.$exchange->id());
    }
  }
  drupal_set_message(
    "Put $count wallets belonging to ".$entity->bundle() .' '.$entity->id(). ' into exchanges: '.
      implode(', ', array_keys((array)$belongsToExchanges))
  );
}

function mcapi_exchanges_element_info_alter($info) {
  $info['select_wallet']['#process'][] = 'mcapi_exchanges_process_wallet';//might want to move this to another file or class
}

function mcapi_exchanges_process_wallet(&$element, FormStateInterface &$form_state) {
  $exchanges = $element['#exchanges'] ? : array_keys(Exchanges::in());
  $element['#autocomplete_route_parameters'] = array('exchanges' => implode(',', $exchanges));
  return $element;
}


/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields to the exchange
 */
function mcapi_exchanges_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  $count = db_select("user__exchanges", 'e')->fields('e', array('entity_id'))
  ->condition('exchanges_target_id', $entity->id())
  ->countQuery()->execute()->fetchField();
  $build['members_link'] = array(
    '#type' => 'item',
    '#title' => t('@count members', array('@count'=> $count)),
    'link' => array(
      '#type' => 'link',
      '#title' => t('Show members'),
      '#href' => 'exchange/'.$entity->id().'/members',
      //maybe instead put a view with the last five members here
      '#options' => array(
        'attributes' => new Attribute(array('title' => "This view doesn't exist yet"))
      )
    )
  );
}


/**
 * get the exchanges a transaction and its children are in.
 * Children may be in a different exchange to their parents
 *
 * @param Drupal\mcapi\Entity\Transaction $transaction
 *   A single transaction entity, (with no children)
 *
 * @todo check that we actually have a good use for this function. SHould it return ids or entities?
 *
 * @return integer[]
 *   the first value will be the parent transaction exchange ID
 */
function mcapi_transaction_get_exchanges(Transaction $transaction) {
  foreach ($transaction->flatten() as $t) {
    //generally we only need one, so take the first
    $exchanges[] = $t->exchange->target_id;
  }
  return exchanges;
}

/**
 * implements hook_mcapi_transaction_alter().
 * if the wallets are in different exchanges, and other context allows
 * split the transaction into 2
 */
function mcapi_exchanges_mcapi_transaction_alter(TransactionInterface $transaction) {
  $common_exchanges = array_intersect_key(
    Exchanges::walletInExchanges($transaction->payer->entity),
    Exchanges::walletInExchanges($transaction->payee->entity)
  );
  if ($common_exchanges) {
    mcapi_exchange_join($exchange->id(), array($transaction));
    //$transaction->set('exchange', reset($common_exchanges)->id());
    return;
  }
  $transaction_curr_ids = $transaction->worth->currencies();
  $my_exchange_ids = Exchanges::in();
//TODO delete this
if (!is_array($my_exchange_ids)){print_r($my_exchange_ids);die('mcapi_exchanges_mcapi_transaction_alter');}
  $payer_exchanges = Exchanges::walletInExchanges($transaction->payer->entity, TRUE);
  $common = Exchange::loadMultiple(array_intersect($payer_exchanges, $my_exchange_ids));
  foreach ($common as $exchange) {
    if (has_currencies($exchange, $transaction_curr_ids))  {
      mcapi_exchange_join($exchange->id(), array($transaction));
      $source = 'payer';
      $dest = 'payee';
      break;
    }
  }
  $source = 0;
  if (empty($set))  {
    $exchange_ids = array_intersect(Exchanges::walletInExchanges($transaction->payee->entity, TRUE), $my_exchange_ids);    
    foreach (Exchange::loadMultiple($exchange_ids) as $exchange) {
      if (has_currencies($exchange, $transaction_curr_ids))  {
        mcapi_exchange_join($exchange->id(), array($transaction));
        $source = 'payee';
        $dest = 'payer';
        break;
      }
    }
  }
  $violations = [];
  if (!$source) {
    throw new McapiTransactionException('worth', 'Neither party can access all the currencies in the transaction: '.implode(', ', $transaction_curr_ids));
  }

  //We have to check if a transaction is even possible.
  //this means there is at least one currency in the transaction not common to both wallets' exchanges

  //That means we create a transaction between each wallet and its exchange's _intertrading wallet
  //In effect the current transaction is altered and a child added

  //Whichever wallet which can use all the currencies in the transaction is the 'source' wallet.
  //In an intertrading split the source wallet takes the existing transactions
  //The dest wallet takes the new (child) transaction and the converted currency values.

  //we might want to abstract this into a plugin or something to allow
  //different mechanisms for taking a commission.


  //We need to identify a dest exchange whose intertrading wallet can be used
  //which of the $dest_wallet's parent's exchanges is most suitable, if any?
  //it must contain all the worth's currencies bar one.
  
  foreach (Exchanges::walletInExchanges($transaction->{$dest}->entity) as $dest_exchange) {
    $dest_exchange_currencies = Mcapi::currencies(array($dest_exchange->id()));
    $diff = array_diff_key(array_flip($transaction_curr_ids), $dest_exchange_currencies);
    //diff is the currencies in worth which are not in the dest exchange
    //if there is no diff, we shouldn't be intertrading but doing a straight transaction
    $source_currency_id = key($diff);//do this now to ensure there is a value for the error
    if (!$diff) {
      throw new McapiTransactionException('Intertrading calculation is running when worth currencies are all matched');
    }
    if (count($diff) > 1) {
      continue;//we won't attempt to convert more than one currency in a transaction
    }
    $source_ticks = Currency::load($source_currency_id)->ticks;
    if (!$source_ticks) {//the one diff currency in this exchange is not intertradable
      continue;
    }
    //when we have found a suitable exchange, stop looping because we need the variables above
    $found = TRUE;
    break;
  }
  if (!isset($found)) {
    return array(
      $source_currency_id,
      //this string is identical to another
      t('There is no way to intertrade this currency between these wallets')
    );
  }
  //so now we have our dest $exchange, a list of $exchange_currencies in it
  //get the first tradable currency in the exchange which isn't one of the other worth values.
  foreach ($dest_exchange_currencies as $curr) {
    if ($curr->ticks) {
      $dest_currency = $curr;
      break;
    }
  }
  if (!isset($dest_currency)) {
    $transaction->violations[$source_currency_id] = t('The destination exchange has no tradable currency.');
    return;
  }


  $new_transaction = clone($transaction);//since it hasn't been saved there is no xid or serial number yet
  $new_transaction->uuid->setValue(\Drupal::service('uuid')->generate());
  $transaction->set($dest, $transaction->exchange->entity->intertrading_wallet()->id());
  $new_transaction->set($source, $dest_exchange->intertrading_wallet()->id());
  $new_transaction->worth->setValue(
    array(
      array(
        'curr_id' => $dest_currency->id(),
        'value' => floor($dest_currency->ticks / $source_ticks * $transaction->worth->val($source_currency_id))
      )
    )
  );
  $transaction->children[] = $new_transaction;
}

/**
 * put an entity in an exchange
 * utility function
 * @param integer $exid
 * @param ContentEntityInterface[] $entities
 * @return boolean 
 *   TRUE if successful
 * @todo remove the old exchanges before or during this function
 */
function mcapi_exchange_join($exid, $entities) {
  //if something joins an exchange, then so do its wallets
  foreach ($entities as $entity) {
    $entity->set(EXCHANGE_OG_REF, $exid);
    $entity->save();
  }
}

/**
 * determine if all the passed currency ids are in the exchange
 * @param unknown $exchange
 * @param unknown $currency_ids
 */
function has_currencies($exchange, $currency_ids) {
  foreach($exchange->currencies->referencedEntities() as $currency) {
    $ids[] = $currency->id;
  }
  return array_intersect($currency_ids, $ids) == $currency_ids;
}


/**
 * Provide the new worthItemList array for an intertrading child transaction
 * @param TransactionInterface $transaction
 *
 * @param WalletInterface $dest_wallet
 *   The wallet in the remote exchange
 * @return array
 *   violation, keyed by fieldname
 */
function intertrading_new_worths(TransactionInterface $transaction, WalletInterface $dest_wallet) {
  $transaction_curr_ids = $transaction->get('worth')->curr_ids();

  return [];//no problems
}

/**
 * implements hook_mcapi_transaction_validate().
 * check that _intertrading wallet is being used correctly.
 * @param array $clusters
 */
function mcapi_exchanges_mcapi_transaction_validate(array $clusters) {
  foreach ($clusters as $transaction) {
echo $transaction->payer->entity->name();
    if ($transaction->payer->entity->name == '_intertrading' || $transaction->payee->entity->name == '_intertrading') {
      //there MUST be a child transaction also with an intertrading wallet in a different exchange.
      foreach ($transaction->children as $child) {
        if ($child->payer->entity->name == '_intertrading' || $child->payee->entity->name == '_intertrading') continue 2;
      }
      throw new \Exception('Intertrading wallet error');
    }
  }
}

/**
 * Implements hook_mail_alter().
 * divert exchange contact mails to the right exchange
 */
function mcapi_exchanges_mail_alter(&$message) {
  print_r($message);die('mcapi_exchanges_mail_alter');
  //if the recipient is mcapi_exchange@drupal then swop it for the owner of the current exchange
  //either that or don't use the contact module to contact exchanges
}

/**
 * implements hook_ENTITY_TYPE_load().
 */
function mcapi_exchanges_contact_category_load($entities) {
  foreach ($entities as $category) {
    if ($category->id == 'exchange') {
      //this might work except for caching and we don't know what exchange we are trying to contact!
      $category->recipients[] = 'mcapi_exchange@drupal';
    }
  }
}


/**
 * Implements hook_form_alter();
 * 
 * Add a submit callback to ContentEntityForms for contentTypes which reference exchanges
 * to check for entities joining and leaving exchanges
 * Form_alter is rather a blunt instrument but it is the best available.
 * Would be better to use hook_entity_presave or postsave but the old values aren't available there
 * 
 * //TODO rewrite this once we have OG working.
 */
function mcapi_exchanges_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (array_key_exists('controller', $form_state) && $form_state->get('controller') instanceof \Drupal\Core\Entity\ContentEntityForm) {
    $entity = $form_state->get('controller')->getEntity();
    $form_state->loadInclude('mcapi', 'inc');
    if (Mcapi::walletable($entity)) {
      array_unshift($form['actions']['submit']['#submit'], 'mcapi_exchanges_changed_submit');
    }
  }
}

/**
 * implements hook_form_alter().
 * adds the exchange option to the designed form
 * @todo work out the function name and alter the config schema for this extra variable
 */
function mcapi_exchanges_form_mcapi_transaction_1stparty_form_alter(&$form, &$form_state) {

  $config = $form_state->getFormObject()->config;  $maxes = $wallet_config->get('autoadd');
debug($maxes);
  $maxes['mcapi_exchange:mcapi_exchange'] = 1;
  $wallet_config->set('autoadd', $maxes);
  $wallet_config->save();
  if ($config->getThirdPartySetting('mcapi_exchanges', 'exchange')) {
    debug($form['payer']);
  }
  if (strpos($config->experience['twig'], '{{ intertrade }}') && Exchanges::in(NULL, TRUE, TRUE)) {
    //this checkbox flips between partner_choosers
    $form['intertrade'] = array(
      '#title' => t('Intertrade'),
      '#description' => t('Trade with someone outside your exchange'),
      '#type' => 'checkbox',
      '#default_value' => 0,
    );
    //make a second partner widget and switch between them
    $form['partner']['#states'] = array(
      'visible' => array(
        ':input[name="intertrade"]' => array('checked' => FALSE)
      )
    );
    $form['partner_all'] = $form['partner'];
    $form['partner_all']['#exchanges'] = [];
    $form['partner_all']['#states']['visible'][':input[name="intertrade"]']['checked'] = TRUE;
  }
}



/**
 * implement hook_FORM_first_party_editform_ALTER().
 * 
 */
function mcapi_exchanges_form_first_party_editform_alter(&$form, FormStateInterface $form_state) {
  //since this is an entity form, we need to get the $config from the $entity.
  $config = $form_state->getBuildInfo()['callback_object']->getEntity();  
  $account = User::load(\Drupal::currentuser()->id());
  $options = [];
  
  
  $exchanges = \Drupal::currentUser()->hasPermission('manage mcapi') ?
    Exchange::loadMultiple() :
    Exchange::loadMultiple();
  drupal_set_message('Exchanges field needs to be limited to only the exchanges of which the current user is a member ', 'warning');
    /* transaction forms might go in exchange groups? */
  foreach ($exchanges as $id => $entity) {
    $options[$id] = $entity->label();
  }
  $form['exchange'] = array(
    '#title' => t('Restricted to exchange:'),
    '#type' => 'select',
    '#empty_option' => t('- All -'),
    '#empty_value' => '',
    '#options' => $options,
    '#default_value' => $config->getThirdPartySetting('mcapi_exchanges', 'exchange'),
    '#weight' => 10,
  );

  $form['actions']['submit']['#submit'][] = 'mcapi_exchanges_first_party_editform_submit';
}

function mcapi_exchanges_first_party_editform_submit(&$form, &$form_state) {
  $form_state->getFormObject()->getEntity()->setThirdPartySetting('mcapi_exchanges', 'exchange', $form_state->getValue('exchange'));
  $form_state->getFormObject()->getEntity()->save();
}

/**
 * field api default value callback
 * when creating a new exchange, populate the currencies field according to the currentuser's access.
 * N.B. in FieldItemList::setValue
 *
 * @param ContentEntityInterface $entity,
 *   the exchange
 * 
 * @param array $field_definition,
 * 
 * @param string $langcode
 *
 * @return uuid[]
 *   uuids whose keys I haven't understood yet
 * 
 * @todo check if this is the best approach usability wise
 */
function mcapi_default_currency_id(EntityInterface $exchange, $field_definition) {
  $output = [];
  //default currencies are the currencies of the exchanges of which the current user is a member
  $exchange_ids = Exchanges::in(NULL, TRUE);
  foreach (Mcapi::currencies($exchange_ids) as $currency) {
    $output[]['target_uuid'] = $currency->uuid;
  }
  return $output;
}

/**
 * field api default value callback
 * when creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * 
 * @param ContentEntityInterface $entity,
 * 
 * @param array $field_definition,
 *
 * @return array
 *   The uuids of the exchanges of which the passed Entity is a member
 *
 * //TODO an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id(ContentEntityInterface $entity, $field_definition) {
  if ($entity->getEntityTypeId == 'user' && $entity->id() == 0)drupal_set_message('putting user 0 in default exchange. Prevent this!');
  $output = [];
  $exchanges = Exchange::loadMultiple(Exchanges::in(NULL, TRUE));
  foreach ($exchanges as $exchange) {
    
    $output[]['target_uuid'] = $exchange->uuid->value;
  }
  return $output;
}


/**admin/modules
 * Get all the wallet ids in given exchanges.
 * this can also be done with Wallet::filter() but is quicker.
 * maybe not worth it if this is only used once, in any case the index table is needed for views.
 * Each wallet owner has a required entity reference field pointing to exchanges.
 * 
 * @param array $exchange_ids
 * 
 * @param array $intertrading
 *   TRUE if _intertrading wallets are included
 *
 * @return array
 *   the non-orphaned wallet ids from the given exchanges
 *
 * @todo refactor this for OG
 */
function get_mcapi_wallets_in_exchanges(array $exchange_ids) {
  $query = db_select('og_membership', 'g')
    ->fields('g', array('etid'))
    ->condition('g.group_type', 'mcapi_exchange')
    ->condition('g.entity_type', 'mcapi_wallet');
  if ($exchange_ids) {
    $query->condition('g.gid', $exchange_ids);
  }
  if (!$intertrading) {
    $query->join('mcapi_wallet', 'w', 'w.wid = g.etid');
    $query->condition('w.name', '_intertrading', '<>');
  }
  return $query->execute()->fetchCol();
}



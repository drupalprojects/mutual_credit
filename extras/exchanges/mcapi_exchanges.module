<?php

use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Exchange;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\TransactionInterface;
use Drupal\mcapi\WalletInterface;
use Drupal\Core\Template\Attribute;
use Drupal\mcapi\McapiTransactionException;

/**
 * implements hook_modules_uninstalled().
 * THIS ISN"T RUNNING move to mcapi_exchanges_uninstall
 *
 * @todo move to .install file, which in alpha14 isn't included
 */
function mcapi_exchanges_uninstall() {
//  if (in_array('mcapi_exchanges', $modules)) {
    //delete all transactions
    module_load_install('mcapi_tester');
    mcapi_tester_delete_transactions();
    //delete all the provided currencies
    foreach (Currency::loadMultiple(array('pp', 'mm', 'ss', 'jj')) as $currency) {
      $currency->delete();
    }
    //delete all exchanges except 1
    foreach (Exchange::loadMultiple() as $exchange) {
      if ($exchange->id() > 1) {
        $exchange->delete();
      }
    }

    put_users_in_exchanges();
    echo 'Removed all testing currencies and exchanges.';
    drupal_set_message('Removed all testing currencies and exchanges.');
//  }
}

/**
 * implements hook_entity_info_alter().
 * add new handlers for the Exchange entity
 */
function mcapi_exchanges_entity_type_alter(array &$entity_types) {
  $e = $entity_types['mcapi_exchange'];
  $e->setFormClass("add", "Drupal\mcapi_exchanges\Form\ExchangeWizard");
  $e->setFormClass("edit", "Drupal\mcapi_exchanges\Form\ExchangeForm");
  $e->setFormClass("masspay", "Drupal\mcapi_exchanges\Form\MassPay");
  $e->setFormClass("delete", "Drupal\mcapi_exchanges\Form\ExchangeDeleteConfirm");
  $e->setFormClass("enable", "Drupal\mcapi_exchanges\Form\ExchangeEnableConfirm");
  $e->setFormClass("disable", "Drupal\mcapi_exchanges\Form\ExchangeDisableConfirm");
  $e->setLinkTemplate("canonical", "mcapi.exchange.view");
  $e->setLinkTemplate("edit-form", "mcapi.exchange.edit");
  $e->setLinkTemplate("field_ui_base_route", "mcapi.admin_exchange_list");
  $e->setLinkTemplate("delete-form", "mcapi.exchange.delete_confirm");
  $e->setLinkTemplate("enable", "mcapi.exchange.enable_confirm");
  $e->setLinkTemplate("disable", "mcapi.exchange.disable_confirm");
  $e->setViewBuilderClass("Drupal\mcapi_exchanges\ExchangeViewBuilder");
  $e->setAccessClass("Drupal\mcapi_exchanges\ExchangeAccessControlHandler");
  $e->setListbuilderClass("Drupal\mcapi_exchanges\ExchangeListBuilder");
  //there isn't an explicit method for views_data yet
  $e->setHandlerClass('views_data', "Drupal\mcapi_exchanges\ExchangeViewsData");
  $e->set('field_ui_base_route', "mcapi.admin_exchange_list");
}


function mcapi_exchanges_menu_links_discovered_alter(&$definitions) {
  unset($definitions['mcapi.exchange.masspay']);
}

/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_exchanges_entity_extra_field_info() {
  $extra['mcapi_exchange']['mcapi_exchange']['display']['transactions'] = array(
    'label' => t('Intertrading'),
    'description' => t('Link to the wallets special intertrading wallet'),
    'weight' => 2,
  );
  $extra['mcapi_exchange']['mcapi_exchange']['display']['transactions_link'] = array(
    'label' => t('List of transactions'),
    'weight' => 11
  );
  return $extra;
}


/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields to the exchange
 */
function mcapi_exchanges_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  $count = db_select("user__exchanges", 'e')->fields('e', array('entity_id'))
  ->condition('exchanges_target_id', $entity->id())
  ->countQuery()->execute()->fetchField();
  $build['members_link'] = array(
    '#type' => 'item',
    '#title' => t('@count members', array('@count'=> $count)),
    'link' => array(
      '#type' => 'link',
      '#title' => t('Show members'),
      '#href' => 'exchange/'.$entity->id().'/members',
      //maybe instead put a view with the last five members here
      '#options' => array(
        'attributes' => new Attribute(array('title' => "This view doesn't exist yet"))
      )
    )
  );
  //get all the wallets in this exchange
  $wids = \Drupal\mcapi\Storage\WalletStorage::filter(array('exchanges' => array($entity->id())));
  //get all the transactions in those wallets
  $serials = $wids ?
  \Drupal\mcapi\Storage\TransactionStorage::filter(array('involving' => $wids)) :
  array();

  $build['transactions_link'] = array(
    '#type' => 'item',
    '#title' => t('@count transactions', array('@count'=> count(array_unique($serials)))),
    'link' => array(
      '#type' => 'link',
      '#title' => t('Show transactions'),
      '#href' => 'exchange/'.$entity->id().'/transactions',
      //TODO maybe instead put a view with the last five members here
      '#options' => array(
        'attributes' => new Attribute(array('title' => "This view doesn't exist yet"))
      )
    )
  );
}


/**
 * get the exchanges a transaction and its children are in.
 * Children may be in a different exchange to their parents
 *
 * @param Drupal\mcapi\Entity\Transaction $transaction
 *   A single transaction entity, (with no children)
 *
 * @todo check that we actually have a good use for this function. SHould it return ids or entities?
 *
 * @return integer[]
 *   the first value will be the parent transaction exchange ID
 */
function mcapi_transaction_get_exchanges(Transaction $transaction) {
  foreach ($transaction->flatten() as $t) {
    //generally we only need one, so take the first
    $exchanges[] = $t->exchange->target_id;
  }
  return exchanges;
}

/**
 * implements hook_mcapi_transaction_alter().
 * if the wallets are in different exchanges, and other context allows
 * split the transaction into 2
 */
function mcapi_exchanges_mcapi_transaction_alter(TransactionInterface $transaction) {

  $common_exchanges = mcapi_wallet_common_exchanges($transaction->payer->entity, $transaction->payee->entity);
  if ($common_exchanges) {
    $transaction->set('exchange', reset($common_exchanges)->id());
    return;
  }
  $transaction_curr_ids = $transaction->worth->currencies();
  $my_exchanges = Exchange::referenced_exchanges();
if (!is_array($my_exchanges)){print_r($my_exchanges);die();}
  $payer_exchanges = $transaction->payer->entity->in_exchanges(TRUE);
  foreach (array_intersect_key($payer_exchanges, $my_exchanges) as $exchange) {
    if (has_currencies($exchange, $transaction_curr_ids))  {
      $transaction->set('exchange', $exchange->id());
      $source = 'payer';
      $dest = 'payee';
      break;
    }
  }
  $source = 0;
  if (empty($set))  {
    foreach (array_intersect_key($transaction->payee->entity->in_exchanges(TRUE), $my_exchanges) as $exchange) {
      if (has_currencies($exchange, $transaction_curr_ids))  {
        $transaction->set('exchange', $exchange->id());
        $source = 'payee';
        $dest = 'payer';
        break;
      }
    }
  }
  $violations = array();
  if (!$source) {
    throw new McapiTransactionException('worth', 'Neither party can access all the currencies in the transaction: '.implode(', ', $transaction_curr_ids));
  }

  //We have to check if a transaction is even possible.
  //this means there is at least one currency in the transaction not common to both wallets' exchanges

  //That means we create a transaction between each wallet and its exchange's _intertrading wallet
  //In effect the current transaction is altered and a child added

  //Whichever wallet which can use all the currencies in the transaction is the 'source' wallet.
  //In an intertrading split the source wallet takes the existing transactions
  //The dest wallet takes the new (child) transaction and the converted currency values.

  //we might want to abstract this into a plugin or something to allow
  //different mechanisms for taking a commission.


  //We need to identify a dest exchange whose intertrading wallet can be used
  //which of the $dest_wallet's parent's exchanges is most suitable, if any?
  //it must contain all the worth's currencies bar one.
  foreach ($transaction->{$dest}->entity->in_exchanges() as $dest_exchange) {
    $dest_exchange_currencies = exchange_currencies(array($dest_exchange));
    $diff = array_diff_key(array_flip($transaction_curr_ids), $dest_exchange_currencies);
    //diff is the currencies in worth which are not in the dest exchange
    //if there is no diff, we shouldn't be intertrading but doing a straight transaction
    $source_currency_id = key($diff);//do this now to ensure there is a value for the error
    if (!$diff) {
      throw new McapiTransactionException('Intertrading calculation is running when worth currencies are all matched');
    }
    if (count($diff) > 1) {
      continue;//we won't attempt to convert more than one currency in a transaction
    }
    $source_ticks = Currency::load($source_currency_id)->ticks;
    if (!$source_ticks) {//the one diff currency in this exchange is not intertradable
      continue;
    }
    //when we have found a suitable exchange, stop looping because we need the variables above
    $found = TRUE;
    break;
  }
  if (!isset($found)) {
    return array(
      $source_currency_id,
      //this string is identical to another
      t('There is no way to intertrade this currency between these wallets')
    );
  }
  //so now we have our dest $exchange, a list of $exchange_currencies in it
  //get the first tradable currency in the exchange which isn't one of the other worth values.
  foreach ($dest_exchange_currencies as $curr) {
    if ($curr->ticks) {
      $dest_currency = $curr;
      break;
    }
  }
  if (!isset($dest_currency)) {
    $transaction->violations[$source_currency_id] = t('The destination exchange has no tradable currency.');
    return;
  }


  $new_transaction = clone($transaction);//since it hasn't been saved there is no xid or serial number yet
  $new_transaction->uuid->setValue(\Drupal::service('uuid')->generate());
  $transaction->set($dest, $transaction->exchange->entity->intertrading_wallet()->id());
  $new_transaction->set($source, $dest_exchange->intertrading_wallet()->id());
  $new_transaction->worth->setValue(
    array(
      array(
        'curr_id' => $dest_currency->id(),
        'value' => floor($dest_currency->ticks / $source_ticks * $transaction->worth->val($source_currency_id))
      )
    )
  );
  $transaction->children[] = $new_transaction;
}

/**
 * determine if all the passed currency ids are in the exchange
 * @param unknown $exchange
 * @param unknown $currency_ids
 */
function has_currencies($exchange, $currency_ids) {
  foreach($exchange->currencies->referencedEntities() as $currency) {
    $ids[] = $currency->id;
  }
  return array_intersect($currency_ids, $ids) == $currency_ids;
}


/**
 * Provide the new worthItemList array for an intertrading child transaction
 * @param TransactionInterface $transaction
 *
 * @param WalletInterface $dest_wallet
 *   The wallet in the remote exchange
 * @return array
 *   violation, keyed by fieldname
 */
function intertrading_new_worths(TransactionInterface $transaction, WalletInterface $dest_wallet) {
  $transaction_curr_ids = $transaction->get('worth')->curr_ids();

  return array();//no problems
}

/**
 * implements hook_ENTITY_TYPE_delete().
 * Remove references to exchanges
 * TODO surely entity reference deletion should happen automatically??
 */
function mcapi_exchanges_mcapi_exchange_delete($exchange) {
  return;
  foreach (Exchange::getEntityFieldnames() as $entity_type => $fieldname) {
    db_delete($entity_type.'__'.$fieldname)
      ->condition($fieldname.'_target_id', $exchange->id())
      ->condition('entity_id', 1, '>')
      ->execute();
    db_delete($entity_type.'_revision__'.$fieldname)
      ->condition($fieldname.'_target_id', $exchange->id())
      ->condition('entity_id', 1, '>')
      ->execute();
  }
}

/**
 * Implements hook_mail_alter().
 * divert exchange contact mails to the right exchange
 */
function mcapi_exchanges_mail_alter(&$message) {
  print_r($message);die();
  //if the recipient is mcapi_exchange@drupal then swop it for the owner of the current exchange
  //either that or don't use the contact module to contact exchanges
}

/**
 * implements hook_ENTITY_TYPE_load().
 */
function mcapi_exchanges_contact_category_load($entities) {
  foreach ($entities as $category) {
    if ($category->id == 'exchange') {
      //this might work except for caching and we don't know what exchange we are trying to contact!
      $category->recipients[] = 'mcapi_exchange@drupal';
    }
  }
}

<?php

use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Exchange;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\TransactionInterface;
use Drupal\mcapi\WalletInterface;
use Drupal\Core\Template\Attribute;
use Drupal\mcapi\McapiTransactionException;


/**
 * implements hook_entity_info_alter().
 * add new handlers for the Exchange entity
 */
function mcapi_exchanges_entity_type_alter(array &$entity_types) {
  $e = $entity_types['mcapi_exchange'];
  $e->setFormClass("add", "Drupal\mcapi_exchanges\Form\ExchangeWizard");
  $e->setFormClass("edit", "Drupal\mcapi_exchanges\Form\ExchangeForm");
  $e->setFormClass("masspay", "Drupal\mcapi_exchanges\Form\MassPay");
  $e->setFormClass("delete", "Drupal\mcapi_exchanges\Form\ExchangeDeleteConfirm");
  $e->setFormClass("enable", "Drupal\mcapi_exchanges\Form\ExchangeEnableConfirm");
  $e->setFormClass("disable", "Drupal\mcapi_exchanges\Form\ExchangeDisableConfirm");
  $e->setLinkTemplate("canonical", "mcapi.exchange.view");
  $e->setLinkTemplate("edit-form", "mcapi.exchange.edit");
  $e->setLinkTemplate("field_ui_base_route", "mcapi.admin_exchange_list");
  $e->setLinkTemplate("delete-form", "mcapi.exchange.delete_confirm");
  $e->setLinkTemplate("enable", "mcapi.exchange.enable_confirm");
  $e->setLinkTemplate("disable", "mcapi.exchange.disable_confirm");
  $e->setViewBuilderClass("Drupal\mcapi_exchanges\ExchangeViewBuilder");
  $e->setAccessClass("Drupal\mcapi_exchanges\ExchangeAccessControlHandler");
  $e->setListbuilderClass("Drupal\mcapi_exchanges\ExchangeListBuilder");
  //there isn't an explicit method for views_data yet
  $e->setHandlerClass('views_data', "Drupal\mcapi_exchanges\ExchangeViewsData");
  $e->set('field_ui_base_route', "mcapi.admin_exchange_list");
}

/**
 * implements hook_ENTITY_TYPE_load().
 * add the 'exchange arguments to the transactions view
 * @param type $entities
 * @todo see if this works in mcapi"_exchanges.views.inc
 */
function mcapi_exchanges_view_load(&$entities) {
  if (array_key_exists('mcapi_transactions', $entities)) {
    $display = $entities['mcapi_transactions']->getDisplay('default');
    $display['display_options']['arguments']['exchange'] = array (
      'id' => 'exchange',
      'table' => 'mcapi_transaction',
      'field' => 'exchange',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'dependencies' => array(
        'module' => array(
          0 => 'mcapi',
          1 => 'views',
        ),
      ),/*
      'default_action' => 'ignore',
      'exception' => array(
        'value' => 'all',
        'title_enable' => false,
        'title' => 'All',
      ),
      'title_enable' => false,
      'title' => '',
      'default_argument_type' => 'fixed',
      'default_argument_options' => array(
        'argument' => '1',
      ),
      'default_argument_skip_url' => false,
      'summary_options' => array(
        'base_path' => '',
        'count' => true,
        'items_per_page' => 25,
        'override' => false,
      ),
      'summary' => array(
        'sort_order' => 'asc',
        'number_of_records' => 0,
        'format' => 'default_summary',
      ),*/
      'specify_validation' => true,
      'validate' => array(
        'type' => 'entity:mcapi_exchange',
        'fail' => 'access denied',
      ),
      'validate_options' => array(
        'access' => '1',
        'operation' => 'view',
        'multiple' => '1',
        'bundles' => NULL,
      ),
      'break_phrase' => false,
      'not' => 0,
      'plugin_id' => 'transaction_exchange',
      'provider' => 'mcapi',
    );
    debug($entities['mcapi_transactions']->getDisplay('default')['display_options']['arguments']['exchange']);
  }
}

function mcapi_exchanges_menu_links_discovered_alter(&$definitions) {
  unset($definitions['mcapi.exchange.masspay']);
}

/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_exchanges_entity_extra_field_info() {
  $extra['mcapi_exchange']['mcapi_exchange']['display']['transactions'] = array(
    'label' => t('Intertrading'),
    'description' => t('Link to the wallets special intertrading wallet'),
    'weight' => 2,
  );
  $extra['mcapi_exchange']['mcapi_exchange']['display']['transactions_link'] = array(
    'label' => t('List of transactions'),
    'weight' => 11
  );
  return $extra;
}


/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields to the exchange
 */
function mcapi_exchanges_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  $count = db_select("user__exchanges", 'e')->fields('e', array('entity_id'))
  ->condition('exchanges_target_id', $entity->id())
  ->countQuery()->execute()->fetchField();
  $build['members_link'] = array(
    '#type' => 'item',
    '#title' => t('@count members', array('@count'=> $count)),
    'link' => array(
      '#type' => 'link',
      '#title' => t('Show members'),
      '#href' => 'exchange/'.$entity->id().'/members',
      //maybe instead put a view with the last five members here
      '#options' => array(
        'attributes' => new Attribute(array('title' => "This view doesn't exist yet"))
      )
    )
  );
  //get all the wallets in this exchange
  $wids = \Drupal\mcapi\Storage\WalletStorage::filter(array('exchanges' => array($entity->id())));
  //get all the transactions in those wallets
  $serials = $wids ?
  \Drupal\mcapi\Storage\TransactionStorage::filter(array('involving' => $wids)) :
  array();

  $build['transactions_link'] = array(
    '#type' => 'item',
    '#title' => t('@count transactions', array('@count'=> count(array_unique($serials)))),
    'link' => array(
      '#type' => 'link',
      '#title' => t('Show transactions'),
      '#href' => 'exchange/'.$entity->id().'/transactions',
      //TODO maybe instead put a view with the last five members here
      '#options' => array(
        'attributes' => new Attribute(array('title' => "This view doesn't exist yet"))
      )
    )
  );
}


/**
 * get the exchanges a transaction and its children are in.
 * Children may be in a different exchange to their parents
 *
 * @param Drupal\mcapi\Entity\Transaction $transaction
 *   A single transaction entity, (with no children)
 *
 * @todo check that we actually have a good use for this function. SHould it return ids or entities?
 *
 * @return integer[]
 *   the first value will be the parent transaction exchange ID
 */
function mcapi_transaction_get_exchanges(Transaction $transaction) {
  foreach ($transaction->flatten() as $t) {
    //generally we only need one, so take the first
    $exchanges[] = $t->exchange->target_id;
  }
  return exchanges;
}

/**
 * implements hook_mcapi_transaction_alter().
 * if the wallets are in different exchanges, and other context allows
 * split the transaction into 2
 */
function mcapi_exchanges_mcapi_transaction_alter(TransactionInterface $transaction) {
  $common_exchanges = array_intersect_key(
    $transaction->payer->entity->in_exchanges(),
    $transaction->payee->entity->in_exchanges()
  );
  if ($common_exchanges) {
    $transaction->set('exchange', reset($common_exchanges)->id());
    return;
  }
  $transaction_curr_ids = $transaction->worth->currencies();
  $my_exchanges = Exchange::referenced_exchanges();
//TODO delete this
if (!is_array($my_exchanges)){print_r($my_exchanges);die('mcapi_exchanges_mcapi_transaction_alter');}
  $payer_exchanges = $transaction->payer->entity->in_exchanges(TRUE);
  foreach (array_intersect_key($payer_exchanges, $my_exchanges) as $exchange) {
    if (has_currencies($exchange, $transaction_curr_ids))  {
      $transaction->set('exchange', $exchange->id());
      $source = 'payer';
      $dest = 'payee';
      break;
    }
  }
  $source = 0;
  if (empty($set))  {
    foreach (array_intersect_key($transaction->payee->entity->in_exchanges(TRUE), $my_exchanges) as $exchange) {
      if (has_currencies($exchange, $transaction_curr_ids))  {
        $transaction->set('exchange', $exchange->id());
        $source = 'payee';
        $dest = 'payer';
        break;
      }
    }
  }
  $violations = array();
  if (!$source) {
    throw new McapiTransactionException('worth', 'Neither party can access all the currencies in the transaction: '.implode(', ', $transaction_curr_ids));
  }

  //We have to check if a transaction is even possible.
  //this means there is at least one currency in the transaction not common to both wallets' exchanges

  //That means we create a transaction between each wallet and its exchange's _intertrading wallet
  //In effect the current transaction is altered and a child added

  //Whichever wallet which can use all the currencies in the transaction is the 'source' wallet.
  //In an intertrading split the source wallet takes the existing transactions
  //The dest wallet takes the new (child) transaction and the converted currency values.

  //we might want to abstract this into a plugin or something to allow
  //different mechanisms for taking a commission.


  //We need to identify a dest exchange whose intertrading wallet can be used
  //which of the $dest_wallet's parent's exchanges is most suitable, if any?
  //it must contain all the worth's currencies bar one.
  foreach ($transaction->{$dest}->entity->in_exchanges() as $dest_exchange) {
    $dest_exchange_currencies = exchange_currencies(array($dest_exchange));
    $diff = array_diff_key(array_flip($transaction_curr_ids), $dest_exchange_currencies);
    //diff is the currencies in worth which are not in the dest exchange
    //if there is no diff, we shouldn't be intertrading but doing a straight transaction
    $source_currency_id = key($diff);//do this now to ensure there is a value for the error
    if (!$diff) {
      throw new McapiTransactionException('Intertrading calculation is running when worth currencies are all matched');
    }
    if (count($diff) > 1) {
      continue;//we won't attempt to convert more than one currency in a transaction
    }
    $source_ticks = Currency::load($source_currency_id)->ticks;
    if (!$source_ticks) {//the one diff currency in this exchange is not intertradable
      continue;
    }
    //when we have found a suitable exchange, stop looping because we need the variables above
    $found = TRUE;
    break;
  }
  if (!isset($found)) {
    return array(
      $source_currency_id,
      //this string is identical to another
      t('There is no way to intertrade this currency between these wallets')
    );
  }
  //so now we have our dest $exchange, a list of $exchange_currencies in it
  //get the first tradable currency in the exchange which isn't one of the other worth values.
  foreach ($dest_exchange_currencies as $curr) {
    if ($curr->ticks) {
      $dest_currency = $curr;
      break;
    }
  }
  if (!isset($dest_currency)) {
    $transaction->violations[$source_currency_id] = t('The destination exchange has no tradable currency.');
    return;
  }


  $new_transaction = clone($transaction);//since it hasn't been saved there is no xid or serial number yet
  $new_transaction->uuid->setValue(\Drupal::service('uuid')->generate());
  $transaction->set($dest, $transaction->exchange->entity->intertrading_wallet()->id());
  $new_transaction->set($source, $dest_exchange->intertrading_wallet()->id());
  $new_transaction->worth->setValue(
    array(
      array(
        'curr_id' => $dest_currency->id(),
        'value' => floor($dest_currency->ticks / $source_ticks * $transaction->worth->val($source_currency_id))
      )
    )
  );
  $transaction->children[] = $new_transaction;
}

/**
 * determine if all the passed currency ids are in the exchange
 * @param unknown $exchange
 * @param unknown $currency_ids
 */
function has_currencies($exchange, $currency_ids) {
  foreach($exchange->currencies->referencedEntities() as $currency) {
    $ids[] = $currency->id;
  }
  return array_intersect($currency_ids, $ids) == $currency_ids;
}


/**
 * Provide the new worthItemList array for an intertrading child transaction
 * @param TransactionInterface $transaction
 *
 * @param WalletInterface $dest_wallet
 *   The wallet in the remote exchange
 * @return array
 *   violation, keyed by fieldname
 */
function intertrading_new_worths(TransactionInterface $transaction, WalletInterface $dest_wallet) {
  $transaction_curr_ids = $transaction->get('worth')->curr_ids();

  return array();//no problems
}

/**
 * implements hook_ENTITY_TYPE_delete().
 * Remove references to exchanges
 * TODO surely entity reference deletion should happen automatically??
 */
function mcapi_exchanges_mcapi_exchange_delete($exchange) {
  return;
  foreach (Exchange::getEntityFieldnames() as $entity_type => $fieldname) {
    db_delete($entity_type.'__'.$fieldname)
      ->condition($fieldname.'_target_id', $exchange->id())
      ->condition('entity_id', 1, '>')
      ->execute();
    db_delete($entity_type.'_revision__'.$fieldname)
      ->condition($fieldname.'_target_id', $exchange->id())
      ->condition('entity_id', 1, '>')
      ->execute();
  }
}

/**
 * implements hook_mcapi_transaction_validate().
 * check that _intertrading wallet is being used correctly.
 * @param array $clusters
 */
function mcapi_exchanges_mcapi_transaction_validate(array $clusters) {
  foreach ($clusters as $transaction) {
echo $transaction->payer->entity->name();
    if ($transaction->payer->entity->name == '_intertrading' || $transaction->payee->entity->name == '_intertrading') {
      //there MUST be a child transaction also with an intertrading wallet in a different exchange.
      foreach ($transaction->children as $child) {
        if ($child->payer->entity->name == '_intertrading' || $child->payee->entity->name == '_intertrading') continue 2;
      }
      throw new \Exception('Intertrading wallet error');
    }
  }
}

/**
 * Implements hook_mail_alter().
 * divert exchange contact mails to the right exchange
 */
function mcapi_exchanges_mail_alter(&$message) {
  print_r($message);die('mcapi_exchanges_mail_alter');
  //if the recipient is mcapi_exchange@drupal then swop it for the owner of the current exchange
  //either that or don't use the contact module to contact exchanges
}

/**
 * implements hook_ENTITY_TYPE_load().
 */
function mcapi_exchanges_contact_category_load($entities) {
  foreach ($entities as $category) {
    if ($category->id == 'exchange') {
      //this might work except for caching and we don't know what exchange we are trying to contact!
      $category->recipients[] = 'mcapi_exchange@drupal';
    }
  }
}




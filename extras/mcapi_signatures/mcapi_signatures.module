<?php


define ('TRANSACTION_STATE_PENDING', -1);

/**
 * TODO put all this in hook_help
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table with the date of signing
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * There is also a 'cancel' operation for pending transactions, permissions defined in the currency.
 */


/**
 * implements hook_menu()
 */
function mcapi_signatures_menu() {
  //TODO put this in mcapi_signatures.routing.yml
  $items['user/%user/signall'] = array(
    'title' => 'Sign all your transactions?',
    'description' => 'Put your signature on all transactions which require it',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signall', 1),
    'access callback' => 'mcapi_signall_access',
    'access arguments' => array(1),
    'file' => 'mcapi_signatures.inc'
  );
  return $items;
}

function mcapi_signall_access($account) {
  if (db_query("SELECT TRUE FROM {mcapi_signatures} WHERE uid = $account->uid AND pending = 1")->fetchField()) {
    return $account->uid == \Drupal::currentUser()->id() || user_access('manage all transactions');
  }
}

/**
 * Implements hook_ENTITY_load()
 * put the signatories into the transaction entity
 */
function mcapi_signatures_mcapi_transaction_load($entities) {
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $key => $transaction) {
    if ($transaction->type->value != 'signed') continue;
    $transaction->signatures = db_select('mcapi_signatures', 's')
      ->fields('s', array('uid', 'signed'))
      ->condition('serial', $transaction->serial->value)//or $transaction->serial??
      ->execute()->fetchAllKeyed(0);
  }
}

/**
 * implement mcapi hook_ENTITY_delete
 * this doesn't happen with the undo operation, which merely changes the state.
 * ensures that signatures for undone transactions are not left pending.
 */
function mcapi_signatures_mcapi_transaction_delete(TransactionInterface $transaction) {
	db_delete('mcapi_signatures')
	->condition('serial', $transaction->serial->value)
	->execute();
}

/**
 * implements hook_ENTITY_presave();
 * saves the NEW signatures with the NEW transaction
 */
function mcapi_signatures_mcapi_transaction_presave($transaction){
  if ($transaction->isNew() && $transaction->type->value == 'signed') {
    $config = transaction_operations('sign')->config->get('special');
    $signatories = $config['countersignatories'] + array(
      $transaction->payee->value,
      $transaction->payer->value
    );
    foreach ($signatories as $uid) {
      //assume the current user has already signed
      $transaction->signatures[$uid] = \Drupal::currentUser()->id() == $uid ? REQUEST_TIME : 0;
    }
  }
}

/**
 * implements hook_ENTITY_insert
 * saves the signatures after the entity has been written
 */
function mcapi_signatures_mcapi_transaction_insert($transaction) {
  if (isset($transaction->signatures)) {
    $q = db_insert('mcapi_signatures')->fields(array('serial', 'uid', 'signed'));
    foreach ($transaction->signatures as $uid => $signed) {
      $q->values(array($transaction->serial->value, $uid, $signed));
    }
    $q->execute();
  }

}

/**
 * implements hook_ENTITY_update
 * saves the signatures after the entity has been written
 */
function mcapi_signatures_mcapi_transaction_update($transaction) {
  if (isset($transaction->signatures)) {
    foreach ($transaction->signatures as $uid => $signed) {
      db_merge('mcapi_signatures')
      ->key(array('serial' => $transaction->serial->value, 'uid' => $uid))
      ->fields(array('signed' => $signed))->execute();
    }
  }
}

/**
 * Implements hook_mcapi_info_states
 * declare the pending transaction state.
 */
function mcapi_signatures_mcapi_info_states() {
  return array(
    TRANSACTION_STATE_PENDING => array(
      'name' => t("Pending"),
      'description' => t("awaiting signatures before becoming 'finished'."),//note lowercase
    )
  );
}

/**
 * implements hook_mcapi_info_types().
 */
function mcapi_signatures_mcapi_info_types() {
  return array(
    'signed' => array(
      'label' => t('With signature'),
      'description' => t('The other trader must add a signature.'),
      'start state' => TRANSACTION_STATE_PENDING
    )
  );
}

//returns a list of the user objects who are yet to sign
//will take EITHER a serial OR a uid, returns a list of the other
function mcapi_get_signatories($serial = NULL, $uid = NULL) {
  if ($serial && $uid) {
    drupal_set_message('Bad arguments to mcapi_get_signatories', 'error');
    return;
  }
  $query = db_select('mcapi_signatures', 's');
  if ($serial) {
    $result = $query->fields('s', array('uid', 'signed'))
    ->condition('serial', $serial)
    ->execute()->fetchAllKeyed(0);
  }
  else {
    $result = $query->fields('s', array('serial'))
    ->condition('signed', '')
    ->condition('uid', $uid)
    ->execute()->fetchCol();
  }
  return $result;
}

/**
 * implements hook_block_view_mcapi_user_summary_alter
 * appends the 'signatures needed' view to the mcapi-balance block
 */
function mcapi_signatures_block_view_mcapi_user_summary_alter(array &$build, \Drupal\block\BlockPluginInterface $block) {
  module_load_include('inc', 'mcapi_signatures');
  //TODO test this with a pending transaction
  if ($content = list_waiting_on_uid($build['content']['#account'])) {
    $build['content'][] = array('#markup' => '<strong>'.t('Awaiting my signature...').'</strong>');
    $build['content'][] = $content;
  }
}

/**
 * implements hook_cron
 * checks integrity of signatures and transactions
 */
function mcapi_signatures_cron() {
  //call me paranoid, but I'd like to just check data integrity
  $serials = db_query("SELECT t.serial FROM {mcapi_transactions} t LEFT JOIN {mcapi_signatures} s ON t.serial = s.serial WHERE s.pending = 1 AND t.state = :state", array(':state' => TRANSACTION_STATE_FINISHED))->fetchCol();
  if (count($serials)){
    watchdog('mcapi_signatures', 'Some completed transactions still have signatures pending, please report to matslats: @serials', array('@serials' => implode(', ', $serials)), WATCHDOG_ERROR);
  }
}

/**
 * implements hook_theme
 */
function mcapi_signatures_theme() {
  $items['mcapi_signatures'] = array(
    'template' => 'mcapi_signatures',
    'variables' => array(
      'transaction' => NULL,
    )
  );
  return $items;
}

/**
 * implements hook_THEMEHOOK_view_alter
 */
function mcapi_signatures_mcapi_transaction_view_alter(&$build) {
  if ($build['#theme'] == 'certificate' && isset($build['#mcapi_transaction']->signatures)) {
    $build['mcapi_signatures'] = array(
      '#theme' => 'mcapi_signatures',
      '#transaction' => $build['#mcapi_transaction'],
      '#attached' => array('css' => array(drupal_get_path('module', 'mcapi_signatures') .'/templates/signatures.css'))
    );
  }
}

/**
 * implements template_preprocess_THEMEHOOK
 */
function template_preprocess_mcapi_signatures(&$vars) {
  $plugin = transaction_operations('sign');
  foreach ($vars['transaction']->signatures as $uid => $signed) {
    $account = user_load($uid);
    $vars['signatures'][$uid] = array(
      'account' => $account,
      'class' => 'signature '. (empty($signed) ? 'pending' : 'signed'),
      'name' =>  $account->getUsername(),
    );
  }
}

/**
 * implements hook_mcapicurrencies_default_alter
 * //TODO How is config altered in D8?
 */
function mcapi_signatures_mcapicurrencies_default_alter(&$currencies) {
  //todo, loop these coz they are the same
  foreach ($currencies as $currcode => $currency) {
    $currencies[$currcode]->data->access_view[TRANSACTION_STATE_PENDING] = drupal_map_assoc(
      array(
        'transaction_access_callback_signatory',
        'transaction_access_callback_perm_manage_all'
      )
    );
    $currencies[$currcode]->data->undo_states[TRANSACTION_STATE_PENDING] = drupal_map_assoc(
      array(
        'transaction_access_callback_signatory',
        'transaction_access_callback_perm_manage_all'
      )
    );
  }
}

/**
 * sign a transaction
 * change the state if no more signatures are left
 */
function transaction_sign(TransactionInterface $transaction, $account) {
  if (array_key_exists($account->id(), $transaction->signatures)) {
    $transaction->signatures[$account->id()] = REQUEST_TIME;
    //set the state to finished if there are no outstanding signatures
    if (array_search(0, $transaction->signatures) === FALSE) {
      $transaction->set('state', TRANSACTION_STATE_FINISHED);
    }
    $transaction->save();
  }
  else {
    //this should never happen
    drupal_set_message('@name cannot sign this transaction', 'warning');
  }
}

/**
 * implements hook_field_extra_fields
 */
function mcapi_signatures_field_extra_fields() {
  return array(
    'user' => array(
      'user' => array(
        'display' => array(
          'mcapi_signatures' => array(
            'label' => t('Balance limits'),
            'description' => t('Trading limits per currency'),
            'weight' => 0,
          ),
        )
      )
    )
  );
}

/**
 * implement hook_user_view().
 */
function mcapi_signatures_user_view($account, $mode, $language) {
  echo '//TODO mcapi_limits_user_view()';
  $account->content['mcapi_signatures'] = array();
}

<?php
// $Id:

define ('TRANSACTION_STATE_PENDING', -1);


/*
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table and marked 'signed'
 * Signatures happen via menu callbacks
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * Also to sign all a user's transactions.
 * Note that the mcapi_forms module can not deal with signatures of non-transactors, nor can the mail processor, but this module can
 */
function mcapi_pending_menu() {
  //this item makes it possible to sign on someone elses behalf, if the link is provided.
  //That's not in the scope of this module

  $items['transaction/%transaction/signoff'] = array(
    'title' => 'Sign off',
    'description' => 'Sign the transaction on behalf of everyone',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signoff_confirm_form', 1),
    'access callback' => 'transaction_signoff_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
  );
  $items['transactions/signall/%user'] = array(
    'title' => 'Sign all my transactions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signall_confirm_form', 2),
    'access callback' => 'user_has_pending',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

function mcapi_pending_hook_info() {
  return array(
    //a signature is added to a transaction
    //takes args $transaction and $signer_uid
    'transaction_sign' => array(),
    'transaction_pending_finished' => array(),
  );
}

function mcapi_pending_menu_alter(&$items) {
  //this menu item is generated from the transaction form-in-code
  //it can ONLY be seen by signatories
  $items['transaction/%transaction/sign']['access callback'] = 'transaction_sign_access';
  $items['transaction/%transaction/sign']['access arguments'] = array(1);
  $items['transaction/%transaction/sign']['type'] = MENU_LOCAL_ACTION;
  $items['admin/structure/trigger/mcapi']['weight'] = 1;
}

function user_has_pending($account) {
  $whether = db_query("SELECT count(serial) FROM {mcapi_signatures} where uid = :uid AND pending = 1", array(':uid' => $account->uid))
    ->fetchfield();
  if (!$whether) return;
  return $account->uid == $GLOBALS['user']->uid || user_access('manage all transactions');
  
}
//menu access callback
//returns true if the user is a listed signatory and hasn't signed
//this function name is constructed - do not change!
function transaction_sign_access($transaction) {
  //check the transaction is pending and the given account needs to sign it.
  if ($transaction->state != TRANSACTION_STATE_PENDING) return FALSE;
  //check the user is listed as a signatory
  if (!empty($transaction->pending_signatures[$GLOBALS['user']->uid])) return TRUE;
}

//menu access callback
//can the current user 'sign off' any (pending) transaction
function transaction_signoff_access($transaction) {
  if ($transaction->state == TRANSACTION_STATE_PENDING) {
    if (user_access('manage all transactions')) return TRUE;
  }
}


/*
 * Implements hook_mcapi_info_states
 */
function mcapi_pending_mcapi_info_states() {
  return array(
    //must be defined with lower case
    TRANSACTION_STATE_PENDING => array(
      'name' => t("Pending"),
      'description' => t("awaiting signatures before becoming 'finished'."),
      'default_access_callbacks' => array('mcapi_xacc_participants')
    )
  );
}

/*
 * Will implement hook_entity_load or some such
 */
function mcapi_pending_entity_load($entities, $type) {
  if ($type != 'transaction')return;
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $key => $transaction) {
    $transaction->pending_signatures = mcapi_get_signatories($transaction->serial);
  }
}

/*
 * write the signature for each transaction to the database.
 * $transaction->pending signatures is an array
 * array(
 *   $uid => $signature_needed BOOLEAN
 * )
 * Every value should be 1 when the transaction is created
 */
function mcapi_pending_save($transaction) {
  //need to check property 'pending_signatures' because it may not have been declared
  if (!empty($transaction->pending_signatures)) {
    //save all the signatures whether or not they have been signed
    foreach ($transaction->pending_signatures as $uid => $pending) {
      $values[] = "( $transaction->serial, $uid, $pending  )";
    }
    db_query("REPLACE INTO {mcapi_signatures} (serial, uid, pending) VALUES ". implode(', ', $values) );
    $remaining = array_filter($transaction->pending_signatures);
  }
  
  $transaction->state = empty($remaining) ? TRANSACTION_STATE_FINISHED : TRANSACTION_STATE_PENDING;
  //because the transaction is already written, and to improve integrity, we reset the state here
  transactions_state(array($transaction->serial), $transaction->state);
}

/*
 * Will implement hook_entity_delete or some such
 */
function mcapi_pending_entity_delete($transaction, $type) {
  if ($type == 'transaction') {
    db_delete("mcapi_signatures")
    ->condition('serial', $transaction->serial)
    ->execute();
  }
}

/*
 * resaves signatories from the transaction object and changes state if all are signed
 */
function mcapi_sign($serials, $uids) {
  if (is_numeric($uids)) {
    $uids = array($uids);
  }
  if (count($uids) > 1 && count($serials) > 1) throw new Exception('Pending module error');
  //remove signatures one at a time
  foreach ($serials as $serial) {
    //only the first transaction in the cluster can have signatures
    $transaction = transaction_load($serial);
    foreach ($uids as $uid) {
      if ($transaction->pending_signatures[$uid] == 1) {
        $transaction->pending_signatures[$uid] = 0;
        mcapi_pending_save($transaction);
      }
      else {
        drupal_set_message(t('Transaction #@serial is already signed by @name',
          array('@serial' => $transaction->serial, '@name' => user_load($uid)->name)
        ));
      }
      module_invoke_all('transaction_sign', $transaction, $uid);
    }
    if ($transaction->state == TRANSACTION_STATE_PENDING) {
      drupal_set_message(t("@num signatures remaining on transaction #@serial", 
        array('@num' => count(array_filter($transaction->pending_signatures)), '@serial' => $serial)
      ));
    }
    else {
      drupal_set_message(t('Transaction @serial is signed off', array('@serial' => $transaction->serial)));
      module_invoke_all('transaction_pending_finished', $transaction);
    }
  }
}
/*
 * Implements hook_views_api
 */
function mcapi_pending_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending').'/views',
  );
}

/*
 * Implements ctools hook_ctools_plugin_api
 * not sure if this is needed
 */
function mcapi_pending_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending'),
  );
}

//returns a list of the user objects who are yet to sign
//will take EITHER a serial OR a uid, returns a list of the other
function mcapi_get_signatories($serial = NULL, $uid = NULL) {
  if ($serial && $uid) {
    drupal_set_message('Bad arguments to mcapi_get_signatories', 'error');
    return;
  }
  $signatures = array();
  $query = db_select('mcapi_signatures', 's');
  if ($serial) {
    $result = $query->fields('s', array('uid', 'pending'))->condition('serial', $serial)->execute()->fetchAllKeyed(0);
  }
  else {
    $result = $query->fields('s', array('serial'))->condition('pending', 1)->condition('uid', $uid)->execute()->fetchCol();
  }
 
  return $result;
}


/*
 * implements hook_form_FORMID_alter
 * bumps the signature form up to stage 2, where the fields are rendered as text
 */
function mcapi_pending_form_mcapi_forms_form_alter(&$form, &$form_state) {
  if ($form_state['build_info']['args'][1]->name != 'add_my_signature') return;
  unset($form['experience']['title'], $form['experience']['template']);
  //replace the transaction_form_submit callback because we only want to change the state, not save the 'values and everything
  $key = array_search('transaction_form_submit', $form['#submit']);
  $form['#submit'][$key] = 'add_my_signature_submit';
  unset($form['buttons']['delete']);
}

/*
 * form submit callback
 */
function add_my_signature_submit($form, &$form_state) {
  $serial = $form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]->serial;
  mcapi_sign(array($serial), array($GLOBALS['user']->uid));
}


/*
 * This menu callback is handled differently to the standard signing form
 */
function mcapi_signoff_confirm_form($form, $form_state, $transaction) {
  mcapi_hide_tabs();
  $form = array();
  $form_state['redirect'] = 'transaction/'. $transaction->serial;
  $form['serial'] = array(
    '#type' => 'hidden',
    '#value' => $transaction->serial
  );
  $signatories = array_filter(mcapi_get_signatories($transaction->serial));
  $users = user_load_multiple(array_keys($signatories));
  $form['#prefix'] = t('Are you sure you want to sign this transaction on behalf of @users?',
    array('@users' => mcapi_format_usernames($users))
  );
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signoff_confirm_form_validate($form, $form_state) {
  if ($reason = pending_not_signable($form_state['values']['serial'])) {
    form_set_error('', $reason);
  }
}

function mcapi_signoff_confirm_form_submit($form, &$form_state) {
  $serial = &$form_state['values']['serial'];
  if ($reason = pending_not_signable($serial)) {
    drupal_set_message($reason, 'error');
  }
  $signatories = array_filter(mcapi_get_signatories($serial));
  mcapi_sign(array($serial), array_keys($signatories));
  $form_state['redirect'] = 'transaction/'. $serial;
}
//returns a message if the transaction is not signable
function pending_not_signable($serial) {
  $signatories = array_filter(mcapi_get_signatories($serial));
  try {
    if (transaction_load($serial)->state != TRANSACTION_STATE_PENDING) {
      throw new Exception(t('Transaction is not in pending state'));
    }
    if (empty($signatories)) {
      throw new Exception(t('Pending transaction has no signatures waiting'));
    }
    $serials = array($serial);
    transactions_state($serials, TRANSACTION_STATE_FINISHED, TRUE);
  }
  catch(Exception $e) {
    return $e->getMessage();
  }
}

function mcapi_signall_confirm_form($form, $form_state, $account) {
  $form = array();
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid
  );
  $form['#prefix'] = t('Are you sure you want to sign all your transactions?');
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signall_confirm_form_submit($form, &$form_state) {
  $uid = &$form_state['values']['uid'];
  //get all the transactions
  $serials = array_keys(mcapi_get_signatories(NULL, $uid));
  $transactions = transactions_load(array(), array('serial' => $serials));
  //sign them one by one
  foreach ($transactions as $transaction) {
    $serials[] = $transaction->serial;
  }
  mcapi_sign($serials, array($uid));
  $form_state['redirect'] = 'user';
}


/*
 * Integration with mcapi_forms module
 *
 * Implements hook_form_FORM_ID_alter
 * modifies its own form to hide exceptional fields
 */
function mcapi_pending_form_ctools_export_ui_edit_item_form_alter(&$form, &$form_state) {
  //check that this is actually a transaction form
  if ($form_state['plugin']['schema'] != 'mcapi_forms') return;
  if ($form_state['item']->name != 'add_my_signature') return;

  $form['architecture']['path']['#disabled'] = TRUE;
  //disable the fields that would change the meaning of the form.
  $form['submission']['state']['#type'] = 'hidden';
  $form['submission']['state']['#value'] = 0;
  $form['architecture']['use_block']['#type'] = 'hidden';
  $form['architecture']['menu_link']['#type'] = 'hidden';
  $form['architecture']['menu_link']['#value'] = 0;
  $form['perspective']['#type'] = 'hidden';
  $form['perspective']['#value'] = 3;
  $instances = field_info_instances('transaction', 'transaction');
    mcapi_disable_recursive($form['payer']);
    mcapi_disable_recursive($form['payee']);
  foreach ($instances as $instance) {
    mcapi_disable_recursive($form[$instance['field_name']]);
  }
  unset($form['step-1']);
}

/*
 * implements hook_block_info_alter
 * adjusts the blocks declared by the default view
 */
function mcapi_pending_block_info_alter(&$blocks) {
  //because this view requires an argument which probably comes from the url
  if (isset($blocks['views']['signatures-user_pending'])) {
    $blocks['views']['signatures-user_pending']['visibility'] = 1;
    $blocks['views']['signatures-user_pending']['pages'] = 'user*';
  }
}

function mcapi_pending_cron() {
  //call me paranoid, but I'd like to just check data integrity
  $serials = db_query("SELECT t.serial FROM {mcapi_transactions} t LEFT JOIN {mcapi_signatures} s ON t.serial = s.serial WHERE s.pending = 1 AND t.state = :state", array(':state' => TRANSACTION_STATE_FINISHED))->fetchCol();
  if (count($serials)){
    watchdog('mcapi_pending', 'Some completed transactions still have signatures pending, please report to matslats: @serials', array('@serials' => implode(', ', $serials)), WATCHDOG_ERROR);
  }
}


function mcapi_disable_recursive(&$array) {
  $array['#disabled'] = TRUE;
  foreach(element_children($array) as $fieldname) {
    mcapi_disable_recursive($array[$fieldname]);
  }
}


/*
 * implements hook_trigger_info
 */
function mcapi_pending_trigger_info() {
  return array(
    'mcapi' => array(
      'transaction_sign' => array(
        'label' => t('A signature is added to a transaction'),
      ),
      'transaction_pending_finished' => array(
        'label' => t('A transaction moves from pending to completed states'),
      )
    )
  );
}
/*
 * default implementation of trigger hooks
 * calls up the actions, with the appropriate arguments
 */
function mcapi_pending_transaction_sign($transaction, $uid) {
  foreach (trigger_get_assigned_actions('transaction_sign') as $aid => $settings) {
    actions_do($aid, array($transaction), $settings);
  }
}
function mcapi_pending_transaction_pending_finished($transaction) {
  foreach (trigger_get_assigned_actions('transaction_pending_finished') as $aid => $settings) {
    actions_do($aid, array($transaction), $settings);
  }
}

/*
 * Implements hook_action_info
 * provides some simple actions, without conditions
 */
function mcapi_pending_action_info() {
  $items['mcapi_add_signatories_action'] = array(
    'type' => 'transactions',
    'label' => t('Add signatories and change state to Pending'),
    'configurable' => TRUE,
    'triggers' => array('transactions_inserted'),
  );
  //this replaces the action mcapi_transactions_mail_action
  $items['mcapi_signatories_mail_action'] = array(
    'label' => t('Notify transactees'),
    'type' => 'transactions',
    'configurable' => TRUE,
    'triggers' => array(
      'transactions_inserted',
      'transaction_pending_finished',
      'transaction_sign'
    ),
  );
  return $items;
}
/*
 * implements hook_action_info_alter
 * removes the replaced action
 */
function mcapi_action_info_alter(&$items) {
  unset($items['mcapi_transaction_mail_action']);
}

/*
 * actions callback
 * takes no settings.
 */
function mcapi_add_signatories_action(&$transactions, $settings) {
  $transaction = current($transactions);
  //some of these types would be meaningless
  if (in_array($transaction->type, array('undo', 'undone', 'child', 'remote receipt', 'remote payment', 'auto'))) return;
  //add users as signers, but mark it signed if the signer is the current user
  //make pending for any user who isn't the current user
  foreach (array('payer', 'payee') as $participant) {
    $uid = $transaction->$participant;
    $signed = $GLOBALS['user']->uid != $uid;
    //the current user is assumed to have signed
    $transaction->pending_signatures[$uid] = intval($signed);
  }
  if ($uid = $settings['countersigner']) {
    $pending = $GLOBALS['user']->uid != $uid;
    $transaction->pending_signatures[$uid] = intval($pending);
  }
  mcapi_pending_save($transaction);
}

function mcapi_add_signatories_action_form($context = array()) {
  return array(
    'countersigner' => array(
      '#title' => t('Countersignatory username (optional)'),
      '#description' => t('Username or email'),
      '#type' => 'textfield',
      '#default_value' => isset($context['countersigner']) ? $context['countersigner'] : '',
      '#element_validate' => array('mcapi_validate_usernames'),
      '#autocomplete_path' => 'user/autocomplete',
    )
  );
}
function mcapi_add_signatories_action_submit($form, $form_state) {
  return $form_state['values'];
}

/*
 * action callback
 * mail the transaction participants, and cc
 */
function mcapi_signatories_mail_action($transactions, $context) {
  $context['transactions'] = $transactions;
  $t = current($transactions);
  $recipients = isset($t->pending_signatures) ? $t->pending_signatures : array($t->payer => 1, $t->payee => 1);
  if(empty($context['send_to_all'])) {
    $recipients = array_filter($recipients);
  }
  _mcapi_transaction_mail_action(array_keys($recipients), $context);
}

function mcapi_signatories_mail_action_form($context = array()) {
  if (empty($context['body'])) $context['body'] = "[user:name],\n\n".
    t('A transaction for [transaction:worth] has been saved')."\n\n".
    t('More details can be found at:') ."\n[transaction:uri]\n\n".
    t('To change your notification settings, visit your profile at:') ."\n[user:edit-url]\n\n".
    t('The team at [site:name]');
  module_load_include('inc', 'mcapi');
  $form = _mcapi_mail_template_fields($context);
  $form['send_to_all'] = array(
    '#title' => t('Send to all'),
    '#description' => t('Send to all signatories, even ones who have signed already'),
    '#type' => 'checkbox',
    '#default_value' => isset($context['send_to_all']) ? $context['send_to_all'] : 0,
  );
  return $form;
}

/*
 * implements hook_process_transaction
 */
function mcapi_pending_process_transaction(&$variables) {
  $transaction = &$variables['transaction'];
  if (!isset($transaction->pending_signatures) || empty($transaction->pending_signatures)) return;
  $table = array();
  foreach ($transaction->pending_signatures as $uid => $pending) {
    $status = 'signed';
    if ($pending) {
      if ($uid == $GLOBALS['user']->uid && transaction_sign_access($transaction)) {
        $status = url('transaction/'.$transaction->serial.'/sign');
      }
      else {
        $status = 'pending';
      }
    }
    $signatories[$uid] = $status;
  }
  $signoff = array();
  if (transaction_signoff_access($transaction)) {
    $signoff = array(
      '#theme' => 'link',
      '#text' => t('Sign off'),
      '#path' => 'transaction/'.$transaction->serial.'/signoff',
      '#options' => array(
        'attributes' => array('title' => t('Sign the transaction on behalf of everyone')),
        'html' => TRUE,//required
       ),
    );
  }
  $variables['pending_signatures'] = array(
    '#theme' => 'pending_signatures',
    '#pending_signatures' => $transaction->pending_signatures,
    '#signatories' => $signatories,
    '#signoff_link' => $signoff,
    '#finished' => $transaction->state == TRANSACTION_STATE_FINISHED ? TRUE : FALSE
  );
}

/*
 * implements hook_theme
 */
function mcapi_pending_theme() {
  $items = array(
    'pending_signatures' => array(
      'template' => 'pending_signatures',
      'variables' => array(
        'pending_signatures' => array(),//raw data pulled from the transaction
        'signatories' => array(),
        'signoff_link' => array(),
        'finished' => FALSE
      )
    )
  );
  return $items;
}

/*
 * default preprocessor for theme callback 'pending_signatures'
 */
function template_preprocess_pending_signatures(&$variables) {
  $signatories = &$variables['signatories'];
  foreach ($signatories as $uid => $status) {
    $link = '';
    $username  = format_username(user_load($uid));
    if (strlen($status) > 7 ) {//then its a url
      $link = l( t('Sign transaction'), $status);
      $status = 'sign-link';
      $title = '';
    }
    else {
      $title = $status == 'pending' ? t('Awaiting signature') : t('Signed');
    }
    $rows[$uid] = array(
      $username, array(
        'class' => $status,
        'data' => $link,
        'title' => $title
      )
    );
  }
  $variables['table'] = array(
    '#theme' => 'table',
    '#attributes' => array('style' => 'width:15em'),
    '#rows' => $rows
  );
}
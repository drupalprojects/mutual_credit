<?php
// $Id:

define ('TRANSACTION_STATE_PENDING', -1);


/*
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table and marked 'signed'
 * Signatures happen via menu callbacks
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * Also to sign all a user's transactions.
 * Note that the mcapi_forms module can not deal with signatures of non-transactors, nor can the mail processor, but this module can
 */
function mcapi_pending_menu() {
  //this item makes it possible to sign on someone elses behalf, if the link is provided.
  //That's not in the scope of this module

  $items['transaction/%transaction/signoff'] = array(
    'title' => 'Sign off transaction',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signoff_confirm_form', 1),
    'access callback' => 'mcapi_pending_signoff_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
  );
  $items['transactions/signall/%user'] = array(
    'title' => 'Sign all my transactions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signall_confirm_form', 2),
    'access callback' => 'has_pending',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  mcapi_check_integrity();
  return $items;
}

function mcapi_pending_menu_alter(&$items) {
  //this menu item is generated from the transaction form-in-code
  //it can ONLY be seen by signatories
  $items['transaction/%transaction/sign']['access callback'] = 'mcapi_pending_signatories_access';
  $items['transaction/%transaction/sign']['access arguments'] = array(1);
  $items['transaction/%transaction/sign']['type'] = MENU_LOCAL_ACTION;
}

function has_pending($account) {
    $whether = db_query("SELECT count(serial) FROM {mcapi_signatures} where uid = :uid AND pending = 1", array(':uid' => $account->uid))
    ->fetchfield();
  if (!$whether) return;
  return $account->uid == $GLOBALS['user']->uid || user_access('manage all transactions');
  
}
//menu access callback
//returns true if the user is a listed signatory and hasn't signed
function mcapi_pending_signatories_access($transaction) {
  //check the transaction is pending and the given account needs to sign it.
  if ($transaction->state != TRANSACTION_STATE_PENDING) return FALSE;
  //check the user is listed as a signatory
  if (!empty($transaction->pending_signatures[$GLOBALS['user']->uid])) return TRUE;
}

//menu access callback
//can the current user 'sign off' any (pending) transaction
function mcapi_pending_signoff_access($transaction) {
  if ($transaction->state == TRANSACTION_STATE_PENDING) {
    if (user_access('manage all transactions')) return TRUE;
  }
}


/*
 * Implements hook_mcapi_info_states
 */
function mcapi_pending_mcapi_info_states() {
  return array(
    //must be defined with lower case
    TRANSACTION_STATE_PENDING => array(
      'name' => t("Pending"),
      'description' => t("awaiting signatures before becoming 'finished'."),
      'default_access_callbacks' => array('mcapi_xacc_participants')
    )
  );
}

/*
 * Will implement hook_entity_load or some such
 */
function mcapi_pending_entity_load($entities, $type) {
  if ($type != 'transaction')return;
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $key => $transaction) {
    $transaction->pending_signatures = mcapi_get_signatories($transaction->serial);
  }
}

/*
 * implements hook_entity_insert
 * creates signatures in the transaction object and sends them off to be written
 */
function mcapi_pending_entity_insert($transaction, $type) {
  if ($type != 'transaction' || $transaction->state != TRANSACTION_STATE_PENDING || $transaction->type == 'auto') return;
  //load the mcapi_form to check if this transaction has any signatories
  //this is where we actually add the signatures to the transaction object
  if (module_exists('mcapi_forms')) {
    $mcapi_form = mcapi_forms_load($transaction->type);
    if ($mcapi_form->data['perspective'] == 1) {
    foreach (array('1stperson', '2ndperson') as $participant) {
        $uid = $transaction->payee == $GLOBALS['user']->uid ? $transaction->payer : $transaction->payee;
        $transaction->pending_signatures[$uid] = 1;
      }
    }
    elseif ($mcapi_form->data['perspective'] == 3) {
      foreach (array('payer', 'payee') as $participant) {
        $transaction->pending_signatures[$transaction->$participant] = 1;
      }
    }
  }
  else {
    //make pending for any user who isn't the current user
    foreach (array('payer', 'payee') as $participant) {
      if ($transaction->$participant != $GLOBALS['user']->uid) {
        $transaction->pending_signatures[$transaction->$participant] = 1;
      }
    }
  }
  mcapi_pending_save_signatures($transaction);
}

function mcapi_pending_save_signatures($transaction) {
  //need to check property 'pending_signatures' because it may not have been declared
  if (empty($transaction->pending_signatures)) return;
  foreach ($transaction->pending_signatures as $uid => $pending) {
    db_merge('mcapi_signatures')->key(array(
      'serial' => $transaction->serial,
      'uid' => $uid
    ))->fields(array(
      'pending' => $pending
    ))->execute();
  }
}

/*
 * Will implement hook_entity_delete or some such
 */
function mcapi_pending_entity_delete($entity, $type) {
  if ($type == 'transaction' && !empty($entity->pending_signatures)) {
    db_query("DELETE FROM {mcapi_signatures} WHERE serial = :serial", array(':serial' => $transaction->serial));
  }
}

/*
 * resaves signatories from the transaction object and changes state if all are signed
 */
function mcapi_sign($serials, $uids) {
  if (is_numeric($uids)) {
    $uids = array($uids);
  }
  if (count($uids) > 1 && count($serials) > 1) throw new Exception('Pending module error');
  //remove signatures one at a time
  foreach ($serials as $serial) {
    $transaction = transaction_load($serial);
    foreach ($uids as $uid) {
      if ($transaction->pending_signatures[$uid] == 1) {
        $transaction->pending_signatures[$uid] = 0;
        mcapi_pending_save_signatures($transaction);
      }
      else {
        drupal_set_message(t('Transaction #@serial is already signed by @name',
          array('@serial' => $transaction->serial, '@name' => user_load($uid)->name)
        ));
      }
    }
    if (count(array_filter($transaction->pending_signatures)) == 0) {
      $change_state[] = $serial;
    }
    else {
      drupal_set_message(t("@num signatures remaining on transaction #@serial", 
        array('@num' => count(array_filter($transaction->pending_signatures)), '@serial' => $serial)));
    }
  }
  if (empty($change_state)) return;
  //change the state of the transaction if all signatures are present
  try {
    transaction_state($change_state, TRANSACTION_STATE_FINISHED, TRUE);
  }
  catch (Exception $e){
    drupal_set_message($e->getMessage());
  }
}
/*
 * Implements hook_views_api
 */
function mcapi_pending_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending'),
  );
}

/*
 * Implements ctools hook_ctools_plugin_api
 * not sure if this is needed
 */
function mcapi_pending_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending'),
  );
}

//returns a list of the user objects who are yet to sign
//will take EITHER a serial OR a uid, returns a list of the other
function mcapi_get_signatories($serial = NULL, $uid = NULL) {
  if ($serial && $uid) {
    drupal_set_message('Bad arguments to mcapi_get_signatories', 'error');
    return;
  }
  $signatures = array();
  $query = db_select('mcapi_signatures', 's');
  if ($serial) {
    $result = $query->fields('s', array('uid', 'pending'))->condition('serial', $serial)->execute()->fetchAllKeyed(0);
  }
  else {
    $result = $query->fields('s', array('serial'))->condition('pending', 1)->condition('uid', $uid)->execute()->fetchCol();
  }
 
  return $result;
}


/*
 * implements hook_form_FORMID_alter
 * bumps the signature form up to stage 2, where the fields are rendered as text
 */
function mcapi_pending_form_mcapi_forms_form_alter(&$form, &$form_state) {
  if ($form_state['build_info']['args'][1]->name != 'add_my_signature') return;
  unset($form['experience']['title'], $form['experience']['template']);
  //replace the transaction_form_submit callback because we only want to change the state, not save the 'values and everything
  $key = array_search('transaction_form_submit', $form['#submit']);
  $form['#submit'][$key] = 'add_my_signature_submit';
  unset($form['buttons']['delete']);
}

/*
 * form submit callback
 */
function add_my_signature_submit($form, &$form_state) {
  $serial = $form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]->serial;
  mcapi_sign(array($serial), array($GLOBALS['user']->uid));
}


/*
 * This menu callback is handled differently to the standard signing form
 */
function mcapi_signoff_confirm_form($form, $form_state, $transaction) {
  //check that the balances will be ok if we change state
  try {
    $serials = array($transaction->serial);
    transaction_state($serials, TRANSACTION_STATE_FINISHED, FALSE);
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'warning');
    return array();
  }

  mcapi_hide_tabs();
  $form = array();
  $form_state['redirect'] = 'transaction/'. $transaction->serial;
  $form['serial'] = array(
    '#type' => 'hidden',
    '#value' => $transaction->serial
  );
  $signatories = array_filter(mcapi_get_signatories($transaction->serial));
  $users = user_load_multiple(array_keys($signatories));
  $form['#prefix'] = t('Are you sure you want to sign this transaction on behalf of @users?',
    array('@users' => mcapi_format_usernames($users))
  );
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signoff_confirm_form_validate($form, $form_state) {
  if ($reason = pending_not_signable($form_state['values']['serial'])) {
    form_set_error('', $reason);
  }
}

function mcapi_signoff_confirm_form_submit($form, &$form_state) {
  $serial = &$form_state['values']['serial'];
  if ($reason = pending_not_signable($serial)) {
    drupal_set_message($reason, 'error');
  }
  $signatories = array_filter(mcapi_get_signatories($serial));
  mcapi_sign(array($serial), array_keys($signatories));
  $form_state['redirect'] = 'transaction/'. $serial;
}
//returns a message if the transaction is not signable
function pending_not_signable($serial) {
  $signatories = array_filter(mcapi_get_signatories($serial));
  try {
    if (transaction_load($serial)->state != TRANSACTION_STATE_PENDING) {
      throw new Exception(t('Transaction is not in pending state'));
    }
    if (empty($signatories)) {
      throw new Exception(t('Pending transaction has no signatures waiting'));
    }
    $serials = array($serial);
    transaction_state($serials, TRANSACTION_STATE_FINISHED, TRUE);
  }
  catch(Exception $e) {
    return $e->getMessage();
  }
}

function mcapi_signall_confirm_form($form, $form_state, $account) {
  $form = array();
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid
  );
  $form['#prefix'] = t('Are you sure you want to sign all your transactions?');
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signall_confirm_form_submit($form, &$form_state) {
  $uid = &$form_state['values']['uid'];
  //get all the transactions
  $serials = array_keys(mcapi_get_signatories(NULL, $uid));
  $transactions = transactions_load(array(), array('serial' => $serials));
  //sign them one by one
  foreach ($transactions as $transaction) {
    $serials[] = $transaction->serial;
  }
  mcapi_sign($serials, array($uid));
  $form_state['redirect'] = 'user';
}


/*
 * Integration with mcapi_forms module
 *
 * Implements hook_form_FORM_ID_alter
 * modifies its own form to hide exceptional fields
 */
function mcapi_pending_form_ctools_export_ui_edit_item_form_alter(&$form, &$form_state) {
  //check that this is actually a transaction form
  if ($form_state['plugin']['schema'] != 'mcapi_forms') return;
  if ($form_state['item']->name != 'add_my_signature') return;

  $form['architecture']['path']['#disabled'] = TRUE;
  //disable the fields that would change the meaning of the form.
  $form['submission']['state']['#type'] = 'hidden';
  $form['submission']['state']['#value'] = 0;
  $form['architecture']['use_block']['#type'] = 'hidden';
  $form['architecture']['menu_link']['#type'] = 'hidden';
  $form['architecture']['menu_link']['#value'] = 0;
  $form['perspective']['#type'] = 'hidden';
  $form['perspective']['#value'] = 3;
  $instances = field_info_instances('transaction', 'transaction');
    mcapi_disable_recursive($form['payer']);
    mcapi_disable_recursive($form['payee']);
  foreach ($instances as $instance) {
    mcapi_disable_recursive($form[$instance['field_name']]);
  }
  unset($form['step-1']);
}

/*
 * implements hook_block_info_alter
 * adjusts the blocks declared by the default view
 */
function mcapi_pending_block_info_alter(&$blocks) {
  //because this view requires an argument which probably comes from the url
  if (isset($blocks['views']['signatures-user_pending'])) {
    $blocks['views']['signatures-user_pending']['visibility'] = 1;
    $blocks['views']['signatures-user_pending']['pages'] = 'user*';
  }
}

function mcapi_pending_cron() {
  mcapi_check_integrity();
}
function mcapi_check_integrity() {
  $serials = db_query("SELECT t.serial FROM {mcapi_transactions} t LEFT JOIN {mcapi_signatures} s ON t.serial = s.serial WHERE s.pending = 1 AND t.state = :state", array(':state' => TRANSACTION_STATE_FINISHED))->fetchCol();
  if (count($serials)){
    watchdog('mcapi_pending', 'Some completed transactions still have signatures pending, please report to matslats: @serials', array('@serials' => implode(', ', $serials)), WATCHDOG_ERROR);
  }

  $serials = db_query("SELECT s.serial FROM {mcapi_transactions} t RIGHT JOIN {mcapi_signatures} s ON t.serial = s.serial WHERE s.pending = 0 AND t.state = :state", array(':state' => TRANSACTION_STATE_PENDING))->fetchCol();
  if (count($serials)) {
    watchdog('mcapi_pending', 'Some pending transactions have no signatures pending, please report to matslats: @serials', array('@serials' => implode(', ', $serials)), WATCHDOG_ERROR);
  }
}


function mcapi_disable_recursive(&$array) {
  $array['#disabled'] = TRUE;
  foreach(element_children($array) as $fieldname) {
    mcapi_disable_recursive($array[$fieldname]);
  }
}
<?php

use Drupal\mcapi_1stparty\Entity\FirstPartyFormDesign;
use Drupal\Core\Session\AccountInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\mcapi\Entity\Exchange;
use Drupal\Core\Entity\Entity\EntityFormDisplay;
use Drupal\mcapi\Entity\Transaction;

/**
 * implements hook_help().
 */
function mcapi_1stparty_help($route_name) {
  if ($route_name == 'mcapi.admin_1stparty_editform_list') {
    $help[] = t('Design your own forms for users to start transactions on their workflow paths.');
    $help[] = t('Each form has access control and can be presented as a block, page or panel.');
    $help[] = t('Each form can have presets and hidden fields.');
    //TODO might want to put some more detail here or at the top of the form editor page
    return implode(' ', $help);
  }
}

/**
 * implements hook_entity_type_alter().
 * adds a form controller to the transaction entity
 * @deprecated
 */
function mcapi_1stparty_entity_type_alter(array &$entity_types) {
  $entity_types['mcapi_transaction']->setFormClass('1stparty', 'Drupal\mcapi_1stparty\FirstPartyTransactionForm');
}


/**
 * implements hook_theme().
 */
function mcapi_1stparty_theme() {
  return array(
    '1stpartyform'=> array(
      'function' => 'theme_1stpartyform',//no template is possible here
      'render element' => 'element',
    ),
  );
}

/**
 * theme preprocessor
 */
function template_preprocess_1stpartyform(&$vars) {
  $form = &$vars['element'];
  //add the buttons if they weren't  in the twig template already
  if (strpos($form['#twig'], '{{ actions }}') === FALSE) {
    $form['#twig'] .= "\n{{ actions }}";
  }
}

/**
 * theme implementation of callback 1stpartyform
 * this must be a function, because we are taking a twig string instead of using a template file
 */
function theme_1stpartyform($vars) {
  $form = $vars['element'];
  $tokens = array();
  foreach (element_children($form) as $fieldname) {
    if (strpos($form['#twig'], '{{ '.$fieldname.' }}') !== FALSE) {
      $tokens[$fieldname] = mcapi_render_stripped($form[$fieldname]);
    }
    else {
      if (@$form[$fieldname]['#default_value'] || @$form[$fieldname]['#value']) {
        $tokens['hidden_elements'][$fieldname] = $form[$fieldname];
      }
      elseif ($form[$fieldname]['#required']) {
        drupal_set_message(t('No default value for required hidden element @name', array('@name' => $fieldname)));
      }
    }
  }
  $last = key($tokens);
  //adjustments for intertrade mode
  if (array_key_exists('intertrade', $tokens)) {// && array_key_exists('partner_all', $form)) {
    $checkbox = mcapi_render_stripped($form['partner_all']);
    if (array_key_exists('partner', $tokens)) {
      $tokens['partner'] .= $checkbox;
    }
    else {
      $tokens[$last] .= $checkbox;
    }
  }

  //append everything not rendered onto the last rendered thing.
  //$tokens['hidden_elements'] = $form;
  $form['#twig'] .= '{{ hidden_elements }}';

  return \Drupal::service('twig')->renderInline(_filter_autop($form['#twig']), $tokens);
}

/**
 * callback to render form elements without their theme_wrappers
 * simply stripping the theme_wrappers is cleaner but prevents the #states from working.
 *
 * @param array $element
 *
 * @return string
 *   HTML
 */
function mcapi_render_stripped(&$element) {
  if (array_key_exists('#type',  $element)) {
    if (!in_array($element['#type'], array('checkbox', 'checkboxes', 'radios', 'actions', 'value'))) {
      $element['#prefix'] = '<span class = "form-item">';
      $element['#suffix'] = '</span>';
      unset($element['#theme_wrappers']);
    }
  }
  return drupal_render($element);
}

/**
 * machine_name callback
 * @param unknown $id
 */
function mcapi_editform_load($id) {
  return FirstPartyFormDesign::load($id);
}

/**
 * get all the tokens which apply in the transaction form
 * @return array
 *   the token names, without the 'type:'
 */
function mcapi_1stparty_transaction_tokens() {
  module_load_include ('inc', 'mcapi');
  $tokens = array();
  $tokens += mcapi_transaction_list_tokens(FALSE);

  unset($tokens[array_search('state', $tokens)]);
  unset($tokens[array_search('serial', $tokens)]);
  unset($tokens[array_search('creator', $tokens)]);
  //TODO remove this if it isn't required. @see Transaction::baseFieldDefinitions()
  unset($tokens[array_search('langcode', $tokens)]);
  //replace payer and payee with partner and direction
  $tokens[array_search('payer', $tokens)] = 'partner';
  $tokens[array_search('payee', $tokens)] = 'mywallet';
  $tokens[] = 'direction';
  $tokens[] = 'intertrade';
  return $tokens;
}

/**
 * Check whether the current user can access a given 1stparty form.
 * used by the router and by the block controller
 *
 * @param FirstPartyFormDesign $editform
 *
 * @param AccountInterface $account
 *
 * @return boolean
 *   TRUE if the current user can access the given form
 */
function mcapi_1stparty_access(FirstPartyFormDesign $editform, AccountInterface $account) {
  die('mcapi_1stparty_access');
}

/**
 * Make a transaction entity loaded up with the defaults from the Designed form
 * @param object $configEntity
 * @return mcapi_transaction
 *   a partially populated transaction entity
 */
function mcapi_1stparty_make_template($configEntity) {
  $props = array();
  $props['type'] = $configEntity->get('type');
  $props['description'] = $configEntity->get('description.preset');
  //we can't set a default for mywallet because it is differnet for every user
  if ($configEntity->get('direction.preset') == 'outgoing') {
    $props['payee'] = $configEntity->get('partner.preset');
  }
  else {
    $props['payer'] = $configEntity->get('partner.preset');
  }
  foreach ($configEntity->get('fieldapi_presets') as $fieldname => $value) {
    $props[$fieldname] = $value;
  }
  //so the worth defaults have been copied right out of the saved entity
  return Transaction::Create($props);
}

/**
 * return the visible field definitions for any transaction field API fields
 * according to the default transaction entity_form_display
 * including worth, or course
 *
 * @return array
 *   field definitions and widgets keyed by field name
 */
function mcapi_1stparty_fieldAPI() {
  //we need this to get the widgets for entering the defaults
  $entity_display = EntityFormDisplay::load('mcapi_transaction.mcapi_transaction.default');
  $fieldAPI = array();
  //get the field API fields showing according to the the default display
  //and filter out the entity properties
  //the entity_form_display does this more elegantly but function is protected
  foreach(\Drupal::entityManager()->getFieldDefinitions('mcapi_transaction', 'mcapi_transaction') as $field_name => $definition) {
    if ($definition instanceOf FieldConfig) {
      if ($widget = $entity_display->getRenderer($field_name)) {
        $fieldAPI[$field_name] = array(
          'definition' => $definition,
          'widget' => $widget
        );
      }
    }
  }
  return $fieldAPI;
}

function mcapi_1stparty_form_field_ui_form_display_overview_form_alter(&$form, $form_state) {
  $form['#suffix'] = t('N.B. Disabled fields may cause problems with the transaction form editor');
}

/**
 * implements hook_menu_links_discovered_alter().
 * adds menu links where the firstparty forms specify them
 * adding/Altering menu links, local tasks and local actions are all veyr different...
 * @param unknown $definitions
 */
function mcapi_1stparty_menu_links_discovered_alter(&$definitions) {
  foreach (FirstPartyFormDesign::loadMultiple() as $id => $first_party_form) {
    if (empty($first_party_form->menu['menu_name'])) continue;
    $route_name = 'mcapi.1stparty.'.$id;

    $parent_path = substr($first_party_form->path, 0, strrpos($first_party_form->path, '/'));
    $definitions[$route_name.'.link'] = array(
      'title' => $first_party_form->title,
      'route_name' => $route_name,
      //TODO currently the entity doesn't support nested menu items
//      'parent' => '',
      'provider' => 'mcapi_1stparty',
    );
  }
}

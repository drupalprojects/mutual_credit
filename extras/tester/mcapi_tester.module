<?php

use Drupal\Core\Entity\EntityStorageException;
use Drupal\mcapi\McapiTransactionException;
use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Exchange;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\Entity\Wallet;
use Drupal\user\Entity\User;

/**
 * implements hook_menu().
 */
function mcapi_tester_menu() {
  return array(
    'admin/accounting/generate' => array(
      'title' => 'Generate data',
      'description' => 'delete all data and create fresh',
      'route_name' => 'mcapi.generate'
    )
  );
}
/**
 * implements hook_permissions().
 */
function mcapi_tester_permissions() {
  return array(
    'exchange helper' => array(
      'title' => t('Helper within an exchange'),
      'description' => t("Enhanced access within one's own exchanges")
    )
  );
}

/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields
 */
function mcapi_tester_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  if ($roles = user_role_names(TRUE, 'exchange helper')) {
    $helpernames = array();
    //get all the helper users in this exchange
    $query = db_select('users_roles', 'ur')->fields('ur', array('uid'));
    $query->join('user__exchanges', 'f', 'f.entity_id = ur.uid');
    $query->condition('ur.rid', array_keys($roles))
    ->condition('f.exchanges_target_id', $entity->id());

    foreach (User::loadMultiple($query->execute()->fetchCol()) as $account) {
      $helpernames[] = $account->label();//what's the best way to make this a link?
    }
    if (empty($helpernames)) {
      $helpernames = array(t('None'));
    }
    $build['people']['helpers'] = array(
      '#prefix' => '<br />',
      '#markup' => t('Helpers: !names', array('!names' => implode(', ', $helpernames)))
    );
  }
}


function mcapi_tester_make_transactions($num, $inter = FALSE) {
  $all_exchanges = Exchange::loadMultiple();
  if ($inter) {
    //get a list of all wids
    //pick a random wallet (not _intertrading);
    $wids = \Drupal\mcapi\Storage\WalletStorage::filter(array(), 0, 0);

    //remove wallet 2, belonging to user 1, because of a caching problem - very uncomfortable hack
    $pos = array_search('2', $wids);
    unset($wids[$pos]);
  }
  for ($i = 1; $i <= $num; $i++) {
    if (!$inter) {
      //choose an exchange and get the wids in it
      $key = array_rand($all_exchanges);
      $exchange = $all_exchanges[$key];
      //because this is just the tester module I don't bother using the storage API
      $q = db_select('mcapi_wallet_exchanges_index', 'i');
      $q->join('mcapi_wallet', 'w', 'w.wid = i.wid');
      $wids = $q->fields('i', array('wid'))
        ->condition('i.exid', $exchange->id())
        ->condition('w.name', '_intertrading', '<>')
        ->execute()->fetchCol();
    }
    if (count($wids) < 2) {
      throw new \Exception('Not enough wallets to trade: '.($inter ? 'intertrading' : 'normal'));
    }
    //get two random different wallets - the first one...
    $temp = $wids;
    shuffle($temp);
    $props = array(
      'payer' => array_pop($temp),
      'payee' => array_pop($temp),
      'type' => 'test',
      'creator' => 1,
      'description' => 'autogenerated'
    );
    if ($inter) {
      //get an exchange the payer is in, and an open currency in that exchange
      $wallet = Wallet::load($props['payer']);
      $owner = $wallet->getOwner();
      foreach (Exchange::referenced_exchanges($owner) as $exchange) {
        foreach ($exchange->currencies->referencedEntities() as $currency) {
          if ($currency->ticks) break;
        }
      }
      if (!isset($currency)) {
        drupal_set_message($owner->getEntityTypeId() .' '.$owner->id() .' is not in any exchanges');
        continue;
        //drupal_set_message('No currencies in exchange '.$exchange->id());
      }
    }
    else {
      $currencies = exchange_currencies(array($exchange));
      $currency = reset($currencies);
    }

    $props['worth'] = array(
      0 => array(
        'value' => rand(5, 100)*10,
        'curr_id' => $currency->id()
      )
    );
    try {
      //there is no way to get the soft error messages out when a transaction is created in code.
      $transaction = Transaction::create($props);
      $transaction->save();
    }
    catch (McapiTransactionException $e) {
      //todo

    }
    catch(EntityStorageException $e) {
      //all errors will be entityStorage exceptions because save() catches and rethrows them
      //random attempts at intertrading are bound to produce some errors.
      //otherwise we actually do have a problem
      if ($inter) continue;
      throw new Exception($e->getMessage);
    }
    if ($num == 1 && $transaction){
      drupal_set_message(l('Created transaction', $transaction->url('canonical')));
    }
  }
}

function mcapi_tester_1stparty_editform_load($entities) {
//  debug($entities);
  foreach ($entities as &$firstpartyform) {
  //  if
  }
}
<?php

use Drupal\mcapi\Exchange;
use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\Entity\Wallet;
use Drupal\mcapi_exchanges\Entity\Exchanges;
use Drupal\user\Entity\User;


/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields
 */
function mcapi_tester_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  //@todo this role should be an og role
  return;
  if ($roles = user_role_names(TRUE, 'exchange helper')) {
    $helpernames = [];
    //get all the helper users in this exchange
    $query = db_select('users_roles', 'ur')->fields('ur', array('uid'));
    $query->join('user__exchanges', 'f', 'f.entity_id = ur.uid');
    $query->condition('ur.rid', array_keys($roles))
    ->condition('f.exchanges_target_id', $entity->id());

    foreach (User::loadMultiple($query->execute()->fetchCol()) as $account) {
      $helpernames[] = $account->label();//what's the best way to make this a link?
    }
    if (empty($helpernames)) {
      $helpernames = array(t('None'));
    }
    $build['people']['helpers'] = array(
      '#prefix' => '<br />',
      '#markup' => t('Helpers: !names', array('!names' => implode(', ', $helpernames)))
    );
  }
}

function mcapi_tester_make_transactions($num, $exchange = NULL) {
  //choose an exchange and get the wids in it
  $exchange_ids = [];
  if ($exchange) {//assume the mcapi_exchanges module is enabled
    $all_exchanges = Exchange::loadMultiple();
    $exchange_ids = array_keys($all_exchanges);
    $key = array_rand($all_exchanges);
    $exchange = $all_exchanges[$key];
    //get all the wallets in this exchange
    $q = db_select('og_membership', 'g');
    $q->join('mcapi_wallet', 'w', 'w.wid = g.etid');
    $q->fields('g', array('etid'));
    $q->condition('w.name', '_intertrading', '<>');
    $q->condition('g.group_type', 'mcapi_exchange');
    $q->condition('g.gid', $exchange->id());
    $q->condition('g.entity_type', 'mcapi_wallet');
    $wids = $q->execute()->fetchCol();
  }
  else {
    $wallets = \Drupal::EntityManager()->getStorage('mcapi_wallet')->loadByProperties(['entity_type' => 'user']);
    //quick way to select non-intertrading wallets
    $wids = array_keys($wallets);
  }
  if (count($wids) < 2) {
    throw new \Exception('Not enough wallets to trade: '.($inter ? 'intertrading' : 'normal'));
  }

  for ($i = 1; $i <= $num; $i++) {
    $temp = $wids;
    shuffle($temp);
    $props = array(
      'payer' => array_pop($temp),
      'payee' => array_pop($temp),
      'type' => 'test',
      'creator' => 1,
      'description' => 'autogenerated'
    );
    $currencies = Exchange::userCurrencies($props['payer']);

    $props['worth'] = array(
      0 => array(
        'value' => rand(5, 100)*10,
        'curr_id' => reset($currencies)->id()
      )
    );
    mcapi_save_test_transaction($props);
  }
}

function mcapi_tester_make_inter_transactions($num) {
  $exchanges = Exchange::loadbyProperties(array('status' => 1, 'open' => 1));
  foreach($exchanges as $exchange) {
    $wids[$exchange->id()] = get_mcapi_wallets_in_exchanges(array($exchange->id()));
  }

  //remove wallet 2, belonging to user 1, because of a caching problem - very uncomfortable hack
  //$pos = array_search('2', $wids);
  //unset($wids[$pos]);
  //get two random different wallets - the first one...
  for ($i = 1; $i <= $num; $i++) {
    $wids1 = $wids;
    shuffle($wids1);
    $e1 = reset($wids1);
    $e2 = next($wids1);
    $k1 = array_rand($e1);
    $k2 = array_rand($e2);

    $props = array(
      'payer' => $e1[$k1],
      'payee' => $e2[$k2],
      'type' => 'test',
      'creator' => 1,
      'description' => 'autogenerated intertrade'
    );
    reset($wids1);
    //does key() advance the array cursor?
    $currencies = Exchanges::currencies(array(key($wids1), key($wids1)), $ticks = FALSE);
    if (empty($currencies)) {
      debug('No currencies in exchange(s) '.$exchange_id);
      continue;
    }
    $props['worth'] = array(
      0 => array(
        'value' => rand(5, 100)*10,
        'curr_id' => reset($currencies)->id()
      )
    );
    mcapi_save_test_transaction($props);
  }
}

function mcapi_save_test_transaction($props) {
  try {
    //there is no way to get the soft error messages out when a transaction is created in code.
    $transaction = Transaction::create($props);
    $transaction->save();
  }
  catch (\Exception $e) {
    //@todo

  }
  catch(\Exception $e) {
    throw new Exception($e->getMessage);
  }

}

function mcapi_tester_1stparty_editform_load($entities) {
//  debug($entities);
  foreach ($entities as &$firstpartyform) {
  //  if
  }
}

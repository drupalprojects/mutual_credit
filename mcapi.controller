<?php

  /*
   * creates a transaction-shaped object using the passed values
   * the transaction would fail its own validation without being populated though
   * PRIOR to writing in the database
   * that means it does nothing with the xid and the serial number
   *   'values' can contain any of
   *   'payer' - user ID
   *   'payee' - user ID
   *   'creator' - User ID
   *   'created' - unixtime
   *   'type' - string defined in hook_mcapi_info_types
   *   'extra' -
   *   'state' - constant defined in hook_mcapi_info_states
   *   'worth' - fieldAPI array begining with LANGUAGE_NONE
   *     OR
   *   'quantity' (AND currcode) numeric value (AND currency identifier)
   *   'description' OR $description_field_name string describing purpose of transaction
   *
   */
  public function create(array $values = array(), $for_me = FALSE) {
    $transaction = new stdClass;
    $default_props = array(
      'payer' => NULL,
      'payee' => NULL,
      'creator' => \Drupal::currentUser()->id(),
      'created' => REQUEST_TIME,
      'type' => 'default',
      'extra' => array(),
      'state' => TRANSACTION_STATE_FINISHED,
      'description' => t('No description provided'),
      'worths' => array()
    );
    foreach ($default_props as $key => $val) {
      $transaction->$key = array_key_exists($key, $values) && !empty($values[$key]) ? $values[$key] : $val;
      unset($values[$key]);
    }
    if (isset($values['worths'])) {
      foreach ($values['worths'] as $currcode => $quantity) {
        //TODO check that the currency exists and that payer and payee, if set, can use it.
        $transaction->worth[$currcode] = $quantity;
      }
      unset($values['worths']);
    }
    elseif(array_key_exists('quantity', $values)) {
      //TODO get the default currcode
      $transaction->worth[$currcode] = $quantity;
      unset($values['quantity']);
    }
    else {//if worths is not indicated, set 0 for each currency the user is permitted to use
      //check that the creator is actually permitted to use this currency
      $currencies = $for_me ? currencies_load(\Drupal::currentUser()) : currencies_load();
      foreach (array_keys($currencies) as $currcode) {
        $transaction->worth[LANGUAGE_NONE][] = array(
          'quantity' => 0,
          'currcode' => $currcode
        );
      }
    }
    //probably the following fieldapi fields should be handled someotherhow, but this works
    //and is particularly convenient for when transactions are created without awareness of the field API.
    //finally any other fields...
    foreach($values as $fieldname => $value) {
      if (empty($value)) continue;
      //special presetting for taxonomy fields
      $field = field_info_field($fieldname);
      if (!is_array($field)) continue;
      if ($field['type'] == 'taxonomy_term_reference') {
        if (is_numeric($value)) {//because the forms module will return just one number if we're not careful
          $transaction->{$fieldname}[LANGUAGE_NONE][]['tid'] = $value;
        }
        elseif (!is_numeric($value) && is_string($value)) {//the incoming value is a string of comma separated tags
          if ($value == "_none") continue;
          foreach(drupal_explode_tags($value) as $term_name) {
            $term = current(taxonomy_get_term_by_name($term_name));
            $transaction->{$fieldname}[LANGUAGE_NONE][] = array('tid' => $term->tid);
          }
        }
        elseif (is_array($value)) {//must be a fieldAPI thing
          $transaction->{$fieldname} = $value;
        }
        else throw new Exception("Don't know how to add terms in this format: ".print_r($value, 1));
      }
      else {
        //YUK
        if (is_array($value)) $value = array_pop($value);
        if (is_array($value)) $value = array_pop($value);
        $transaction->{$fieldname}[LANGUAGE_NONE][] = $value;
      }
    }
    $transaction->dependents = array();
    return $transaction;
  }

  /*
   * get some stats by adding up the transactions for a given user
   * this is currently used for the limits module and for the views handler per-row
   * caching running balances is innappropriate because they would all need recalculating any time a transaction changed state
   */
  public function sums($uid, $currcode, $conditions) {
    $query = "SELECT
      COUNT(w1.worth_quantity) + COUNT(w2.worth_quantity) as count,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)), 0) as gross_in,
      COALESCE(SUM(COALESCE(w1.worth_quantity, 0)), 0) as gross_out,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)) - SUM(COALESCE(w1.worth_quantity, 0)), 0) as balance,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)) + SUM(COALESCE(w1.worth_quantity, 0)), 0) as volume

      WHERE (t.payer = $uid OR t.payee = $uid)" . mcapi_parse_conditions($conditions);
    if ($result = db_query($query)->fetchAssoc()) {
      return $result;
    }
    return array('count' => 0, 'gross_in' => 0, 'gross_out' => 0, 'balance' => 0, 'volume' => 0);
  }

  function mcapi_parse_conditions($conditions) {
    if (empty($conditions)) return '';
    $where = array();
    foreach ($conditions as $condition) {
      if (is_array($condition)) {
        $condition[] = '=';
        list($field, $value, $operator) = $condition;
        if (empty($operator)) $operator = ' = ';
        if (is_array($value)) {
          $value = '('.implode(', ', $value) .')';
          $operator = ' IN ';
        }
        $where[] = " ( t.$field $operator $value ) ";
      }
      else {//the condition is already provided as a string
        $where[] = " $condition ";
      }
    }
    return ' AND '. implode(' AND ', $where);
  }

  public function delete($xids) {
    if (count($xids)) {
      db_delete('mcapi_transactions')->condition('xid', $xids)->execute();
    }
  }

  /*
   * Get a list of xids and serial numbers
   * see transaction.api.php for arguments
   */
  public function filter(array $conditions, $offset, $limit) {
    extract($conditions);//
    //db_set_active(variable_get('mcapi_db_read', 'default'));
    $query = db_select('mcapi_transactions', 'x')//should we use db_query_range?
      ->fields('x', array('xid', 'serial'))
      ->orderby('created', 'DESC');
    if ($limit) {
      $query->range($offset, $limit);
    }
    //db_set_active();
    if (isset($serial)) {
      $query->condition('serial', (array)$serial);
    }
    if (isset($state)) {
      $query->condition('state', (array)$state);
    }
    if (isset($payer)) {
      $query->condition('payer', (array)$payer);
    }
    if (isset($payee)) {
      $query->condition('payee', (array)$payee);
    }
    if (isset($creator)) {
      $query->condition('creator', (array)$creator);
    }
    if (isset($type)) {
      $query->condition('type', (array)$type);
    }
    if (isset($involving)) {
      $query->condition(db_or()
        ->condition('payer', (array)$involving)
        ->condition('payee', (array)$involving)
      );
    }
    if (isset($from)) {
      $query->condition('created', $from, '>');
    }
    if (isset($to)) {
      $query->condition('created', $to,  '<');
    }

    if (isset($currcode) || isset($quantity)) {
      $query->join('field_data_worth', 'w', 'x.xid = w.entity_id');
      if (isset($currcode)) {
        $query->condition('worth_currcode', $currcode);
      }
      if (isset($quantity)) {
        $query->condition('worth_quantity', $quantity);
      }
    }
    return $query->execute()->fetchAllKeyed();
  }


  //this is undocumented.
  //when users are deleted, their uids should not persist in the transaction table.
  public function mergeAccounts($main) {
    $uids = func_get_args();
    $main = array_shift($uids);
    foreach ($uids as $uid) {
      db_update('mcapi_transactions')
        ->fields(array('payer' => $main))
        ->condition('payer', $uid)->execute();
      db_update('mcapi_transactions')
        ->fields(array('payee' => $main))
        ->condition('payee', $uid)->execute();
      $serials = transaction_filter(array('payer' => $main, 'payee' => $main));
      //this is usually a small number, but strictly speaking should be done in a batch.
      foreach (array_unique($serials) as $serial) {
        transaction_undo($serial, MCAPI_UNDO_STATE_DELETE);
      }
    }
  }
}

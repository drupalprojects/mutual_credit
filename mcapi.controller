<?php
// $Id:
/*
 * This file is included using the function mcapi_controller();
 * the class should be named thus:
 * MODULENAME_EntityController
 */
define('MCPI_CURRENCY_UPDATE_NONE', 0);
define('MCPI_CURRENCY_UPDATE_HARD', 2);
define('MCPI_CURRENCY_UPDATE_SOFT', 1);

/*
 * The transaction entity has its own CRUD operations
 */
class mcapi_EntityController extends DrupalDefaultEntityController {
  /*
   * This controller actually writes the transaction during validation
   * When written, the transaction has a unique ID, so we
   * indicate that the transaction is actually a new transaction with the new property, 'is_new'
   * Adapted from the default entity controller.
   * no support for revisions
   * switches database to load transactions
   * returns an error if the transaction id is invalid
   */
  public function load($ids = array(), $conditions = array()) {
    $entities = array();
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;

    //get from cache where available
    if ($this->cache) {
      $entities += $this->cacheGet($ids, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }

    if ($ids === FALSE || $ids || ($conditions && !$passed_ids)) {
      db_set_active(variable_get('mcapi_db_read', 'default'));
      $query = db_select($this->entityInfo['base table'], 'base');
      db_set_active();
      $query->fields('base', $this->entityInfo['schema_fields_sql']['base table']);
      // Build the query.
      if ($ids) {
        $query->condition("base.{$this->idKey}", $ids, 'IN');
      }
      foreach ($conditions as $field => $value) {
        $query->condition('base.' . $field, $value);
      }
      $query->orderBy('created', 'ASC');
      $queried_entities = $query->execute()->fetchAllAssoc($this->idKey);
      //extract the serialized data into 'extra' property
      //there isn't acutally a use for the extra property at the moment.
      foreach ($queried_entities as $key => $entity) {
        $queried_entities[$key]->extra = unserialize($queried_entities[$key]->data);
        unset($queried_entities[$key]->data);
      }
    }

    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities);
      $entities += $queried_entities;
    }
    if ($this->cache) {
      if (!empty($queried_entities)) {
        $this->cacheSet($queried_entities);
      }
    }
    return $entities;
  }

  public function validate($transaction){
    $state = $transaction->state;
    $transaction->validating = TRUE;
    if (empty($transaction->xid)) {
      $transaction->is_new = TRUE;
    }
    $t = db_transaction();
    try {
      mcapi_controller_validate_transaction_fields($transaction);
      $transaction->state = TRANSACTION_STATE_VALIDATED;
      $this->save($transaction);
    }
    catch (Exception $e){
      //if the validation fails at this stage when everything should be validated
      //we should put it in watchdog because it means some form somewhere needs tightening up
      //unfortunately at this point we don't know what form it is.
      $transaction->extra['error'] = $e->getMessage();
      watchdog('mcapi', '@message', array('@message' => $e->getMessage()), WATCHDOG_ALERT);
      throw $e;
    }
    if (empty($transaction->is_new)) {
      $t->rollback();
    }
    unset($transaction->validating);
    return $transaction;
  }

  /*
   * update or insert the saved transaction
   * expects a single, validated transaction object
   * what the user thinks of as inserting and updating isn't actually what the controller is doing.
   * because the transaction was actually 'inserted' during the validation phase
   * So we use the 'is_new' property and run insert a second time
   * The transaction is only really processed if the validating property is NOT set
   */
  public function save($transaction) {
    //this is only used to fix what I think is a Drupal bug, see mcapi_field_attach_presave
    //removes the 'add more' item from fields with infinite cardinality
    $instances = array();
    $instances = _field_invoke_get_instances('transaction', 'transaction', array('deleted' => FALSE));
    foreach($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == -1 && isset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more'])) {
        unset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more']);
      }
    }//end of bugfix
    
    $transaction->modified = REQUEST_TIME;
    $transaction->modifier = $GLOBALS['user']->uid;
    $t = db_transaction();
    //the transaction is actually inserted during the validation phase, after validation the state should be changed
    if (isset($transaction->is_new)) $function = 'insert';
    elseif (isset($transaction->validating)) $function = 'state';
    else $function = 'update';

    try {
      $this->$function($transaction);
    }
    catch (Exception $e) {
      $t->rollback();
      watchdog_exception('mcapi', $e);
      throw $e;
    }
    if (isset($transaction->validating) || $function == 'state') return;

    module_invoke_all('entity_'.$function, $transaction, 'transaction');
    return $transaction;
  }

  /*
   * merely set the state of the exchange, not delete the row
   * there is no error checking on this.
   */
  public function erase($transaction) {
    //if there are more than one flows involved, use the minimum value for the update mode
    $flows = current($transaction->worth);
    foreach ($flows as $flow) {
      $modes[] = currency_load($flow['currcode'])->accounting['erase_mode'];
    }
    switch(min($modes)) {
      case 1: //mark deleted
        $transaction->state = TRANSACTION_STATE_ERASED;
        $transaction->modified = REQUEST_TIME;
        $transaction->modifier = $GLOBALS['user']->uid;
        try{
          mcapi_write_record($transaction, array('xid'));
        }
        catch (Exception $e) {
          $e->message .= t('Problem changing state of transaction #@xid to @state', array('@xid' => $transaction->xid, '@state' => $new_state));
          $e->code = 'mark_del';
          throw $e;
        }
        break;
      case 2: //actually delete
        $query = db_delete('mcapi_transactions')
        ->condition('xid', $transaction->xid)
        ->execute();
        field_attach_delete('transaction', $transaction);
        module_invoke_all('entity_delete', $transaction, 'transaction');
      default:
        throw new Exception(t('Deletions not allowed'));
        break;
    }
    return $transaction;
  }
  /*
   * change the state of a transaction.
   * This does not count as updating it, which is subject to different permissions
   */
  public function state($transaction) {
    db_query("UPDATE {mcapi_transactions} SET state = :state WHERE xid = :xid", array(':state' => $transaction->state, ':xid' => $transaction->xid));
    //not sure it's appropriate to run update here, when the entity is treating a state change as distinct from an update
    module_invoke_all('entity_update', $transaction, 'transaction');
    return $transaction;
  }

  /*
   * get_balance
   * this is currently used for the limits module and for the views handler per-row
   * caching running balances is dangerous because they would all need recalculating any time a transaction changed state
   * $options can be array(
   *   states => array(TRANSACTION_STATE_FINISHED)
   *   before_xid => 0
   *   after_xid => 0
   *   before_time => 0
   *   after_time => 0
   */
  public function sums($uid, $currcode, $options = array()) {
    $options += array(
      'states' => array(TRANSACTION_STATE_FINISHED),
      'before_xid' => NULL,
      'after_xid' => 0,
      'before_time' => NULL,
      'after_time' => 0
    );
    //this COALESCE is only tested for mysql.
    //when we joing the tables like this, half of all values will be NULL, and NULL values do not add
    //so these NULL values need to be selected as 0 before adding
    //there may well be a more elegant way
    $query = "SELECT
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)), 0) as gross_in,
      COALESCE(SUM(COALESCE(w1.worth_quantity, 0)), 0) as gross_out,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)) - SUM(COALESCE(w1.worth_quantity, 0)), 0) as balance,
      COUNT(t.xid) as count
      FROM {mcapi_transactions} t
      LEFT JOIN {field_data_worth} w1 ON t.xid = w1.entity_id AND w1.worth_currcode = '$currcode' AND t.payer = $uid
      LEFT JOIN {field_data_worth} w2 ON t.xid = w2.entity_id AND w2.worth_currcode = '$currcode' AND t.payee = $uid
      WHERE (t.payer = $uid OR t.payee = $uid)
        AND t.state in (:states)
        AND t.created > :after_time
        AND t.xid > :after_xid";
    if ($options['before_xid'] > 0) {
      $query .= " AND t.xid <= ".$options['before_xid'];
    }
    if ($options['before_time'] > 0) {
      $query .= " AND t.created <= ".$options['before_time'];
    }
    $replacements = array(
      ':states' => implode(',', $options['states']),
      ':after_xid' => $options['after_xid'],
      ':after_time' => $options['after_time']
    );
    return db_query($query, $replacements)->fetchAssoc();
  }
  /*
   * alternative to using views
   * Get a list of transactions for a user, between unixtimes
   * arguments, in any order can be
   * from // unixtime
   * to //unixtime
   * states array, defaults to array(0) which is completed transactions only
   * no pager is provided in this function
   * views is much better
   */
  public function get_period($uid, $variables) {
    $variables += array(
      'from' => 0,
      'to' => REQUEST_TIME + 1,
      'states' => array(TRANSACTION_STATE_FINISHED),
      'currcode' => NULL
    );
    extract($variables);
    db_set_active(variable_get('mcapi_db_read', 'default'));
    $query = db_select('mcapi_transactions', 'x')->fields('x');
    db_set_active();
    $query->condition(db_or()
      ->condition('payer', $uid)
      ->condition('payee', $uid)
    )
    ->condition('state', $states)
    ->condition('created', $from, '>')
    ->condition('created', $to,  '<')
    ->orderby('created');
    if ($currcode) {
      $query->condition('currcode', $currcode);
    }
    return $query->execute()->fetchAll();
  }
  

  /*
   * create a transaction, either the first moment at validation
   */
  function insert($transaction) {
    $transaction->creator = $GLOBALS['user']->uid;
    $transaction->created = REQUEST_TIME;
    if (empty($transaction->xid)) {
      //this is probably done during validation
      mcapi_write_record($transaction);
      field_attach_insert('transaction', $transaction);
    }
    else {
      //this is part of creating the transaction process, but after validation
      mcapi_write_record($transaction, array('xid'));
      field_attach_update('transaction', $transaction);
    }
  }

  /*
   * This controller makes no use of the entity revision control facility
   * $force_update is for the special case of a validated transaction which is being written
   */
  function update($transaction) {
    //if there are more than one flows involved, use the minimum value for the update mode
    $flows = current($transaction->worth);
    foreach ($flows as $flow) {
      $currency = currency_load($flow['currcode']);
      $modes[] = $currency->accounting['update_mode'];
    }
    switch(min($modes)) {//choose the most rigourous accounting standard
      case MCPI_CURRENCY_UPDATE_HARD:
        $old = clone(transaction_load($transaction->xid));
        $transaction->extra['former_xid'] = $transaction->xid;
        //remove the xid and insert the transaction anew
        unset($transaction->xid);
        $this->insert($transaction); //will give a new xid
        $old->extra['became_xid'] = $transaction->xid;
        //then erase the old one
        $this->erase($old);
        break;
      case MCPI_CURRENCY_UPDATE_SOFT:
        try {
          mcapi_write_record($transaction, array('xid'));
        }
        catch (Exception $e) {
          //getting an error: Cannot access protected property Exception::$message
          $e->getMessage .= ' '. t('Database failed to update transaction record.');
          throw $e;
        }
        field_attach_update('transaction', $transaction);
        break;
      //safe default
      case MCPI_CURRENCY_UPDATE_NONE:
      default:
        throw new Exception(t('This currency does not allow transaction updates.'));
    }
  }
}


/*
 * wrapper for drupal_write_record
 * writes to the database(s) specified by the entity controller settings
 */
function mcapi_write_record(&$record, $primary_keys = array()) {
  $record->data = (isset($record->extra)) ? $record->extra : array();
  //we need to ensure the schema is cached before calling mcapi_write_record
  //Otherwise it may try to retrieve the schema from the wrong database
  drupal_get_schema('mcapi');
  foreach (variable_get('mcapi_db_write', array('default')) as $connection) {
    db_set_active($connection);
    try{
      $ts[] = db_transaction();
      if(!drupal_write_record('mcapi_transactions', $record, $primary_keys)) {
        throw new Exception();
      }
      ddebug_backtrace();
      debug($record);
    }
    catch (Exception $e) {
      foreach ($ts as $db_transaction) {
        $db_transaction->rollback();
      }
      db_set_active();
      $keys = array();
      foreach ($primary_keys as $keyname) {
        $keys[$keyname] = $record->$keyname;
      }
      $keys = implode(',', $keys);
      $newmessage = t("Failed to write to table 'mcapi_transactions' on database '@database', using keys: @keys",
        array(
          '@database' => $connection,
          '@keys' => '<pre>'.print_r($primary_keys, 1).'</pre>'
        )
      );
      $replacements = array('@tablename' => 'mcapi_transactions', '@keys' => $keys, '@database' => $connection);
      if ($keys) {
        watchdog('Failed to update table @tablename of database @database using keys: @keys', $replacements, WATCHDOG_CRITICAL);
        throw new Exception(t('Failed to update table @tablename of database @database using keys: @keys', $replacements));
      }
      else {
        watchdog('Failed to insert into table @tablename of database @database', $replacements, WATCHDOG_CRITICAL);
        throw new Exception(t('Failed to insert into table @tablename of database @database', $replacements));
      }
    }
  }
  db_set_active();
}

/*
 * implements hook_currency_innerform_alter
 * Expects $form['#currency']
 */
function mcapi_currency_innerform_alter(&$form, &$form_state) {
  $form['accounting'] = array(
    '#title' => t('Accounting standards'),
    '#description' => t('More or less formal accounting standards can be determined.') .' '.
      t('Not all combinations are meaningful!'),
    '#type' => 'fieldset',
    '#weight' => -1,
    '#group' => 'additional_settings',
    'update_mode' => array(
      '#title' => t('Update mode'),
      '#type' => 'radios',
      '#options' => array(
        MCPI_CURRENCY_UPDATE_NONE => t("Can't update"),
        MCPI_CURRENCY_UPDATE_SOFT => t("Update same record"),
        MCPI_CURRENCY_UPDATE_HARD => t("Erase and create a new transaction"),
        //3 => t("Use entity versioning the same transaction (not available)"),
      ),
      '#default_value' => $form['#currency']->accounting['update_mode'],
      '#weight' => 1,
      '#element_validate' => array('mcapi_currency_validate_update_mode'),
      '#ajax' => array(
        'callback' => 'currency_form_ajax',
        'wrapper' => 'mcapi-currency-form',
      ),
    ),
    'erase_mode' => array(
      '#title' => t('Delete mode'),
      '#type' => 'radios',
      '#options' => array(
        0 => t("Can't delete"),
        1 => t('Mark deleted'),
        2 => t('Remove all traces from the database (not from backups)'),
      ),
      '#default_value' => $form['#currency']->accounting['erase_mode'],
      '#weight' => 2,
      '#ajax' => array(
        'callback' => 'currency_form_ajax',
        'wrapper' => 'mcapi-currency-form',
      ),
    )
  );
}

function mcapi_controller_validate_transaction_fields($transaction) {
  //should really validate every field that needs to go in the data base
  foreach ($transaction->worth['und'] as $worth) {
    if (!is_numeric($worth['quantity'])) {
      throw new Exception(t('Illegal quantity: @val', array('@val' => print_r($worth, 1))));
    }
  }
}
<?php
// $Id:
/*
 * This file is included using the function mcapi_controller();
 * Each function supports the choice of database connections.
 * the class should be named thus:
 * MODULENAME_EntityController
 */
/*
 * The transaction entity has its own CRUD operations
 */
class mcapi_EntityController extends DrupalDefaultEntityController {
  /*
   * This controller test writes the transaction during validation
   * mostly copied from the node controller
   * need to see what the entity module has to offer
   * no support for revisions
   * returns an error if the transaction id is invalid
   */
  public function load($ids = array(), $conditions = array()) {
    $entities = array();
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;

    //get from cache where available
    if ($this->cache) {
      $entities += $this->cacheGet($ids, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }

    if ($ids === FALSE || $ids || ($conditions && !$passed_ids)) {
      db_set_active(variable_get('mcapi_db_read', 'default'));
      $query = db_select('mcapi_transactions');
      db_set_active();
      $query->fields('mcapi_transactions', $this->entityInfo['schema_fields_sql']['base table']);
      // Build the query.
      if ($ids) {
        $query->condition("mcapi_transactions.xid", $ids);
      }
      foreach ($conditions as $field => $value) {
        $query->condition('mcapi_transactions.' . $field, $value);
      }
      $query->orderBy('xid', 'ASC'); //this ensures that the primary transaction in a cluster is first
      $queried_entities = $query->execute()->fetchAllAssoc('xid');
      //extract the serialized data into 'extra' property
      //there isn't acutally a use for the extra property at the moment.
      foreach ($queried_entities as $entity) {
        $entity->extra = unserialize($entity->data);
        unset($entity->data);
      }
    }

    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities);
      $entities += $queried_entities;
    }
    if ($this->cache) {
      if (!empty($queried_entities)) {
        $this->cacheSet($queried_entities);
      }
    }
    return $entities;
  }
  

  /*
   * put an array of transactions in the database
   * any transactions without a serial number will be assumed to be part of a new cluster
   * and saved with the same serial number
   */
  public function insert(&$transactions, $really = FALSE) {
    //we need to ensure the schema is cached before calling mcapi_write_record
    //Otherwise it may try to retrieve the schema from the wrong database
    drupal_get_schema('mcapi');
    //for now only the controller knows how to generate and serial numbers for its own
    //this subsystem system will need reworking if this module expands
    $serial = db_query("SELECT MAX(serial) FROM {mcapi_transactions}")->fetchField() + 1;
    foreach ($transactions as $transaction) {
      $transaction->temp = isset($transaction->xid) ? $transaction->xid : 0;
      $transaction->creator = $GLOBALS['user']->uid;
      $transaction->created = REQUEST_TIME;
      //do the best we can in case a serial number isn't yet provided
      $transaction->serial = empty($transaction->serial) ? $serial : $transaction->serial;
      $transaction->data = (isset($transaction->extra)) ? $transaction->extra : array();
    }
    //remember transaction might be written to more than one db
    foreach (array_filter(variable_get('mcapi_db_write', array('default'))) as $connection) {
      db_set_active($connection);
      try{
        $ts[] = db_transaction();
        foreach ($transactions as $transaction) {
          if(drupal_write_record('mcapi_transactions', $transaction) != SAVED_NEW) {
            throw new Exception(
              t('Failed to insert into table @tablename of database @database',
              array('@tablename' => 'mcapi_transactions', '@database' => $connection)
            ));
          }
        }
      }
      catch (Exception $e) {
        foreach ($ts as $db_transaction) $db_transaction->rollback();
        db_set_active();
        throw $e;
      }
    }
    if (!$really) {
      foreach ($ts as $db_transaction) $db_transaction->rollback();
      foreach ($transactions as $id => $transaction) {
        $transactions[$id]->xid = $transaction->temp;
      }
    }
    db_set_active();
  }

  /*
   * there is no error checking on this.
   * $purge is an undocumented feature, for development only, which forces mode MCPI_CURRENCY_UNDO_DELETE
   */
  public function undo($transactions, $mode = FALSE) {
    if (empty($mode)) {
      $mode = variable_get('mcapi_controller_delete_mode', MCPI_CURRENCY_UNDO_REVERSE);
    }
    switch($mode) {
      case MCPI_CURRENCY_UNDO_DELETE: //actually delete
        foreach ($transactions as $transaction) {
          $xids[] = $transaction->xid;
        }
        $query = db_delete("mcapi_transactions")->condition('xid', $xids)->execute();
        break;
      case MCPI_CURRENCY_UNDO_ERASE: //mark deleted
        $this->state($transactions, TRANSACTION_STATE_ERASED);
        break;
      case MCPI_CURRENCY_UNDO_REVERSE:
        foreach($transactions as $transaction) {
          $reversed = clone $transaction;
          $reversed->payer = $transaction->payee;
          $reversed->payee = $transaction->payer;
          $reverseds[] = $reversed;
        }
        transactions_insert($reverseds);
        break;
    }
    return $transaction;
  }
  /*
   * change the state of a transaction and its dependents
   * This does not count as updating it, which is subject to different permissions
   */
  public function state(array $serials, $new_state) {
    db_update('mcapi_transactions')
      ->fields(array('state' => $new_state))
      ->condition('serial', $serials)
      ->execute();
  }

  /*
   * get some stats by adding up the transactions for a given user
   * this is currently used for the limits module and for the views handler per-row
   * caching running balances is dangerous because they would all need recalculating any time a transaction changed state
   * $options can be array(
   *   states => array(TRANSACTION_STATE_FINISHED)
   *   before_xid => 0
   *   after_xid => 0
   *   before_time => 0
   *   after_time => 0
   */
  public function sums($uid, $currcode, $options = array()) {
    $options += array(
      'states' => array(TRANSACTION_STATE_FINISHED),
      'before_xid' => NULL,
      'after_xid' => 0,
      'before_time' => NULL,
      'after_time' => 0
    );
    //this COALESCE is only tested for mysql.
    //when we joing the tables like this, half of all values will be NULL, and NULL values do not add
    //so these NULL values need to be selected as 0 before adding
    //there may well be a more elegant way
    $query = "SELECT
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)), 0) as gross_in,
      COALESCE(SUM(COALESCE(w1.worth_quantity, 0)), 0) as gross_out,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)) - SUM(COALESCE(w1.worth_quantity, 0)), 0) as balance,
      COUNT(t.xid) as count
      FROM {mcapi_transactions} t
      LEFT JOIN {field_data_worth} w1 ON t.xid = w1.entity_id AND w1.worth_currcode = '$currcode' AND t.payer = $uid
      LEFT JOIN {field_data_worth} w2 ON t.xid = w2.entity_id AND w2.worth_currcode = '$currcode' AND t.payee = $uid
      WHERE (t.payer = $uid OR t.payee = $uid)
        AND t.state in (:states)
        AND t.created > :after_time
        AND t.xid > :after_xid";
    if ($options['before_xid'] > 0) {
      $query .= " AND t.xid <= ".$options['before_xid'];
    }
    if ($options['before_time'] > 0) {
      $query .= " AND t.created <= ".$options['before_time'];
    }
    $replacements = array(
      ':states' => implode(',', $options['states']),
      ':after_xid' => $options['after_xid'],
      ':after_time' => $options['after_time']
    );
    return db_query($query, $replacements)->fetchAssoc();
  }

  public function last_insert($type = '') {
    $query = "SELECT MAX(serial) FROM {mcapi_transactions} ";
    $args = array();
    if ($type) {
      $query .= 'WHERE type = :type';
      $args[':type'] = 'type';
    }
    return db_query($query, $args)->fetchfield();
  }
  /*
   * alternative to using views
   * Get a list of transactions for a user, between unixtimes
   * arguments, in any order can be
   * from // unixtime
   * to //unixtime
   * states array, defaults to array(0) which is completed transactions only
   * no pager is provided in this function
   * views is much better
   */
  public function get_period($uid, $variables) {
    $variables += array(
      'from' => 0,
      'to' => REQUEST_TIME + 1,
      'states' => array(TRANSACTION_STATE_FINISHED),
      'currcode' => NULL
    );
    extract($variables);
    db_set_active(variable_get('mcapi_db_read', 'default'));
    $query = db_select('mcapi_transactions', 'x')->fields('x');
    db_set_active();
    $query->condition(db_or()
      ->condition('payer', $uid)
      ->condition('payee', $uid)
    )
    ->condition('state', $states)
    ->condition('created', $from, '>')
    ->condition('created', $to,  '<')
    ->orderby('created');
    if ($currcode) {
      $query->condition('currcode', $currcode);
    }
    return $query->execute()->fetchAll();
  }

  public function delete() {
    
  }
}

/*
 * implements hook_FORM_mcapi_controller_options_form
 * sets a drupal variable mcapi_controller_delete_mode
 */
function mcapi_form_mcapi_controller_options_form_alter(&$form) {
  $form['mcapi_controller_delete_mode'] = array(
    '#title' => t('Undo mode'),
    '#type' => 'radios',
    '#options' => array(
      MCPI_CURRENCY_UNDO_DELETE => t('Wipe slate - remove transactions from database'),
      MCPI_CURRENCY_UNDO_ERASE => t('Scratch - use deleted transaction state'),
      MCPI_CURRENCY_UNDO_REVERSE => t('Reverse - create an equal and opposite transaction'),
    '#default_value' => variable_get('mcapi_controller_delete_mode', MCPI_CURRENCY_UNDO_REVERSE),
    )
  );
}
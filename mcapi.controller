<?php
// $Id:
/*
 * This file is included using the function mcapi_controller();
 * Each function supports the choice of database connections.
 * the class should be named thus:
 * MODULENAME_EntityController
 */
define('MCPI_CURRENCY_UPDATE_NONE', 0);
define('MCPI_CURRENCY_UPDATE_HARD', 2);
define('MCPI_CURRENCY_UPDATE_SOFT', 1);

/*
 * The transaction entity has its own CRUD operations
 */
class mcapi_EntityController extends DrupalDefaultEntityController {
  /*
   * This controller test writes the transaction during validation
   * mostly copied from the node controller
   * need to see what the entity module has to offer
   * no support for revisions
   * returns an error if the transaction id is invalid
   */
  public function load($ids = array(), $conditions = array(), $serial = FALSE) {
    $entities = array();
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;

    //get from cache where available
    if ($this->cache) {
      //$entities += $this->cacheGet($serials, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }

    if ($ids === FALSE || $ids || ($conditions && !$passed_ids)) {
      db_set_active(variable_get('mcapi_db_read', 'default'));
      $query = db_select('mcapi_transactions');
      db_set_active();
      $query->fields('mcapi_transactions', $this->entityInfo['schema_fields_sql']['base table']);
      // Build the query.
      if ($ids) {
        $key = $serial ? 'serial' : 'xid';
        $query->condition("mcapi_transactions.$key", $ids, 'IN');
      }
      foreach ($conditions as $field => $value) {
        $query->condition('mcapi_transactions.' . $field, $value);
      }
      $query->orderBy('created', 'ASC');
      $queried_entities = $query->execute()->fetchAllAssoc($this->idKey);
      //extract the serialized data into 'extra' property
      //there isn't acutally a use for the extra property at the moment.
      foreach ($queried_entities as $key => $entity) {
        $queried_entities[$key]->extra = unserialize($queried_entities[$key]->data);
        unset($queried_entities[$key]->data);
      }
    }

    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities);
      $entities += $queried_entities;
    }
    if ($this->cache) {
      if (!empty($queried_entities)) {
        $this->cacheSet($queried_entities);
      }
    }
    return $entities;
  }
  
  public function validate($transaction){
    $xid = $transaction->xid;
    try {  //should really validate every transaction entity property
      foreach ($transaction->worth['und'] as $worth) {
        if (!is_numeric($worth['quantity'])) {
          throw new Exception(t('Illegal quantity: @val', array('@val' => print_r($worth, 1))));
        }
      }
      $t = db_transaction();
      $this->save($transaction);
    }
    catch (Exception $e){
      //if the validation fails at this stage when everything should be validated
      //we should put it in watchdog because it means some form somewhere needs tightening up
      //unfortunately at this point we don't know what form it is.
      $transaction->extra['error'] = $e->getMessage();
      watchdog('mcapi', '@message', array('@message' => $e->getMessage()), WATCHDOG_ALERT);
      throw $e;
    }
    $t->rollback();
    $transaction->xid = $xid;
    return $transaction;
  }

  /*
   * update or insert the saved transaction according to whether xid is set
   * expects a single, validated transaction object
   */
  public function save($transaction) {
    //this is only used to fix what I think is a Drupal bug, see mcapi_field_attach_presave
    //removes the 'add more' item from fields with infinite cardinality
    $instances = array();
    $instances = _field_invoke_get_instances('transaction', 'transaction', array('deleted' => FALSE));
    foreach($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == -1 && isset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more'])) {
        unset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more']);
      }
    }//end of bugfix
    
    $transaction->modified = REQUEST_TIME;
    $transaction->modifier = $GLOBALS['user']->uid;
    reset($transaction->worth);
    $t = db_transaction();
    //the transaction is actually inserted during the validation phase, after validation the state should be changed
    $function = empty($transaction->xid) ? 'insert' : 'update';
    try {
      $this->$function($transaction);
    }
    catch (Exception $e) {
      $t->rollback();
      watchdog_exception('mcapi', $e);
      throw $e;
    }
    return $transaction;
  }

  /*
   * merely set the state of the exchange, not delete the row
   * there is no error checking on this.
   */
  public function erase($transaction) {
    //if there are more than one flows involved, use the minimum value for the update mode
    $flows = current($transaction->worth);
    $modes = array(2);
    foreach ($flows as $flow) {
      $modes[$flow['currcode']] = currency_load($flow['currcode'])->accounting['erase_mode'];
    }
    switch(min($modes)) {
      case 1: //mark deleted
        $transaction->state = TRANSACTION_STATE_ERASED;
        $transaction->modified = REQUEST_TIME;
        $transaction->modifier = $GLOBALS['user']->uid;
        $this->state($transaction);
        break;
      case 2: //actually delete
        $query = db_query("DELETE FROM {mcapi_transactions} WHERE xid = :xid", array(':xid' => $transaction->xid));
        break;
      default:
        $currcode = array_search(min($modes), $modes);
        throw new Exception(t('Currency @name does not allow deletion', array('@name' => currency_load($currcode)->human_name)));
        break;
    }
    return $transaction;
  }
  /*
   * change the state of a transaction.
   * This does not count as updating it, which is subject to different permissions
   */
  public function state($transaction) {
    db_query("UPDATE {mcapi_transactions} SET state = :state WHERE xid = :xid", array(':state' => $transaction->state, ':xid' => $transaction->xid));
  }

  /*
   * get_balance
   * this is currently used for the limits module and for the views handler per-row
   * caching running balances is dangerous because they would all need recalculating any time a transaction changed state
   * $options can be array(
   *   states => array(TRANSACTION_STATE_FINISHED)
   *   before_xid => 0
   *   after_xid => 0
   *   before_time => 0
   *   after_time => 0
   */
  public function sums($uid, $currcode, $options = array()) {
    $options += array(
      'states' => array(TRANSACTION_STATE_FINISHED),
      'before_xid' => NULL,
      'after_xid' => 0,
      'before_time' => NULL,
      'after_time' => 0
    );
    //this COALESCE is only tested for mysql.
    //when we joing the tables like this, half of all values will be NULL, and NULL values do not add
    //so these NULL values need to be selected as 0 before adding
    //there may well be a more elegant way
    $query = "SELECT
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)), 0) as gross_in,
      COALESCE(SUM(COALESCE(w1.worth_quantity, 0)), 0) as gross_out,
      COALESCE(SUM(COALESCE(w2.worth_quantity, 0)) - SUM(COALESCE(w1.worth_quantity, 0)), 0) as balance,
      COUNT(t.xid) as count
      FROM {mcapi_transactions} t
      LEFT JOIN {field_data_worth} w1 ON t.xid = w1.entity_id AND w1.worth_currcode = '$currcode' AND t.payer = $uid
      LEFT JOIN {field_data_worth} w2 ON t.xid = w2.entity_id AND w2.worth_currcode = '$currcode' AND t.payee = $uid
      WHERE (t.payer = $uid OR t.payee = $uid)
        AND t.state in (:states)
        AND t.created > :after_time
        AND t.xid > :after_xid";
    if ($options['before_xid'] > 0) {
      $query .= " AND t.xid <= ".$options['before_xid'];
    }
    if ($options['before_time'] > 0) {
      $query .= " AND t.created <= ".$options['before_time'];
    }
    $replacements = array(
      ':states' => implode(',', $options['states']),
      ':after_xid' => $options['after_xid'],
      ':after_time' => $options['after_time']
    );
    return db_query($query, $replacements)->fetchAssoc();
  }

  public function last_insert($type = '') {
    $query = "SELECT MAX(serial) FROM {mcapi_transactions} ";
    $args = array();
    if ($type) {
      $query .= 'WHERE type = :type';
      $args[':type'] = 'type';
    }
    return db_query($query, $args)->fetchfield();
  }
  /*
   * alternative to using views
   * Get a list of transactions for a user, between unixtimes
   * arguments, in any order can be
   * from // unixtime
   * to //unixtime
   * states array, defaults to array(0) which is completed transactions only
   * no pager is provided in this function
   * views is much better
   */
  public function get_period($uid, $variables) {
    $variables += array(
      'from' => 0,
      'to' => REQUEST_TIME + 1,
      'states' => array(TRANSACTION_STATE_FINISHED),
      'currcode' => NULL
    );
    extract($variables);
    db_set_active(variable_get('mcapi_db_read', 'default'));
    $query = db_select('mcapi_transactions', 'x')->fields('x');
    db_set_active();
    $query->condition(db_or()
      ->condition('payer', $uid)
      ->condition('payee', $uid)
    )
    ->condition('state', $states)
    ->condition('created', $from, '>')
    ->condition('created', $to,  '<')
    ->orderby('created');
    if ($currcode) {
      $query->condition('currcode', $currcode);
    }
    return $query->execute()->fetchAll();
  }
  

  /*
   * create a transaction, either the first moment at validation
   */
  function insert($transaction) {
    $transaction->creator = $GLOBALS['user']->uid;
    $transaction->created = REQUEST_TIME;
    $serial = mcapi_next_serial($transaction);
    $transaction->serial = $serial ? $serial : db_query("SELECT MAX(serial) FROM {mcapi_transactions}")->fetchField() + 1;
    
    mcapi_write_record($transaction);
  }

  /*
   * This controller makes no use of the entity revision control facility
   * $force_update is for the special case of a validated transaction which is being written
   */
  function update($transaction) {
    //if there are more than one flows involved, use the minimum value for the update mode
    $flows = current($transaction->worth);
    foreach ($flows as $flow) {
      $currency = currency_load($flow['currcode']);
      $modes[] = $currency->accounting['update_mode'];
    }
    switch(min($modes)) {//choose the most rigourous accounting standard
      case MCPI_CURRENCY_UPDATE_HARD:
        $old = clone(transaction_load($transaction->xid));
        $transaction->extra['former_xid'] = $transaction->xid;
        //remove the xid and insert the transaction anew
        unset($transaction->xid);
        $this->insert($transaction); //will give a new xid
        $old->extra['became_xid'] = $transaction->xid;
        //then erase the old one
        $this->erase($old);
        break;
      case MCPI_CURRENCY_UPDATE_SOFT:
        try {
          mcapi_write_record($transaction, array('xid'));
        }
        catch (Exception $e) {
          //getting an error: Cannot access protected property Exception::$message
          $e->getMessage .= ' '. t('Database failed to update transaction record.');
          throw $e;
        }
        field_attach_update('transaction', $transaction);
        break;
      //safe default
      case MCPI_CURRENCY_UPDATE_NONE:
      default:
        throw new Exception(t('This currency does not allow transaction updates.'));
    }
  }
}


/*
 * wrapper for drupal_write_record
 * writes to the database(s) specified by the entity controller settings
 */
function mcapi_write_record(&$record, $primary_keys = array()) {
  $record->data = (isset($record->extra)) ? $record->extra : array();
  //we need to ensure the schema is cached before calling mcapi_write_record
  //Otherwise it may try to retrieve the schema from the wrong database
  drupal_get_schema('mcapi');
  foreach (variable_get('mcapi_db_write', array('default')) as $connection) {
    db_set_active($connection);
    try{
      $ts[] = db_transaction();
      if(!drupal_write_record('mcapi_transactions', $record, $primary_keys)) {
        throw new Exception();
      }
    }
    catch (Exception $e) {
      foreach ($ts as $db_transaction) {
        $db_transaction->rollback();
      }
      db_set_active();
      $keys = array();
      foreach ($primary_keys as $keyname) {
        $keys[$keyname] = $record->$keyname;
      }
      $keys = implode(',', $keys);
      $newmessage = t("Failed to write to table 'mcapi_transactions' on database '@database', using keys: @keys",
        array(
          '@database' => $connection,
          '@keys' => '<pre>'.print_r($primary_keys, 1).'</pre>'
        )
      );
      $replacements = array('@tablename' => 'mcapi_transactions', '@keys' => $keys, '@database' => $connection);
      if ($keys) {
        watchdog('Failed to update table @tablename of database @database using keys: @keys', $replacements, WATCHDOG_CRITICAL);
        throw new Exception(t('Failed to update table @tablename of database @database using keys: @keys', $replacements));
      }
      else {
        watchdog('Failed to insert into table @tablename of database @database', $replacements, WATCHDOG_CRITICAL);
        throw new Exception(t('Failed to insert into table @tablename of database @database', $replacements));
      }
    }
  }
  db_set_active();
}

/*
 * implements hook_form_FORM_ID_alter
 * Adds the accounting standards to the currency form
 */
function mcapi_form_ctools_export_ui_edit_item_form_alter(&$form, &$form_state) {
  if (empty($form_state['plugin']['handler']) || $form_state['plugin']['handler'] != 'mcapi_ui') return;
  $currency = isset($form_state['values']) ? (object)$form_state['values'] : $form_state['item']->data;
  $form['accounting'] = array(
    '#title' => t('Accounting standards'),
    '#description' => t('More or less formal accounting standards can be determined.') .' '.
      t('Not all combinations are meaningful!') .' '.
      t('Transactions with multiple cardinality will go with the most conservative meaning'),
    '#type' => 'fieldset',
    '#weight' => -1,
    '#group' => 'additional_settings',
    'update_mode' => array(
      '#title' => t('Update mode'),
      '#type' => 'radios',
      '#options' => array(
        MCPI_CURRENCY_UPDATE_NONE => t("Can't update"),
        MCPI_CURRENCY_UPDATE_HARD => t("Delete and create a new transaction"),
        MCPI_CURRENCY_UPDATE_SOFT => t("Update same record"),
        //3 => t("Use entity versioning the same transaction (not available)"),
      ),
      '#default_value' => isset($currency->accounting['update_mode']) ? $currency->accounting['update_mode'] : MCPI_CURRENCY_UPDATE_SOFT,
      '#weight' => 1,
      '#element_validate' => array('mcapi_currency_validate_update_mode'),
      //TODO: THESE AJAX CALLS ARE ONLY WORKING THE FIRST TIME BECAUSE THE FORM ID IS BEING INCREMENTD EACH TIME
      '#ajax' => array(
        'callback' => 'currency_form_ajax',
        'wrapper' => 'mcapi-currency-form',
      ),
    ),
    'erase_mode' => array(
      '#title' => t('Delete mode'),
      '#type' => 'radios',
      '#options' => array(
        0 => t("Can't delete"),
        1 => t('Mark deleted'),
        2 => t('Remove all traces from the database (not from backups)'),
      ),
      '#default_value' => isset($currency->accounting['erase_mode']) ? $currency->accounting['erase_mode'] : 1,
      '#weight' => 2,
      '#ajax' => array(
        'callback' => 'currency_form_ajax',
        'wrapper' => 'mcapi-currency-form',
      ),
    )
  );

  $operations = array('update' => t('Correct'), 'erase' => t('Erase'));
  $form += currency_op_settings_tab($currency, $operations);
  
  //alter the options according to what is set
  if ($form['accounting']['erase_mode']['#default_value'] == 0) {
    unset($form['accounting']['update_mode']['#options'][1]);
    if ($form['accounting']['update_mode']['#default_value'] == 1) {
      $form['accounting']['update_mode']['#default_value'] = 0;
    }
  }
  //nasty design flaw around radio buttons which means ajax rebuilds them wrong
  if (arg(0) == 'system') {
    unset($form['accounting']['update_mode']['#title']);
  }

}

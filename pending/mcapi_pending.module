<?php
// $Id:

define ('TRANSACTION_STATE_PENDING', 1);


/*
 * Introduces a new transaction state, 'pending', and
 * modifies existing default transaction forms to create pending transactions
 * Pending transactions require at least one signature
 * Required signatures are stored in a db table and marked 'signed'
 * Signatures happen via menu callbacks
 * Its possible both to sign a transaction 'off' thus 'finishing' it
 * Also to sign all a user's transactions.
 * Note that the mcapi_forms module can not deal with signatures of non-transactors, nor can the mail processor, but this module can
 */
function mcapi_pending_menu() {
  //this item makes it possible to sign on someone elses behalf, if the link is provided.
  //That's not in the scope of this module

  $items['transaction/%transaction/signoff'] = array(
    'title' => 'Sign off transaction',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signoff_confirm_form', 1),
    'access callback' => 'mcapi_pending_signoff_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
  );
  $items['transactions/signall/%user_uid_optional'] = array(
    'title' => 'Sign all my transactions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mcapi_signall_confirm_form', 1),
    'access callback' => 'has_pending',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  mcapi_check_integrity();
  return $items;
}

function mcapi_pending_menu_alter(&$items) {
  //this menu item is generated from the transaction form-in-code
  //it can ONLY be seen by signatories
  $new = array(
    'access callback' => 'mcapi_pending_signatories_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
  );
  $items['transaction/%transaction/sign'] = $new + $items['transaction/%transaction/sign'];
}

function has_pending($account) {
  if (db_query("SELECT count(xid) FROM {mcapi_signatures} where uid = :uid AND pending = 1", array(':uid' => $account->uid))->fetchfield()) {
    return $account->uid == $GLOBALS['user']->uid || user_access('manage all transactions');
  }
}
//menu access callback
//returns true if the user is a listed signatory and hasn't signed
function mcapi_pending_signatories_access($transaction) {
  //check the transaction is pending and the given account needs to sign it.
  if ($transaction->state != TRANSACTION_STATE_PENDING) return FALSE;
  //checking (just for development)
  if (!count(array_filter($transaction->pending_signatures))) {
    drupal_set_message('no signatories');
  }
  //check the user is listed as a signatory
  if (!empty($transaction->pending_signatures[$GLOBALS['user']->uid])) return TRUE;
}

//menu access callback
//can the current user sign off the given transaction
function mcapi_pending_signoff_access($transaction) {
  if ($transaction->state == TRANSACTION_STATE_PENDING) {
    if (user_access('manage all transactions')) return TRUE;
  }
}


/*
 * Implements hook_mcapi_info_states
 */
function mcapi_pending_mcapi_info_states() {
  return array(
    //must be defined with lower case
    TRANSACTION_STATE_PENDING => t('pending'),
  );
}

/*
 * Will implement hook_entity_load or some such
 */
function mcapi_pending_entity_load(&$entities, $type) {
  if ($type != 'transaction')return;
  //as we put the signatures into the transaction objects, we check that each transaction is pending
  foreach ($entities as $transaction) {
    $xid = &$transaction->xid;
    $entities[$xid]->pending_signatures = mcapi_get_signatories($xid);
  }
}

/*
 * implements hook_entity_update
 * calculates the pending balances and saves the required signatures
 */
function mcapi_pending_entity_update($transaction, $type) {
  if ($type == 'transaction') {
    //resave the signatures to the entity table
    mcapi_pending_entity_save($transaction);
  }
}
/*
 * implements hook_entity_insert
 */
function mcapi_pending_entity_insert($transaction, $type) {
  if ($type != 'transaction' || $transaction->state != TRANSACTION_STATE_PENDING) return;
  $transaction->pending_signatures = array();
  //load the mcapi_form to check if this transaction has any signatories
  //this is where we actually add the signatures to the transaction object
  if (module_exists('mcapi_forms')) {
    $mcapi_form = mcapi_forms_load($transaction->type);
    if ($mcapi_form->data['perspective'] == 1) {
    foreach (array('1stperson', '2ndperson') as $participant) {
        $uid = $transaction->payee == $GLOBALS['user']->uid ? $transaction->payer : $transaction->payee;
        $transaction->pending_signatures[$uid] = 1;
      }
    }
    elseif ($mcapi_form->data['perspective'] == 3) {
      foreach (array('payer', 'payee') as $participant) {
        $transaction->pending_signatures[$transaction->$participant] = 1;
      }
    }
  }
  else {
    //make pending for any user who isn't the current user
    foreach (array('payer', 'payee') as $participant) {
      if ($transaction->$participant != $GLOBALS['user']->uid) {
        $transaction->pending_signatures[$transaction->$participant] = 1;
      }
    }
  }
  //resave the signatures to the entity table
  mcapi_pending_entity_save($transaction);
}


function mcapi_pending_entity_save($transaction) {
  $rows = array();
  foreach ($transaction->pending_signatures as $uid => $pending) {
    db_merge('mcapi_signatures')->key(array(
      'xid' => $transaction->xid,
      'uid' => $uid
    ))->fields(array(
      'pending' => $pending
    ))->execute();
  }
}

/*
 * Will implement hook_entity_delete or some such
 */
function mcapi_pending_entity_delete($entity, $type) {
  if ($type = 'transaction' && !empty($entity->pending_signatures)) {
    db_query("DELETE FROM {mcapi_signatures} WHERE xid = ".$transaction->xid);
  }
}

/*
 * removes one signatory from the transaction object and resaves the transaction
 */
function mcapi_sign($transaction, $uid) {
  if ($transaction->pending_signatures[$uid] == 1) {
    $transaction->pending_signatures[$uid] = 0;
    $remaining = array_filter($transaction->pending_signatures);
    if (empty($remaining)) {
      $transaction->state = TRANSACTION_STATE_FINISHED;
      transaction_state($transaction, $transaction->state);
      drupal_set_message(t("Transaction #@xid is signed off.", array('@xid' => $transaction->xid)));
    }
    else {
      drupal_set_message(t("@num signatures remaining on transaction #@xid", array('@num' => count($remaining), '@xid' => $transaction->xid)));
    }
  }
  else {
    drupal_set_message(t('Transaction #@xid is already signed'), array('@xid' => $transaction->xid));
  }
}

/*
 * Implements hook_views_api
 */
function mcapi_pending_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending'),
  );
}

/*
 * Implements ctools hook_ctools_plugin_api
 * not sure if this is needed
 */
function mcapi_pending_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_pending'),
  );
}

//returns a list of the user objects who are yet to sign
//will take either an xid or a uid, returns a list of the other
function mcapi_get_signatories($xid = NULL, $uid = NULL) {
  if ($xid && $uid) {
    drupal_set_message('Bad arguments to mcapi_get_signatories', 'error');
    return;
  }
  $signatures = array();
  $query = db_select('mcapi_signatures', 's')->fields('s');
  if ($xid) {
    $results = $query->condition('xid', $xid)->execute()->fetchAll();
    foreach($results as $signature) {
      $signatures[$signature->uid] = $signature->pending;
    }
  }
  else {
    $results = $query->condition('uid', $uid)->execute()->fetchAll();
    foreach($results as $signature) {
      $signatures[$signature->xid] = $signature->pending;
    }
  }
  return $signatures;
}


/*
 * Bit of a one off, this one
 */
function mcapi_format_usernames($accounts) {
  foreach($accounts as $account) {
    $names[] = format_username($account);
  }
  $output = implode(' & ' ,$names);
  return $output;
}


/*
 * implements hook_form_FORMID_alter
 * bumps the signature form up to stage 2, where the fields are rendered as text
 */
function mcapi_pending_form_mcapi_forms_form_alter(&$form, &$form_state) {
  if ($form_state['build_info']['args'][0]->name != 'add_my_signature') return;
  $form_state['step']++;

  array_unshift($form['#submit'], 'add_my_signature_submit');
  unset($form['buttons']['delete']);
}


function add_my_signature_submit($form, &$form_state) {
  //remove the signatory from the transaction
  debug($form_state['transaction']);
  if ($form_state['transaction']->state = TRANSACTION_STATE_PENDING) {
    mcapi_sign($form_state['transaction'], $GLOBALS['user']->uid);
  }
}


/*
 * This menu callback is handled differently to the standard signing form
 */
function mcapi_signoff_confirm_form($form, $form_state, $transaction) {
  mcapi_hide_tabs();
  $xid = &$transaction->xid;
  $form = array();
  $form_state['redirect'] = 'transaction/'. $xid;
  $form['xid'] = array(
    '#type' => 'hidden',
    '#value' => $xid
  );
  $signatories = array_filter(mcapi_get_signatories($xid));
  $users = user_load_multiple(array_keys($signatories));
  $form['#prefix'] = t('Are you sure you want to sign this transaction on behalf of @users?',
    array('@users' => mcapi_format_usernames($users))
  );
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signoff_confirm_form_submit($form, &$form_state) {
  $xid = &$form_state['values']['xid'];
  $signatories = array_filter(mcapi_get_signatories($xid));
  foreach (array_keys($signatories) as $uid) {
    mcapi_sign(transaction_load($xid), $uid);
  }
  drupal_set_message(t("Transaction #@xid is signed off.", array('@xid' => $xid)));
  $form_state['redirect'] = 'transaction/'. $xid;
}

function mcapi_signall_confirm_form($form, $form_state, $account) {
  $form = array();
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $account->uid
  );
  $form['#prefix'] = t('Are you sure you want to sign all your transactions?');
  return confirm_form(
    $form,
    t('Are you sure?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mcapi_signall_confirm_form_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  //get all the transactions
  $transactions = transaction_controller('load', mcapi_get_signatories(NULL, $uid));
  //sign them one by one
  foreach ($transactions as $transaction) {
    mcapi_sign($transaction, $uid);
  }
  $form_state['redirect'] = 'user';
}


/*
 * Integration with mcapi_forms module
 *
 * Implements hook_form_FORM_ID_alter
 * modifies its own form to hide exceptional fields
 * adds ajax to the state selector
 * then if the state is set to pending, this inserts the checkboxes to require signatures in transaction forms
 *
 */
function mcapi_pending_form_ctools_export_ui_edit_item_form_alter(&$form, &$form_state) {
  //check that this is actually a transaction form
  if ($form_state['plugin']['schema'] != 'mcapi_forms') return;
  //add the checbox to each participant field to say whether their signature is required
  $form['workflow']['outgoing']['#ajax'] = array(
    'callback' => 'mcapi_forms_ajax_settings',
    'wrapper' => 'form-wrapper'
  );
  //disable the path field for the pending form
  if ($form['architecture']['path']['#default_value'] == 'transaction/%transaction/sign') {
    $form['architecture']['path']['#disabled'] = TRUE;
    //disable the fields that would change the meaning of the form.
    $form['workflow']['outgoing']['#type'] = 'hidden';
    $form['workflow']['incoming']['#disabled'] = TRUE;
  }
}

/*
 * implements hook_block_info_alter
 * adjusts the blocks declared by the default view
 */
function mcapi_pending_block_info_alter(&$blocks) {
  //because this view requires an argument which probably comes from the url
  $blocks['views']['signatures-user_pending']['visibility'] = 1;
  $blocks['views']['signatures-user_pending']['pages'] = 'user*';
}

function mcapi_check_integrity() {
  $xids = db_query("SELECT t.xid FROM {mcapi_transactions} t LEFT JOIN {mcapi_signatures} s ON t.xid = s.xid WHERE s.pending = 1 AND t.state = 0")->fetchCol();
  if (count($xids)){
    drupal_set_message('Some completed transactions still have signatures pending, please report to matslats: '. implode(', ', $xids), 'warning');
  }

  $xids = db_query("SELECT s.xid FROM {mcapi_transactions} t RIGHT JOIN {mcapi_signatures} s ON t.xid = s.xid WHERE s.pending = 0 AND t.state = 1")->fetchCol();
  if (count($xids)) {
    drupal_set_message('Some pending transactions have no signatures pending, please report to matslats: '. implode(', ', $xids), 'warning');
  }
}


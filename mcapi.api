<?php
// $Id$

/*
 * API functions for mutual_credit 
 */
 
 

/*
 * Create an exchange
 * It enables other modules to create exchanges by passing in the properties
 * these other modules have to do most of their own integrity checking though.
 * This calls mcapi validate for minimal validation but you will want to do more validation using your form
 * Any unknown $options will be packed in a serialized array for storage,
 * and appear as normal node properties outside the db
 */
function mc_api_add_node($payer_uid, $payee_uid, $quantity, $options = array()) {
  global $user;
  //although mcapi.module allows it, this version of the API will not allow zero value transactions
  if (!$quantity) {
    drupal_set_message(t('Cannot create a zero value exchange'));
    return;
  }
  if (!isset($options['title'])) {
    $title = format_date(time(), 'short') . t('No details given');
  }
  $node = $options + array(
    'payee_uid' => $payee_uid,
    'payer_uid' => $payer_uid,
    'quantity' => $quantity,
   //default $options
    'cid' => array_pop(array_keys(currencies_load())), //shouldn't really be omitted
    'title' => t('no description given'),  //shouldn't really be omitted
    'state' => EXCHANGE_STATE_FINISHED, //shouldn't really be omitted
    'exchange_type' => 'api unspecified', //shouldn't really be omitted
    'uid' => $user->uid,
    'created' => time(),
    'data' => array(),
    //rating will take NULL, not 0 if not specified
   //essential node property
    'type' => 'exchange',
  );
  $node=(object)$node;
  mcapi_validate($node);
  if (!drupal_get_messages('error', FALSE)){
    node_save($node);
  }
  print_r($node);
  $result = new stdClass();
  if ($node->nid) {
    $result->success = TRUE;
    $result->exchange = $node;
    if ($notifications = drupal_get_messages('status')) {
      $result->status = $notifications;
    }
  }
  else{
    $mail = array(
      'to' => db_result(db_query("SELECT mail FROM {users} WHERE uid = 1")),
      'subject' => t('Transaction failed on @site', array('@site' => variable_get('site_name', 'no_site'))),
      'body' => print_r($node, 1),
      'headers' => array('From' => variable_get('site_mail', '')),
    );
    $errors = drupal_get_messages('error');
    $result->errors = array_merge(
      array(t('Failed to create exchange. Details have been forwarded to the site administrator')),
      $errors['error']
    );
  }
  if ($warnings = drupal_get_messages('warning')) {
    $result->warnings = $warnings;
  }
  if (isset($mail)) drupal_mail_send($mail);
  return $result;
}

/*
 * Create several exchanges, implementing a hook before and after
 * how to use this exactly depends on the creator.
 * $exchanges is an array of arrays of args for mc_api_add_node
 */

function mc_api_add_nodes($exchanges) {
  drupal_alter('exchanges', $exchanges);
  foreach ($exchanges as $exchange) {
    $results = mc_api_add_node($exchange['payer_uid'], $exchange['payee_uid'], $exchange['quantity'], $exchange['options']);
  }
  //note that this hook cannot alter the exchanges
  module_invoke_all('after_add_exchanges', $exchanges);
  return $results;
}

/*
 * limit checker
 * checks an account to see if the proposed difference will violate the balance limits
 */
function mc_api_check_user_limits($account, $difference, $cid) {
  module_load_include('inc', 'mcapi');
  $limits = user_limits($account, $cid);
  $balances = db_result(db_query("SELECT cleared_balance, pending_dif FROM {mc_cache} WHERE uid = %d and cid = %d", array(':uid' => $account->uid, ':cid' => $cid)));
  $balance = $balances['cleared_balance'];
  if (variable_get('mc_count_pending', TRUE)) {
    $balance += $balances['pending_dif'];
  }
  $projected_total = $balance + $difference;

  $messages = array();
  if ((float) $difference > 0) {
    $surplus = $projected_total - $limits['max'];
    if ($surplus > 0) {
      $message = t('Exchange takes @username !quant above the maximum balance of !max',
        array(
          '@username' => strip_tags(theme('username', $account)),
          '!quant' => theme('money', $surplus, $cid),
          '!max' => theme('money', $limits['max'], $cid)
        )
      );
    }
  }
  else {
    $deficit = $limits['min'] - $projected_total;
    if ($deficit > 0) {
      $message = t('Exchange takes @username !quant below the minimum balance of !min',
        array(
          '@username' => strip_tags(theme('username', $account)),
          '!quant' => theme('money', $deficit, $cid),
          '!min' => theme('money', $limits['min'], $cid)
        )
      );
    }
  }
  if (isset($message)) {
    return $message;
  }
}


//returns all the cached balances for one user, in an array using currency ids as keys
function mc_balances($account) {
  //get all the currency rows for the given member
  $result = db_query(
    "SELECT cid, cleared_balance, pending_dif, gross_in, gross_out, rating, count
      FROM {mc_cache}
      WHERE uid = %d",
    array(':uid' => $account->uid)
  );
  module_load_include('inc', 'mcapi');
  $limits = user_limits($account);

  while ($data = db_fetch_array($result)) {
    $cid = array_shift($data);
    $set = $data;
    $set += $limits[$cid];

    $use_balance = $data['cleared_balance'];
    if ('mc_count_pending') {
      $use_balance += $data['pending_dif'];
    }
    $set['max_in'] = $set['max'] - $use_balance;
    $set['max_out'] = $set['min'] - $use_balance;
    $balances[$cid] = $set;
  }
  return $balances;
}

/*
 * Provides a list of exchanges in a way that views cannot, and more efficiently.
 * This is not yet possible with views, because you can't do WHERE payer_uid = x OR payee_uid = x
 *
 * Options are (showing defaults) array(
 *   'to' => unixtime
 *   'from' => unixtime
 *   'direction' => enum(both, in, out)
 *   'pager_limit' => integer
 *   'order' = ASC or DESC
 *   'cids' = array
 *   'states' = array()
 *   )
 * Main purpose of this function is to filter the list which is cached already.
 */
function mc_api_user_exchanges($uid, $options) {
  $options += array(
    'to' => time(),
    'from' => 0,
    'direction' => 'both',
    'pager_limit' => 25,
    'order_by' => 'DESC',
    'cids' => currencies_load(),
    'states' => array(EXCHANGE_STATE_FINISHED, EXCHANGE_STATE_PENDING),
  );

  $all_exchanges = array();
  foreach ($options['cids'] as $cid) {
    //this recalls the whole exchange history, with running balances, in descending order of time
    //to keep the memory footprint down, retrieve one currency at a time
    //(if we don't do this, we'll have to store the cid in the serialized exchange)
    $one_curr = db_result(db_query("SELECT exchanges FROM {mc_cache} WHERE uid = %d AND cid = %d", array(':uid' => $uid, ':cids' => $cid)));

    //IMPORTANT to do the paging as soon as possible, as its the biggest filter
    $exchanges = unserialize($one_curr);
    if (!count($exchanges)) continue;

    foreach ($exchanges as $exchange) {
      if (!mcapi_access('view', $exchange, $GLOBALS['user'])) continue;
      if (!in_array($exchange->state, $options['states'])) continue;
      if ($exchange->created > $options['to'] || $exchange->created < $options['from']) continue;
      $exchange->cid = $cid;
      $filtered[] = $exchange;
    }
  }

  if ($options['order'] == 'ASC') {
    $filtered = array_reverse($filtered);
  }
  return $filtered;
}

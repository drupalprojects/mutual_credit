<?php
//$Id
define ('GOOGLE_CHARTS_URI', 'http://chart.apis.google.com/chart?');
define('TRANSACTIONS_PAGER_ELEMENT', 1);


function mcapi_views_entity_insert($type, $entity) {
  if ($type == 'transaction') mcapi_update_index($entity);
  //then we'll need to recalc the running balances of everything after that
}
function mcapi_views_entity_update($type, $entity) {
  if ($type == 'transaction') mcapi_update_index($entity, $entity->xid);
  //then we'll need to recalc the running balances of everything after that
}

function mcapi_views_entity_delete($type, $entity) {
  if ($type == 'transaction') {
    db_query("DELETE FROM {mcapi_index} WHERE xid = :xid", array(':xid' => $entity->xid));
  }
  //then we'll need to recalc the running balances of everything after that
}

/*
 * To reduce the number of permutations of data which could be cached,
 * Cacheing is done at the display level
 * This function merely clears those caches
 */
function mcapi_update_index($transaction, $xid = NULL) {
  if ($transaction->state == TRANSACTION_STATE_FINISHED) {
    $balance_query = "SELECT SUM(diff) FROM {mcapi_index} WHERE uid1 = :uid AND cid = $transaction->cid AND xid <= $transaction->xid";

    db_merge('mcapi_index')
    ->key(array('xid' =>$transaction->xid, 'uid1' => $transaction->payee))
    ->fields(array(
      'uid2' => $transaction->payer,
      'created' => $transaction->created,
      'cid' => $transaction->cid,
      'expenditure' => $transaction->quantity,
      'volume' => $transaction->quantity,
      'diff' => -$transaction->quantity,
      'balance' => db_query($balance_query, array(':uid' => $transaction->payee))->fetchfield(),
    ))->execute();
    db_merge('mcapi_index')
    ->key(array('xid' =>$transaction->xid, 'uid1' => $transaction->payer))
    ->fields(array(
      'uid2' => $transaction->payee,
      'created' => $transaction->created,
      'cid' => $transaction->cid,
      'income' => $transaction->quantity,
      'volume' => $transaction->quantity,
      'diff' => $transaction->quantity,
      'balance' => db_query($balance_query, array(':uid' => $transaction->payer))->fetchfield(),
    ))->execute();
  }
  else {
    //only completed transactions are indexed
    mcapi_views_entity_delete('transaction', $transaction);
  }
}


/**
 * http://api.drupal.org/api/function/hook_theme/6
 * This hook is required for modules to define one or more node types.
 */
function mcapi_views_theme($existing, $type, $theme, $path) {
  $path .='/theme';
  return array(
    'views_view_field__cid' => array(
      'variables' => array(
        'view' => NULL,
        'field' => NULL,
        'row' => NULL,
      )
    ),
    'balance_history' => array(
      'template' => 'balance_history',
      'path' => $path,
      'variables' => array(
        'histories' => array(),
        'extent' => NULL,
        'legend' => ''
      )
    ),
  );
}

//$extent can be 'limits' or 'balance'
function show_balance_history($account, $cids, $extent = 'limits', $since = 0) {
  $histories = array();
  foreach($cids as $cid) {
    $hist = get_balance_history($account, $cid, $since);
    if (count($hist)) {
      $histories[$cid] = $hist;
    }
  }
  return theme('balance_history', array('histories' => $histories));
}

/*
 * implements hook_form_alter
 * renames the exposed filters on views forms
 */
function mcapi_views_form_alter($form, $form_state, $form_id) {
  if ($form_id == 'views_exposed_form') {
    $description = t('Comma separated usernames');
    $form['payee']['#description'] = $description;
    $form['payer']['#description'] = $description;
  }
}

/*
 * Implements views hook_views_api
 */
function mcapi_views_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi_views') .'/views',
  );
}

/*
 * implements hook_query_TAG_alter
 * the saved view adds the tag 'transaction_access'
 * this modifies the query only to show the transactions visible to the user.
 * in practice, this means filtering by currency firstly
 * but currencies with view control based on who traded is more complicated
 */
function _mcapi_views_query_transaction_access_alter(&$query) {
  $uid = $GLOBALS['user']->uid;
  //what currencies can the current user see?
  $currencies = currency_choose('view', $uid);
  $eachcurrency = db_or();
  foreach ($currencies as $currency) {
    switch ($currency->extra['privacy']) {
      case 1: //show only transactions in currencies that authenticated user can see
        if (!$GLOBALS['user']->uid) continue;
        //if you are logged in, then its the same as if there were no restrictions
      case 0: //in effect, no restrictions
        $eachcurrency->condition('cid', $currency->cid);
        break;
      case 2: //show only transactions in currencies where I have a cached balance
        $cached = transaction_controller('get_cache', $uid);
        if (isset($cached[$currency->cid]) || user_access('manage all transactions')) {
          $eachcurrency->condition('cid', $currency->cid);
        }
        break;
      case 3: //participants, creator, accountant and user 1
        if (!user_access('manage all transactions')) continue;
        //and if you do have permission, then that's like privacy being 4, for this currency.
      case 4: //only participants
        $eachcurrency->condition(db_and()
          ->condition('cid', $currency->cid)
          ->condition(db_or()
            ->condition('payer', $uid)
            ->condition('payee', $uid)
            ->condition('creator', $uid)
          )
        );
    }
  }
  debug($eachcurrency);
  $query->condition($eachcurrency);
}

function mcapi_views_views_query_alter($view, &$query) {
  $tables = array_intersect(array_keys($query->table_queue), array('mcapi_transactions', 'mcapi_index'));
  if (!$tables) return;
  foreach ($tables as $table) {
    $query->add_field($table, 'cid', 'cid');
  }
  //add the cid field to anything using the transaction table or index table

}

function theme_views_view_field__cid($variables) {
  $currency = currency_load($variables['row']->cid);
  return $currency->name;
}
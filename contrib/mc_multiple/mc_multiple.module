<?php
// $Id$

/**
 * Mutual Credit API forms for multiple exchanges
 * A series of four forms for creating mass exchanges: many2one, one2many, few2one, one2few
 * On the 'few' forms the user selects the users to trade from ALL the users on the system.
 * but on the 'many' forms the user selects the users NOT to trade
 */

/**
 * http://api.drupal.org/api/function/hook_help/6
 */
function mc_multiple_help($section) {
  switch ($section) {
    case 'admin/mc/webform':
      return t('The mc_webforms module provides a 3rd party exchange form, and some useful code for building other forms.');
    case 'exchange/many2one':
      return t('Pay from all but a few of the site accounts, the same amount, all into one account');
    case 'exchange/one2many':
      return t('Pay from one account the same amount into all but a few of the site accounts');
  }
}

/**
 * http://api.drupal.org/api/function/hook_menu/6
 */
function mc_multiple_menu() {
  $items['exchange/multiple'] = array(
    'title' => 'Multiple',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('many2one_form'),
    'access arguments' => array('create 3rdparty exchanges'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );
  $items['exchange/multiple/many2one'] = array(
    'title' => 'Many-2-one',
    'access arguments' => array('create 3rdparty exchanges'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items['exchange/multiple/one2many'] = array(
    'title' => 'One-2-many',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('one2many_form'),
    'access arguments' => array('create 3rdparty exchanges'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['exchange/multiple/one2few'] = array(
    'title' => 'One-2-few',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('one2few_form'),
    'access arguments' => array('create 3rdparty exchanges'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );
  $items['exchange/multiple/few2one'] = array(
    'title' => 'Few-2-one',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('few2one_form'),
    'access arguments' => array('create 3rdparty exchanges'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
  );
  //this saves making an installer file, coz I'm in a hurry!
  db_query("UPDATE {system} SET weight = %d WHERE name = 'mc_multiple'",
    array(':weight' => db_result(db_query("SELECT weight FROM {system} WHERE name = 'mc_webforms'")))
  );
  return $items;
}


function mc_multiple_forms() {
  $forms['one2many_form'] = array(
    'callback' => 'mc_multiple_form',
    'callback arguments' => array(array('payer_uid' => 'one', 'payee_uid'=>'many'))
  );
  $forms['many2one_form'] = array(
    'callback' => 'mc_multiple_form',
    'callback arguments' => array(array('payer_uid' => 'many', 'payee_uid'=>'one'))
  );
  $forms['few2one_form'] = array(
    'callback' => 'mc_multiple_form',
    'callback arguments' => array(array('payer_uid' => 'few', 'payee_uid'=>'one'))
  );
  $forms['one2few_form'] = array(
    'callback' => 'mc_multiple_form',
    'callback arguments' => array(array('payer_uid' => 'one', 'payee_uid'=>'few'))
  );
  return $forms;
}

/*
 * Implementation of webforms hook, hook_mc_exchange_forms
 */
function mc_multiple_exchange_type_info() {
  $types = array(
    'many2one' => array(
      'title' => t('Many-2-one'),
      'edit' => 'mc_edit_form'
    ),
    'one2many' => array(
      'title' => t('One-2-many'),
      'edit' => 'mc_edit_form'
    ),
    'few2one' => array(
      'title' => t('Few-2-one'),
      'edit' => 'mc_edit_form'
    ),
    'one2few' => array(
      'title' => t('One-2-few'),
      'edit' => 'mc_edit_form'
    )
  );
  return $types;
}

/*
 * Handles all four multiple exchange forms
 */
//$mode imply what widgets to use and which way around. Widgets are 'one', 'few' and 'many'
function mc_multiple_form($form_state, $fields) {
  module_load_include('inc', 'mc_webforms');
  //get the default exchange form, with defaults
  $node = NULL;
  if (isset($form_state['values']) && is_array($form_state['values'])) {
    $node = (object)$form_state['values'];
  }
  $form = mcapi_form_exchange($node);
  
  $form['title']['#element_validate'][] = 'mc_validate_webform_title';
  $frorm['rating']['#required'] = FALSE;
  //need to be explicit because these because this function is called from hook_forms
  //$form['quantity']['#element_validate']['']
  $form['#validate'] = array('mc_multiple_form_validate');
  $form['#submit'] = array('mc_multiple_form_submit');
  $form['exchange_type'] = array(
    '#type' => 'hidden',
    '#value' => implode('2', $fields),
  );
  //this can't be in the api because the node-form tries to add and screws up.
  $form['type'] = array(
    '#type' => 'hidden',
    '#value' => 'exchange',
  );
  //if unaltered, this will go through as zero, or EXCHANGE_STATE_FINISHED
  $form['state']['#type'] = 'hidden';

  foreach ($fields as $field => $widget) {
    //$form[$field]['#theme'] = '';
    switch ($widget) {
      case 'one':
        //just overwrite a couple of things from the mcapi defaults
        $form[$field]['#type'] = 'mc_trader';
      break;
      case 'few':
      case 'many':
        $form[$field]['#title'] = $field == 'payer_uid' ? t('Payers') : t('Payees');
        $form[$field]['#type'] = 'mc_traders';
        $form[$field]['#element_validate'] = array('mc_validate_traders');
        //I wish there were a more elegant way of doing this is php.
        if ($widget == 'many') {
          $form[$field]['#description'] = t("Select the accounts to be ignored. Use CTRL click to select more than one.");
          $form[$field]['#title'] = $field == 'payer_uid' ? t('Non-payers') : t('Non-payees');
          $form[$field]['#invert'] = TRUE;
        }
        else{
          $form[$field]['#description'] = t("Select the accounts. Use CTRL click to select more than one.");
        }
      break;
    }
  }

  $form['preview'] = array (
    '#type' => 'submit',
    '#value' => t('Test exchanges'),
    '#weight' => 29,
    '#submit' => array('preview_mass_exchanges')
  );
  $form['submit'] = array (
    '#type' => 'submit',
    '#value' => t('Generate exchanges'),
    '#weight' => 30,
  );

  if (isset($form_state['#previews']) && count($form_state['#previews'])) {
    $element['#children'] = '<div class="fieldset-wrapper">'.implode("\n", $form_state['#previews']) . '</div>';
    $element['#title'] = t('Previews');
    $element['#collapsible'] = TRUE;
    $form['#prefix'] = theme('fieldset', $element);
  }
  return $form;
}

function mc_multiple_form_validate($form, &$form_state) {
  //just check that the quantity isn't zero. And in the third party form
  if ($form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You cannot exchange a negative amount.'));
  }
  //check all the traders are real
}
function mc_multiple_form_submit(&$form, &$form_state) {
  //assume that payee and payer are an array and a single value
  if (is_array($form_state['values']['payee_uid'])) {
    $payer_uid = _mc_check_trader($form_state['values']['payer_uid']);
    $payee_uid = _mc_check_traders($form_state['values']['payee_uid'], isset($form['payee_uid']['#invert']));
    $message = t("Many to one multiple payment of @amount for @description");
  }
  else {
    $payee_uid = _mc_check_trader($form_state['values']['payee_uid']);
    $payer_uid = _mc_check_traders($form_state['values']['payer_uid'], isset($form['payee_uid']['#invert']));
    $message = t("One to many multiple payment of @amount for @description");
  }

  $node_arrays = prepare_mass_exchanges(
    (array)$payer_uid,
    (array)$payee_uid,
    $form_state['values']
  );
  foreach ($node_arrays as $node_array) {
    $unsigned = array();
    if ($form_state['values']['state'] == EXCHANGE_STATE_PENDING) {
      $unsigned = array($node_array['payer_uid'], $node_array['payee_uid']);
    }
    $results[] = mc_webform_create($node_array, $message);
  }

  foreach ($results as $result) {
    if (!isset($result->success)) {
      $fail = TRUE;
    }
  }
  if (!$fail) {
    drupal_set_message(t('Multiple exchanges created'));
  }
  $currency = node_load($form_state['values']['cid']);
  //this seems to be the only way to get translated strings to watchdog, as the the first 2 parameters must be literal strings
  watchdog('Mass Payments', '!message', array('!message' => t($message, array(
    '@amount' => theme('money', $form_state['values']['quantity'], $currency, FALSE),
    '@description' => $form_state['values']['title']
  ))));
  if (user_access('access site reports') && module_exists('dblog')) {
    $form['#redirect'] = 'admin/reports/dblog';
  }
}

function preview_mass_exchanges($form, &$form_state) {
  //assume that payee and payer are an array and a single value
  if (is_array($form_state['values']['payee_uid'])) {
    $one = $payer = _mc_check_trader($form_state['values']['payer_uid']);
    $many = $payee = _mc_check_traders($form_state['values']['payee_uid'], $form['payee_uid']['#invert']);
    $each_total = -$form_state['values']['quantity'];
  }
  else {
    $one = $payee = _mc_check_trader($form_state['values']['payee_uid']);
    $many = $payer = _mc_check_traders($form_state['values']['payer_uid'], $form['payer_uid']['#invert']);
    $each_total = $form_state['values']['quantity'];
  }
  $total = count($many) * -$each_total;
  //handle duplicates and produce warning message
  //you might expect this in the form validation, but its easier to do it here rather than parse all the exchanges again.
  //check that none of the payements are from and to the same person
  if ($key = array_search($one, $many)) {
    unset($many[$key]);
    $warnings[] = t('The exchange in which !name is both payer and payee will be ignored', array('!name' => theme('username', user_load($transactee))));
  }
  //check limits for the one user, then all the others
  
  $warnings[] = mc_api_check_user_limits(user_load($one), $total, $form_state['values']['cid']);
  foreach ($many as $key => $transactee) {
    $warnings[] = mc_api_check_user_limits(user_load($transactee), $each_total, $form_state['values']['cid']);
  }
  foreach (array_filter($warnings) as $warning) {
    drupal_set_message($warning, 'warning');
  }
  foreach (prepare_mass_exchanges((array)$payer, (array)$payee, $form_state['values']) as $faux_node) {
    $form_state['#previews'][] = theme('exchange_summary', (object)$faux_node);
  }
  $form_state['rebuild'] = TRUE;
}

function prepare_mass_exchanges($payers, $payees, $values) {
  $exchanges = array();
  //make a list of all the exchanges
  foreach ($payers as $payer_uid) {
    foreach ($payees as $payee_uid) {
      if ($payer_uid == $payee_uid) continue;
      $exchanges[] = array(
        'payer_uid' => $payer_uid,
        'payee_uid' => $payee_uid
      )
      + $values;
    }
  }
  return $exchanges;
}

/**
 * Implementation of hook_elements().
 * This form element builds on mc_trader defined in mc_webforms
 * it returns multiple values, either as a comma-seperated textfield, or an array
 * if also has an invert option
 * note that at no time can a form element change the nested-depth of the value it returns
 * so conversion between strings and arrays doesn't work.
 */
function mc_multiple_elements() {
  //this field handles all trader selection, single and multiple.
  //there are two variables on the webform settings page to control it.
  $type['mc_traders'] = array(
    '#input' => TRUE,
    '#process' => array('field_process_mc_traders'),
  );
  return $type;
}
function field_process_mc_traders(&$element, $edit, &$form_state, $form) {
  //process as though it were a single trader select
  $element = field_process_mc_trader($element, $edit, &$form_state, $form);

  $element['#element_validate'] = array('mc_validate_traders');
  if (!$element['#default_value']) {
    $element['#default_value'] = variable_get($form['#id']['#value'] .'_defaults_'. $element['#name'] , array());
  }
  if (variable_get('mc_trader_autocomplete', TRUE)) {
    $element['#type'] = 'textfield';
    //borrow the views ajax callback for selecting multiple users
    $element['#autocomplete_path'] = 'admin/views/ajax/autocomplete/user';
    $element['#description'] =  t('Usernames, emails, or user IDs (mixed is ok)');
    $element['#submit'] = array('mc_submit_traders_autocomplete');
    $element['#attributes']['style'] = 'width:100%';
  }
  else {
    unset ($element['#options'][0]);
    $element['#multiple'] = TRUE;
  }
  return $element;
}

//validate traders for the validation phase, not changing input variables
function mc_validate_traders(&$element, $form_state){
  //we might be getting an array OR a comma separated list here, depending on the widget chosen
  if (is_string($element['#value'])) {
    $traders = drupal_explode_tags(',', $element['#value']);
  }
  else {
    $traders = $element['#value'];
  }
  if ($element['#invert'] == TRUE) {//#invert is added by the form builder
    $traders = array_diff(array_keys(get_trader_list()), $traders);
  }
  foreach ($traders as $trader) {
    _mc_check_trader($trader, $element);
  }
}
//return trader uids whether given an array or comma separated list
function _mc_check_traders($traders, $invert = FALSE) {
  //we might be getting an array or a comma separated list here
  if (is_string($traders)) {
    $traders = drupal_explode_tags($traders);
  }
  foreach ($traders as $value) {
    $new_values[] = _mc_check_trader($value);
  }
  if ($invert) {
    $traders = array_diff(array_keys(get_trader_list()), $new_values);
  }
  
  return $new_values;
}

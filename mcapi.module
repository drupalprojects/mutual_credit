<?php  // $Id: mcapi.module,v 1.1.2.6 2010/12/22 19:30:29 matslats Exp $: transactions.module,v 1.1.2.4 2009/10/14 10:03:54 matslats Exp $

module_load_include('field.inc', 'mcapi');
module_load_include('controller', variable_get('mcapi_controller', 'mcapi'));

/**
 * @file
 * transactions  are fieldable entities, balances & other stats are in a cache table exposed to views.
 *
 * This .module file contains only the hooks and functions which might be called when the module isn't actively required
 *
 */

//states are mutually exclusive
//the convention is that states > 0 are counted
define ('TRANSACTION_STATE_FINISHED', 1);
define ('TRANSACTION_STATE_ERASED', 0);
define ('TRANSACTION_STATE_UNSAVED', NULL); //before the transaction ever reaches the db
define ('TRANSACTION_STATE_VALIDATED', -2);

/**
 * implements hook_help()
 */
function mcapi_help($section, $arg) {
  switch ($section) {
    case 'admin/help#transaction':
      return t('Defines a contentType called transactions, manages them and does the accounting.');
    case 'admin/accounting':
      return '<p>'. t("This module, its development and implementations at !cforge,", array('!cforge' => l('Community Forge', 'http://communityforge.net')))  .' '.
        t("have been the full time commitment of one person since Spring 2008, and a second person since spring 2009.") . ' '.
        t("The results of this work are offered freely to all.") .'</p><p>'.
        t("We give all possible resources to this work, and live by reciprocal gifting as much as possible.") .' '.
        t("We look forward to the day when support is robust enough to pay staff and provide a reliable nonprofit public service.") .' '.
        t("Please consider supporting this work by:") . ' '.
        theme('item_list', array('items' => array(
          t("sending some scarce hard currency to the developer"),
          t("allying with us to build a global complementary currency ecosystem"),
          t("offering board and lodging for a month or two")
        )));
      case 'admin/config/system/actions/configure':
        //have to look up arg to know which action this is
        return implode('. ', array('<p>'.
          t('Some actions on the site may trigger new transactions. '),
          t('This feature has not yet been deployed, and cannot yet use tokens') . '</p>'
          ));
      case 'admin/accounting/record':
        return t('This is a base form provided for administration purposes only. For end-users, there are forms provided by other modules');
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  module_load_include('inc', 'mcapi');
  return mcapi_menu_inc();
}
function mcapi_menu_alter(&$items) {
  foreach (array_keys($items) as $key) {
    //we don't need to see the page for arranging the bundle fields,
    if (substr($key, 0, 41) == 'admin/accounting/edit/display' || substr($key, 0, 38) == 'admin/accounting/currency/edit/display') {
      unset($items[$key]);
    }
  }
  unset($items['admin/accounting/edit/display']);
  unset($items['admin/accounting/currency/edit/display']);
  unset($items['admin/accounting/fields/worth/delete']);
  //but we do want to manage the fields for two entity types on one page.
  $items['admin/accounting/currency/edit/fields']['title'] = 'Currency fields';
  $items['admin/accounting/edit/fields']['title'] = 'Transaction fields';
}

/*
 * implements hook_forms
 */
function mcapi_forms($form_id, $args) {
  $forms['transaction_admin_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  return $forms;
}

function transaction_form($form, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  //the incoming transaction is either from $form_state, or from the build arguments or an empty object
  $transaction = isset($form_state['transaction']) ? $form_state['transaction'] : (
    isset($form_state['build_info']['args'][0]) ? $form_state['build_info']['args'][0] : new_transaction());
  return _transaction_form($form, $form_state, $transaction);
}

/*
 * hook for modules to declare new_transaction()s types and states
 */
function mcapi_hook_info() {
  module_load_include('inc', 'mcapi');
  return array(
    'transaction_controller' => array(),
    'mcapi_info_states' => array(),
    'mcapi_info_types' => array(),
    'mcapi_info_access' => array(),
    'mcapi_info_permissions' => array(),
    'mcapi_info_drupal_permissions' => array(),
  );
}

/**
 * implements hook_permission
 * This hook can supply permissions that the module defines,
 */
function mcapi_permission() {
  return module_invoke_all('mcapi_info_drupal_permissions');
}


/*
 * implements mcapi hook_info_controller
 * the presence of this hook indicates there is a .controller file
 * with the name MODULE.controller
 */
function mcapi_transaction_controller(){}

/*
 * implements mcapi hook_info_states
 * DON"T call this hook directly as the keys will be lost. use mcapi_states()
 */
function mcapi_mcapi_info_states() {
  return array(
    //TRANSACTION_STATE_UNSAVED => t('unsaved'),//internal use only, never saved in db, and not reported
    //must be defined with lower case
    TRANSACTION_STATE_FINISHED => t('finished'),
    TRANSACTION_STATE_ERASED => t('erased'),
    TRANSACTION_STATE_VALIDATED => t('validated'),
  );
}
function mcapi_states() {
  $states = array();
  foreach(module_implements('mcapi_info_states') as $module) {
    $function = $module . '_mcapi_info_states';
    $states += $function('states');
  }
  return $states;
}

/*
 * implements mcapi hook_info_types
 */
function mcapi_mcapi_info_types() {
  return array('unspecified', 'auto');
}

/*
 * implements mcapi hook_mcapi_info_drupal_permissions
 * make permissions appear altogether on the permissions page
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    )
  );
}

/*
 * implements hook mcapi_permissions
 * each callback refers to 2 functions - itself and CALLBACK_views
 * Declare the access callbacks for (transactions in) currencies
 * each callback takes a $transaction
 */
function mcapi_mcapi_info_permissions() {
  return array(
    'mcapi_access_participants_admin' => t('Only the two participants and admin'),
    'mcapi_access_unrestricted' => t('Anyone, including anonymous users'),
    'mcapi_access_authenticated' => t('Only authenticated users'),
    'mcapi_access_participants' => t('Only the two participants'),
    'mcapi_access_admin' => t("Only admin"),
    'mcapi_access_creator' => t('Only the transaction creator'),
    'mcapi_access_none' => t('Nobody')
  );
}

/**
 * special access function for transactions - NOT hook implementation
 * $op can be array('view', 'update', 'erase', 'admin')
 * Note some settings may even restric access to user 1
 */
function transaction_access($op, $transaction, $account = NULL) {
  module_load_include('admin.inc', 'mcapi', 'currencies');
  module_load_include('inc', 'mcapi');
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  if (!isset($transaction->worth)) {
    drupal_set_message(t('Invalid transaction; access denied', array('@var' => $transaction)), 'error');
    return FALSE;
  }
  reset($transaction->worth);
  //current() gives us the first language, and we're assuming there's only one.
  foreach (current($transaction->worth) as $flow) {
    $currency = currency_load($flow['currcode']);
    //access denied for transaction if ANY of the currencies denies it.
    if (empty($currency->$op)) {
      return FALSE;
    }
    $states = $currency->$op;
    if (!isset($states[$transaction->state])) {
      drupal_set_message(
        t('Currency @name has no permission set for op @op & state @state',
          array('@name' => $flow['currcode'], '@op' => $op, '@state' => $transaction->state)
        ),
        'warning',
        FALSE
      );
      return FALSE;
    }
    $function = $states[$transaction->state];
    if (function_exists($function)) {
      if ($function($transaction, $account, $currency)) return TRUE;
    }
  }
  return FALSE;
}
/*
 * menu access callback for the transaction tab for admin editing
 * only shows if the user owns all currencies in the transaction
 * and if both currencies allow transaction updates
 */
function transaction_adminedit($transaction) {
  if (!user_access('manage all transactions')) return FALSE;
  module_load_include('inc', 'mcapi');
  $flows = current($transaction->worth);
  foreach ($flows as $flow) {
    $currency = currency_load($flow['currcode']);
    if (empty($currency->update))return;
    $states = $currency->update;
    $function = $states[$transaction->state];
    if (function_exists($function)) {
      if ($function($transaction, $GLOBALS['user'], $currency)) return TRUE;
    }
  }
}


/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  return array(
    'transaction' => array(
      'template' => 'transaction',
      'pattern' => 'transaction__',
      'variables' => array(
        'transaction' => NULL,
        'view_mode' => 'certificate',
      )
    )
  ) + mcapi_theme_fields();
}


/**
 * Implements hook_entity_info()
 */
function mcapi_entity_info(){
  module_load_include('inc', 'mcapi');
  return mcapi_entity_info_inc();
}
//I don't believe this callback, part of the entity definition, has any purpose
function transaction_uri($transaction) {
  return array(
    'path' => 'transaction/' . $transaction->xid,
  );
}
function transaction_label($transaction){
  return t('Transaction #@xid', array('@xid' => $transaction->xid));
}
function currency_label($currency) {
  return $currency->name;
}
function transaction_menu_title($transaction) {
  return t('Transaction certificate #@xid', array('@xid' => $transaction->xid));
}

/**
 * menu callback
 * build a render array any number of transactions
 * compatible with $entity_info['view callback'] from entity module
 * first arg can be one or an array
 */
function transaction_view($transactions, $view_mode = 'certificate', $langcode = 'und') {
  if (!is_array($transactions)) {
    $transactions = array($transactions->xid => $transactions);
  }
  entity_prepare_view('transaction', $transactions);
  field_attach_prepare_view('transaction', $transactions, 'default');
  foreach ($transactions as $transaction) {
    $transaction->additional = field_attach_view('transaction', $transaction, $view_mode);
    $renderable[] = array(
      '#theme' => 'transaction',
      '#transaction' => $transaction,
      '#view_mode' => $view_mode,
    );
  }
  return $renderable;
}

/*
 * make the transaction variables into something which can be nicely themed
 */
function template_preprocess_transaction(&$variables) {
  $transaction = &$variables['transaction'];
  $variables['payer'] = format_username(user_load($transaction->payer));
  $variables['payee'] = format_username(user_load($transaction->payee));
  $variables['state'] = $transaction->state;
  $variables['recorded'] = format_date($transaction->created, 'medium');
  $variables['type'] = $transaction->type;
  //choose the transaction theme template based on the first currency of the transaction
  $flows = current($transaction->worth);
  $variables['theme_hook_suggestion'] = 'transaction__' . $flows[0]['currcode'];
  foreach (element_children($transaction->additional) as $key) {
    $variables[$key] = drupal_render($transaction->additional[$key]);
  }
}

// this shouldn't be necessary, but how else to get a dynamic list of tokens?
function mcapi_get_tokens() {
  module_load_include('tokens.inc', 'mcapi');
  $info = mcapi_token_info();
  $markers = array_keys($info['tokens']['transaction']);
  $tokens = array();
  foreach ($markers as $token) {
    $tokens[] = "[transaction:$token]";
  }
  return implode(', ', $tokens);
}

/*
 * Callback to help build transaction entity from $form_state
 */
function transaction_entity_builder($entity_type, $entity, $form, &$form_state) {
  $entity->state = isset($form_state['values']['state']) ?  $form_state['values']['state'] : TRANSACTION_STATE_FINISHED; //shouldn't really be omitted
  $entity->creator = isset($form_state['values']['creator']) ?  $form_state['values']['creator'] : $GLOBALS['user']->uid;
  $entity->created = REQUEST_TIME;
}


/*
 * form submit callback from the base transaction form, hence used by all forms
 * hence must be in .module file
 * this is what actually saves the data
 * $form_state['transaction'] was created in the validation stage
 */
function transaction_all_submit($form, &$form_state) {
  $transaction = transaction_save($form_state['transaction']);
  if ($transaction) {
    field_attach_submit('transaction', $transaction, $form, $form_state);
  }
  if (!isset($form_state['redirect'])) {
    $form_state['redirect'] = 'transaction/'.$transaction->xid;
  }
  //execute the hook / or trigger ????
}


  //this runs every time a 'new_transaction()' is created
function new_transaction() {
  return (object) array(
    'xid' => NULL,
    'payer' => NULL,
    'payee' => NULL,
    'creator' => $GLOBALS['user']->uid,
    'state' => TRANSACTION_STATE_UNSAVED,
    'type' => 'unspecified',
    'extra' => array()
  );
}

/*
 * INTERNAL API FOR MODULE DEVELOPERS
 *
 * These need to be better unified as regards exception handling
 * but I don't have much experience on that
 * for now, all validates must be done within try{}
 *
 * This is where we interface with the entity controller
 * object transaction_load(array(94))
 * array transaction_load_multiple($conditions) e.g array('state' => 0)
 * object transaction_validate($transaction)
 * object transaction_save($transaction)
 * NULL transaction_erase($transaction)
 * NULL transaction_state($transaction, $newstate);
 * array transaction_totals($transaction)
 */

/**
 * load a single transaction, from the $xid
 * this is used to as a menu loader, so can't be in an inc file
 */
function transaction_load($xid) {
  //if this isn't done globally, entity_crud_get_info in the contributed 'entity' module, tries to load the controller without loading the file
  $transactions = entity_get_controller('transaction')->load(array(intval($xid)));
  return array_pop($transactions);
}
function transaction_load_multiple($xids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('transaction', $xids, $conditions, $reset);
}
function transaction_validate(stdClass $transaction) {
  //always sets the transaction->state to TRANSACTION_STATE_VALIDATED
  return entity_get_controller('transaction')->validate($transaction);
}
//don't forget to field_attach_submit when calling this
function transaction_save(stdClass $transaction) {
  return entity_get_controller('transaction')->save($transaction);
}
function transaction_erase($transaction) {//will accept int or object
  if (!is_object($transaction)) {
    throw new Exception('Wrong type passed to transaction_erase');
  }
  return entity_get_controller('transaction')->erase($transaction);
}
function transaction_state(stdClass $transaction) {
  return entity_get_controller('transaction')->state($transaction);
}
//returns an objectwith properties
//->balance
//->gross_in
//->gross_out
//->count
function transaction_totals($uid, $currcode = NULL, $options = array()) {
  if (!$currcode) $currcode = key(currencies_load());
  $options += array(
    'states' => array(TRANSACTION_STATE_FINISHED),
  );
  //convert it to an object for cleaner syntax in php5
  return (object)entity_get_controller('transaction')->sums($uid, $currcode, $options);
}

/*
 * validate callback for user id fields
 * borrowed from node_validate, where it really should have been a reusable function like this.
 * this is in the main module file where it can be found by both currency form and transaction form.
 */
function mcapi_validate_usernames(&$element, &$form_state) {
  $values = is_array($element['#value']) ? $element['#value'] : array($element['#value']);
  if (!array_filter($values)) return;
  foreach ($values as $value) {
    if (!is_numeric($value)) {
      $uid = user_load_by_name($value)->uid;
      if ($uid) {
        form_set_value($element, $uid, $form_state);
      }
      else {
        form_error($element, t('The username %name does not exist.', array('%name' => $value)));
      }
    }
  }
}

/*
 * return one currency object
 */
function currency_load($currcode = 0) {
  $currencies = currencies_load();
  if (!empty($currencies[$currcode])) {
    return $currencies[$currcode];
  }
  return (object)array('name' => t('Please choose...'));
}
/*
 * Load all the currencies from cache filter
 * then optionally return them filtered for which ones an account can use.
 */
function currencies_load($account = NULL) {
  $currencies = &drupal_static('currencies');
  if (!$currencies) {//first time this page request.
    $cache = cache_get('currencies');
    if ($cache) {
      $currencies = $cache->data;
    }
    else {
      module_load_include('admin.inc', 'mcapi', 'currencies');
      $currencies = currencies_recache();
    }
  }
  if (empty($account)) return $currencies;
  module_load_include('admin.inc', 'mcapi', 'currencies');
  $filtered = array();
  foreach ($currencies as $currcode => $currency) {
    //temp measure to update currency division format
    //TODO remove this after while.
    if ($currency->divisions == '00') {
      drupal_set_message('the currency format has changed. Please change your currency divisions field from 00 to 01');
      drupal_goto('admin/accounting/currency');
    }

    if (currency_access('use', $currency, $account)) {
      $filtered[$currcode] = $currency;
    }
  }
  return $filtered;
}

/*
 * Implements variable module's hook_variable_info
 */
function mcapi_variable_info() {
  $vars['mcapi_controller'] = array(
    'type' => 'string',
    'title' => t('Transaction entity controller'),
    'default' => 'mcapi',
    'description' => t('The module that controls how the transactions are read and written to the database.'),
    'required' => TRUE,
  );
  $vars['currency_default'] = array(
    'type' => 'unknown',
    'title' => t('Default currency'),
    'description' => t('The currency when mcapi_currencies is not installed'),
    'required' => TRUE,
  );
  return $vars;
}


/*
 * Implements views hook_views_api
 */
function mcapi_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi') . '/views',
  );
}

//================
//this could all go in a views.inc file I think




//must return a condition objectmcapi_transactions.state
function mcapi_access_unrestricted_views($state){
  $condition = db_and();
  return $condition->condition('mcapi_transactions.state', $state);
}
//must return a condition objectmcapi_transactions.state
function mcapi_access_creator_views($state){
  $condition = db_and();
  return $condition->condition('mcapi_transactions.creator', $GLOBALS['user']->uid);
}
function mcapi_access_authenticated_views($state){
  $condition = db_and();
  $condition->condition('mcapi_transactions.state', $state);
  $condition->condition(0, $GLOBALS['user']->uid, '<>');
  return $condition;
}
function mcapi_access_none_views($state){
  $condition = db_and();
  $condition->condition('mcapi_transactions.state', $state);
  $condition->condition(0, 1);//which is to say, FALSE
  return $condition;
}
function mcapi_access_participants_admin_views($state) {
  $condition = db_and();
  $condition->condition('mcapi_transactions.state', $state);
  $subcondition = db_or();
  $subcondition->condition('mcapi_transactions.payee', $GLOBALS['user']->uid);
  $subcondition->condition('mcapi_transactions.payer', $GLOBALS['user']->uid);
  $subcondition->condition(1, user_access('administer all transactions'));
  $condition->condition($subcondition);
  return $condition;
}
function mcapi_access_admin_views($state) {
  $condition = db_and();
  $condition->condition('mcapi_transactions.state', $state);
  $condition->condition(1, user_access('administer all transactions'));
  return $condition;
}
function mcapi_access_participants_views($state) {
  $condition = db_and();
  $condition->condition('mcapi_transactions.state', $state);
  $subcondition = db_or();
  $subcondition->condition('mcapi_transactions.payee', $GLOBALS['user']->uid);
  $subcondition->condition('mcapi_transactions.payer', $GLOBALS['user']->uid);
  $condition->condition($subcondition);
  return $condition;
}
//this isn't working without the $currency, which the others do not need
//perhaps it doesn't belong here
function mcapi_access_currency_views($state) {
  $condition = db_and();
  return $condition->condition('mcapi_transactions.state', $state);
}


/*
 * implements hook_query_TAG_alter
 * the saved view adds the tag 'transaction_access'
 * this modifies the query only to show the transactions visible to the user.
 * this is pretty elaborate, but the access control has to be done in the query or views pager won't know how many results there were
 */
function _mcapi_query_transaction_access_views_alter(QueryAlterableInterface &$query) {
  $query->addJoin('LEFT', 'field_data_worth', 'tw', 'tw.entity_id = xid');
  //what currencies can the current user see?
  $currencies = currencies_load();
  //WHERE (
  //  (
  //    tw.field_worth_currcode = 1
  //  ) AND (//$currcode_and_states
  //    (
  //      (
  //        mcapi_transactions.state = 0
  //      ) AND (// $state_and_callback
  //        callback
  //      )
  //    ) OR (//$state_or_state
  //      (
  //        mcapi_transactions.state = 1
  //      ) AND (// $state_and_callback
  //        callback
  //      )
  //   )
  // ) OR ( //$or_currcodes
  //  currcode = 2 ...
  $or_currcodes = db_or();
  foreach ($currencies as $currency) {
    $currcode_and_states = db_and();
    $currcode_and_states->condition('tw.worth_currcode', $currency->currcode);
    //note for views we are only interested in viewing permission
    $state_or_state = db_or();
    foreach ($currency->view as $state => $callback) {
      $callback .= '_views';
      $state_and_callback = $callback($state);
      $state_or_state->condition($state_and_callback);
    }
    $currcode_and_states->condition($state_or_state);
    $or_currcodes->condition($currcode_and_states);
  }
  //debug($query->__toString());
  $query->condition($or_currcodes);
}


/*
 * Bit of a one off, this one
 */
function mcapi_format_usernames($accounts) {
  foreach($accounts as $account) {
    $names[] = format_username($account);
  }
  return implode(' & ' ,$names);
}
<?php
// $Id: mcapi.module,v 1.1.2.6 2010/12/22 19:30:29 matslats Exp $: transactions.module,v 1.1.2.4 2009/10/14 10:03:54 matslats Exp $

/**
 * @file
 * transactions and currencies are fieldable entities, balances & other stats are in a cache table exposed to views.
 *
 * This .module file contains only the hooks and functions which might be called when the module is passive
 * If the module is doing anything requiring mutual_credit functionality as generating a block or a page, the inc is included
 *
 * NOTES ON THE TRANSACTION QUANTITY
 * Quantity is stored as a decimal in the DB for easy calculation
 * The transaction object stores the amount as a decimal fraction
 * In preprocessing  an hour currency the decimal is multiplied by 0.6 to become hours:minutes,
 * The theme_money function then attaches the icon or currency name
 *
 *
 * if the multiple currencies module is not installed, the default currency id ('cid') is 0
 *
 */


//states are mutually exclusive
define ('TRANSACTION_STATE_FINISHED', 0);
define ('TRANSACTION_STATE_PENDING', 1);
define ('TRANSACTION_STATE_ERASED', -1);
define ('MCAPI_NOTIFICATION_DEFAULT_LEVEL', 2);


$currencies = &drupal_static('currencies');
$currencies = entity_get_controller('currency')->load(FALSE);

/**
 * implements hook_help()
 */
function mcapi_help($section) {
  switch ($section) {
    case 'admin/help#transaction':
      return t('Defines a contentType called transactions, manages them and does the accounting.');
    case 'admin/accounting/acknowledgements':
      return '<p>'. t("This module, its development and implementations at !cforge,", array('!cforge' => l('Community Forge', 'http://communityforge.net')))  .' '.
        t("have been the full time commitment of one person since Spring 2008, and a second person since spring 2009.") . ' '.
        t("The results of this work are offered freely to all.") .'</p><p>'.
        t("We give all possible resources to this work, and live by reciprocal gifting as much as possible.") .' '.
        t("We look forward to the day when support is robust enough to pay staff and provide a reliable nonprofit public service.") .' '.
        t("Please consider supporting this work by:") . ' '.
        theme('item_list', array('items' => array(
          t("sending some scarce hard currency to the developer"),
          t("allying with us to build a global complementary currency ecosystem"),
          t("offering board and lodging for a month or two")
        )));
      case 'admin/accounting/record':
        return t('This is a base form provided for administration purposes only. For end-users, there are forms provided by other modules');
      case 'admin/accounting/options':
        return t('Determine the rigour of your accounting standards. (May not be compatible with all engines).') .' '. 'Should this be per-currency?';
  }
}

function mcapi_controller() {
  $name = variable_get('mcapi_controller', 'default');
  module_load_include('controller', 'mcapi', $name);
}

/*
 * Needed for the views 2 module
 */
function mcapi_views_api() {
  return array(
    'api' => '3.0-alpha1', //TODO update this to v3
    'path' => drupal_get_path('module', 'mcapi') .'/views',
  );
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  module_load_include('inc', 'mcapi');
  return mcapi_menu_inc();
}
function mcapi_menu_alter(&$items) {
  foreach (array_keys($items) as $key) {
    //we don't need to see the page for arranging the bundle fields,
    if (substr($key, 0, 41) == 'admin/accounting/transaction/edit/display' || substr($key, 0, 38) == 'admin/accounting/currency/edit/display') {
      unset($items[$key]);
    }
  }
  unset($items['admin/accounting/transaction/edit/display']);
  unset($items['admin/accounting/currency/edit/display']);
  //but we do want to manage the fields for two entity types on one page.
  $items['admin/accounting/currency/edit/fields']['title'] = 'Currency fields';
  $items['admin/accounting/transaction/edit/fields']['title'] = 'Transaction fields';
}


function mcapi_forms() {
  $forms['transaction_admin_form']['callback'] = 'transaction_form';
  $forms['transaction_admin__update_form']['callback'] = 'transaction_form';
  return $forms;
}

/**
 * special access function for transactions - NOT hook implementation
 * $ops can be array('view', 'update', 'erase')
 * User 1 cannot update or delete if the currency type doesn't allow
 */
function transaction_access($op, $transaction, $account = NULL) {
  $currencies = &drupal_static('currencies');
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $currency = $currencies[$transaction->cid];
  $participated = $account->uid == $transaction->payee_uid || $account->uid == $transaction->payer_uid;
  $pending = $transaction->state == TRANSACTION_STATE_PENDING;
  $owner = $transaction->uid == $account->uid;

  $accountant = user_access('manage all transactions') && $currency->privacy;
  switch ($op) {
    case 'view'://users can always view their own pages
      debug($currency->privacy);
      switch ($currency->privacy) {
        case 0: return $participated;
        case 1: return $participated || $accountant;
        case 2: $callback = $currency->access_callback;
          return $callback('view', $currency, $GLOBALS['user']->uid);
        case 2: return $GLOBALS['user']->uid;
        case 3: return TRUE;
    }
    case 'update':
      if ($currency->update_mode < 1 || $transaction->state == TRANSACTION_STATE_ERASED) return;
      switch ($currency->user_editable_mode) {
        case 0: return $accountant;
        case 1: return $accountant || ($pending && $owner);
        case 2: return $accountant || ($pending && $participated);
        case 3: return $accountant || $participated;
      }
    case 'erase':
      if ($currency->delete_mode < 1 || $transaction->state == TRANSACTION_STATE_ERASED) return;
      switch($currency->user_editable_mode) {
        case 0: return $accountant;
        case 1: return $accountant || ($pending && $owner);
        case 2: return $accountant || ($pending && $participated);
        case 3: return $accountant || $participated;
      }
    default: debug('Unknown $op in transactions_access');
  }
}

/*
 * determine whether a user has permission to use/edit a currency
 * This could get rather complicated, and vary from system to system
 * Right now 
 * 
 */
function currency_access($op, $currency, $uid = NULL) {
  if (!$uid) $uid = $GLOBALS['user'];
  $function = $currency->access_callback;
  switch ($op) {
    case 'edit':
      return $uid == $currency->uid || user_access('configure all currencies');
    case 'view'://which is to say, view transactions in
      switch($currency->privacy) {
        case 0: return TRUE;
        case 1: return currency_access('use', $currency, $uid);
        case 2: return NULL; //can't be calculated here
        case 3: return NULL;
      }
      //I"m not yet sure exactly a user of the currency is?
      //does it denote the right to use, which is thus far not stored in the db
      //or does it denote that user has used?
    case 'use':
    case 'initiate':
      return $function == 'user_access' ? user_access('transact', user_load($uid)) : $function($op, $currency, $uid);
  }
}
/*
 * determines which currencies a user can use
 */
function currency_choose($op, $uid) {
  $currencies = &drupal_static('currencies');
  foreach ($currencies as $currency) {
    if (currency_access($op, $currency, $uid)) {
      $currencies[$currency->cid] = $currency;
    }
  }
  return $currencies;
}
function currency_select($currencies) {
  foreach ($currencies as $currency) {
    $selection[$currency->cid] = $currency->name;
  }
  return $selection;
}

/*
 * callback function for currency usage
 * viral spread means that anyone can use the currency, but only after someone has traded with them first.
 * So this function just returns true for 'initiate' if the user created or has used the currency
 * $ops can be
 * 'view' meaning view transactions in that currency
 * 'initiate' meaning start transactions in that currency
 * 'use' meaning you can have a balance
 */
function currencies_access_viral($op, $currency, $uid) {
  //return all the currencies which the user has ever used, or created
  if ($currency->uid == $uid || $op == 'use') return TRUE;
  if ($op == 'initiate' || $op == 'view') {
    //this includes pending transactions
    return db_query('SELECT xid FROM mcapi_transactions WHERE payer_uid = :payer or payee_uid = :payee',
       array(':payer' => $uid, ':payee' => $uid)
    )->execute()->fetchField();
  }
}

/**
 * implements hook_permission
 * This hook can supply permissions that the module defines,
 */
function mcapi_permission() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t('Use unrestricted currencies'),
    ),
    'manage all transactions' => array(
      'title' => t('manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency'),
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    ),
  );
}


/*
 * Implements hook_user_view
 */
function mcapi_user_view($account) {
  mcapi_controller();
  $balances = entity_get_controller('transaction')->get_cache($account->uid);
  $account->content['mcapi'] = array(
    '#title' => t('Monetary activity'),
    '#type' => 'user_profile_category',
    'balances' => array(
      '#theme' => 'balances',
      '#title' => t('Balances'),
      '#balances' => $balances,
    )
  );
}

/**
 * load a single transaction, from the $xid
 * this is used to as a menu loader, so can't be in an inc file
 */
function transaction_load($xid) {
  mcapi_controller();
  $transaction = array_pop(entity_load('transaction', array($xid)));
  return $transaction;
}


/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $path .='/theme';
  $items = array(
    'money' => array(
      'variables' => array(
        'quantity' => 0,
        'cid' => 0,
      )
    ),
    'transaction' => array(
      'template' => 'transaction',
      'pattern' => 'transaction__',
      'path' => $path,
      'variables' => array(
        'transaction' => NULL,
        'view_mode' => 'certificate',
      )
    ),
    'balances' => array(
      'template' => 'balances',
      'path' => $path,
      'variables' => array(
        'balances' => array() //array with cid for keys
      )
    )
  );
  return $items;
}

function theme_money($variables) {
  extract($variables);
  $currency = currency_load($cid);
  //the static variable saves processing the icon every time
  $formats = drupal_static(__FUNCTION__);
  if (!isset($formats[$cid])) {
    if (strpos($currency->format, '@icon') !== FALSE) {
      foreach($currency->field_image as $lang) {
        foreach ($lang as $props) {
          $props['path'] = $props['uri'];
          continue 2;
        }
      }
    }
    $formats[$cid] = str_replace('@icon', isset($props) ? theme('image', $props) : '', $currency->format);
  }
  
  $integer = abs(intval($quantity));
  if ($currency->divisions) {
    $fraction = 100 * round(abs($quantity) - abs($integer), 2);
    if (is_array($currency->divisions)) {
      $subdivision = $currency->divisions[$fraction];
    }
    else $subdivision = $fraction;
  }
  else {
    $subdivision = '00';
  }
  return strtr(
    $formats[$cid],
    array(
      '@minus' => $quantity < 0 ? '-' :'',
      '@integer' => $integer,
      '@subdivision' => $subdivision
    )
  );
}


function template_preprocess_balances(&$vars) {
  $currencies = &drupal_static('currencies');
  foreach ($vars['balances'] as $cid => $amounts) {
    $vars['currencies'][$cid] = $currencies[$cid];
    foreach ($amounts as $key => $quantity) {
      if ($key != 'count') {
        $vars['balances'][$cid][$key] = theme('money', compact('quantity', 'cid', 'currencies'));
      }
    }
  }
}



/**
 * Implements hook_entity_info()
 */
function mcapi_entity_info(){
  module_load_include('inc', 'mcapi');
  return mcapi_entity_info_inc();
}

function transaction_uri($transaction) {
  return array(
    'path' => 'transaction/' . $transaction->xid,
  );
}
function transaction_label($transaction){
  return $transaction->description;
}
function currency_label($currency) {
  return $currency->name;
}

/*
 * Implementation of hook_transaction_type_info
 * Transaction types are NOT entity bundles
 */
function mcapi_transaction_type_info() {
  return array(
    'admin' => array(
      'title' => 'admin',
    )
  );
}



/*
 * takes an array of objects, with the nid as array keys and returns an array with just the titles
 * for preparing form field select options
 * Seems a bit random, but there you go...
 */
function mcapi_title_selector($objects, $title_key, $zero_val = 'unspecified') {
  $options = array();
  if ($zero_val && count($objects) > 1) {
    $options[] = $zero_val;
  }
  foreach ($objects as $id => $object) {
    if (is_array($object)) {
      $options[$id] = $object[$title_key];
    }
    else {
      $options[$id] = $object->$title_key;
    }
  }
  return $options;
}

/**
 * Implements hook_image_default_styles().
 */
function mcapi_image_default_styles() {
  return array(
    'curr_icon' => array(
      'effects' => array(
        array(
          'name' => 'image_scale',
          'data' => array('width' => 16, 'height' => 16, 'upscale' => 0),
          'weight' => 0,
        ),
      ),
    )
  );
}

function currency_load($cid) {
  module_load_include('inc', 'mcapi');
  $currencies = &drupal_static('currencies');
  return $currencies[$cid];
}

/**
 * build a render array for the transaction
 * not sure if this is needed
 */
function transaction_view($transaction, $view_mode = 'certificate') {
  //this is almost certainly a full page view, so I dare to set the title here
  $page_title = t('Transaction Certificate #@xid', array('@xid' => $transaction->xid));
  if ($transaction->state == TRANSACTION_STATE_PENDING) {
    $page_title .= '-'. strtoupper(t('pending'));
  }
  drupal_set_title($page_title);

  // This is only needed if there are fields on the transaction entity
  field_attach_prepare_view('transaction', array($transaction->xid => $transaction), 'default');

  entity_prepare_view('transaction', array($transaction->xid => $transaction));
  $build = array(
    '#theme' => 'transaction',
    '#transaction' => $transaction,
    '#view_mode' => $view_mode,
  );

  if (!empty($node->nid) && !($view_mode == 'certificate')) {
    $build['#contextual_links']['transaction'] = array('transaction', array($transaction->xid));
  }
  return $build;
}

/*
 * make the transaction variables into something which can be nicely themed
 */
function template_preprocess_transaction(&$arguments) {
  $transaction = $arguments['transaction'];

  $arguments['theme_hook_suggestion'] = 'transaction__' . $transaction->cid;
  $arguments += array(
    'description' => $transaction->description,
    'payer' => theme('username', array('account' => user_load($transaction->payer_uid))),
    'payee' => theme('username', array('account' => user_load($transaction->payee_uid))),
    'amount' => theme('money', array('cid' => $transaction->cid, 'quantity' => $transaction->quantity)),
    'state' => $transaction->state,
    'recorded' => format_date($transaction->created, 'medium'),
    'type' => $transaction->type
  );
}

//Some currency properties need to be identical if they are to rendered into the transaction form
//this returns the field only if it is the same in all the passed currencies
//takes top-level fieldnames or data fieldnames
//this is a bit complicated by the design of the currency object, but it works fine
function get_common_currency_properties($currencies, $fieldname) {
  $first = array_pop($currencies);

  foreach ($currencies as $currency) {
    if (isset($first->$fieldname)) {
      if ($first->$fieldname != $currency->$fieldname) {
        return;
      }
      $val = $first->$fieldname;
    }
    elseif (isset($first->data[$fieldname])) {
      if ($first->data[$fieldname] != $currency->data[$fieldname]) {
        return;
      }
      $val = $first->data['$fieldname'];
    }
  }
  if (isset($val)) {
    return $val;
  }
  elseif (isset($first->$fieldname)) {
    return $first->$fieldname;
  }
  elseif (isset($first->data[$fieldname])) {
    return $first->data[$fieldname];
  }
}

/*
 * implements hook_query_TAG_alter
 * the saved view adds the tag 'transaction_access'
 * this modifies the query only to show the transactions visible to the user.
 * in practice, this means filtering by currency firstly
 * but currencies with view control based on who traded is more complicated
 */
function mcapi_query_transaction_access_alter(&$query) {
  $uid = $GLOBALS['user']->uid;
  //what currencies can the current user see?
  $currencies = currency_choose('view', $uid);
  $eachcurrency = db_or();
  foreach ($currencies as $currency) {
    switch ($currency->privacy) {
      case 1: //show only transactions in currencies that authenticated user can see
        if (!$GLOBALS['user']->uid) continue;
        //if you are logged in, then its the same as if there were no restrictions
      case 0: //in effect, no restrictions
        $eachcurrency->condition('cid', $currency->cid);
        break;
      case 2: //show only transactions in currencies where I have a cached balance
        $cached = entity_get_controller('transaction')->get_cache($uid);
        if (isset($cached[$currency->cid])) {
          $eachcurrency->condition('cid', $currency->cid);
        }
        break;
      case 3: //participants, accountant and user 1
        if (!user_access('manage all transactions')) continue;
        //and if you do have permission, then that's like privacy being 4, for this currency.
      case 4: //only participants
        $eachcurrency->condition(db_and()
          ->condition('cid', $currency->cid)
          ->condition(db_or()
            ->condition('payer_uid', $uid)
            ->condition('payee_uid', $uid)
            ->condition('uid', $uid)
          )
        );
    }
  }
  $query->condition($eachcurrency);
}

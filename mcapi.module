<?php

/**
 * @file
 * mcapi.module
 */

use Drupal\Core\Template\Attribute;
use Drupal\Core\Utility\Token;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\user\Entity\User;
use Drupal\mcapi\Plugin\Transition\TransitionInterface;
use Drupal\mcapi\Entity\TransactionInterface;
use Drupal\mcapi\Entity\ExchangeInterface;
use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\State;
use Drupal\mcapi\Entity\Wallet;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\Entity\Type;
use Drupal\mcapi\Entity\Exchange;
use Drupal\Component\Utility\NestedArray;
use Drupal\user\EntityOwnerInterface;

//states are mutually exclusive //is it appropriate to use constants for plugin names?
const TRANSACTION_STATE_FINISHED = 'done';
const TRANSACTION_STATE_ERASED = 'erased';

//we could maybe do without these
const CURRENCY_TYPE_ACKNOWLEDGEMENT = 'acknowledgement';
const CURRENCY_TYPE_EXCHANGE = 'exchange';
const CURRENCY_TYPE_COMMODITY = 'commodity';

//negative numbers are used here, and positive numbers represetn uids in the db
const WALLET_ACCESS_OWNER =  'o';//this is replaced with a named user
const WALLET_ACCESS_EXCHANGE = 'e';
const WALLET_ACCESS_AUTH = '2';
const WALLET_ACCESS_ANY = '1';
const WALLET_ACCESS_USERS = 'u';

/**
 * implements hook_requirements().
 */
function mcapi_requirements($phase) {
  if ($phase == 'runtime') {
    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorage('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($route_name) {
  switch ($route_name) {
    case 'mcapi.admin':
      return t('The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital.');
    case 'mcapi.admin_currency_list':
      return implode(' ', array(
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.'),
        t('Retired currencies can no longer be used, but transactions are still visible.'),
        t('Only unused currencies can be deleted.'),
      ));
    case 'mcapi.admin.workflow':
      return implode(' ', array(
        t('Workflow transitions move transactions between states.'),
        t('Each transition presents the user with confirmation form, which is configured on this page')
      ));
  }
}

/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  module_load_include('inc', 'mcapi');
  return _mcapi_theme();
}

/**
 * implements hook_entity_view().
 * add a wallet summary view to wallet-enabled entities
 */
function mcapi_entity_view(&$build, $entity, $mode, $language) {
  //check the entity is of a type which can own a wallet.
  if ($quants = \Drupal::config('mcapi.wallets')->get('entity_types')) {
    $key = $entity->getEntityTypeId() .':'. $entity->bundle();
    if (array_key_exists($key, $quants) && $quants[$key]) {
      module_load_include('inc', 'mcapi');
      $build['wallets_summaries'] = mcapi_view_wallets_summaries($entity);
    }
  }
  else drupal_set_message('config mcapi.wallets is empty');
}


/**
 * Implements hook_form_alter();
 * Add a submit callback to ContentEntityForms for contentTypes which reference exchanges
 * to check for entities joining and leaving exchanges
 * Form_alter is rather a blunt instrument but it is the best available.
 * Would be better to use hook_entity_presave or postsave but the old values aren't available there
 */
function mcapi_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (array_key_exists('controller', $form_state) && $form_state->get('controller') instanceof \Drupal\Core\Entity\ContentEntityFormController) {
    $entity = $form_state->get('controller')->getEntity();
    form_load_include($form_state, 'inc', 'mcapi');
    $lookup = bundles_in_exchanges();
    $entity_type = $entity->getEntityTypeId();
    if (array_key_exists($entity_type, $lookup)) {
      if (array_key_exists($entity->bundle(), $lookup[$entity_type])) {
        array_unshift($form['actions']['submit']['#submit'], 'mcapi_exchanges_changed_submit');
      }
    }
  }
}

/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 * NOT CURRENTLY USED
 */
function mcapi_get_state_descriptions() {
  foreach (State::loadMultiple() as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}

/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  $perms = array(
    'create own wallets' => array(
      'title' => t('Create own wallets'),
      'description' => t('Users can create wallets up to the maximum number per user')
    ),
    'manage own exchanges' => array(
      'title' => t('Manage exchanges'),
      'description' => t('Accounting permissions in all exchanges of which the user is a member')
    ),
    'configure mcapi' => array(
      'title' => t('Configure community accounting'),
      'description' => t('Design and setup the accounting system')
    ),
    'manage mcapi' => array(
      'title' => t('Manage community accounting'),
      'description' => t('Suitable for accountants')
    )
  );
  if (\Drupal::config('mcapi.misc')->get('editable')) {
    $perms['edit transactions'] = array(
    	'title' => t('Edit transactions'),
      'description' => t('Use the Edit transition on transactions in your exchange. See config for details.')
    );
  }
  return $perms;
}

/**
 * implements hook_mail().
 * @todo remove this when we have rules
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transition') {
    $params += array(
      'user' => \Drupal::currentUser(),
      //'mcapi_transaction' => $transaction
    );
    $options = array('language' => $message['langcode'], 'sanitize' => FALSE);
    $message['subject'] =  \Drupal::Token()->replace($params['subject'], $params, $options);
    $message['body'][] =  \Drupal::Token()->replace($params['body'], $params, $options);
    $message['headers']['cc'] = $params['cc'];
  }
}



/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_entity_extra_field_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_entity_extra_field_info();
}



/**
 * Machine name callback
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 *
 * @todo is this still needed?
 */
function mcapi_currency_load($id) {
  return Currency::load($id);
}

/**
 * Helper function to populate a form widget's options with entity names
 *
 * @param string $entity_type_id
 *
 * @param array $data
 *   either entities of the given type, entity ids, or $conditions for entity_load_multiple_by_properties
 *
 * @return array
 *   The entity names, keyed by entity id
 */
function mcapi_entity_label_list($entity_type_id, array $data = array()) {
  if (empty($entities)) {
    $entities = \Drupal::entityManager()->getStorage($entity_type_id)->loadMultiple();
  }
  elseif(is_string(key($entities))) {
    $entities = entity_load_multiple_by_properties($entity_type_id, $data);
  }
  elseif(is_integer(reset($entities))) {
    $entities = \Drupal::entityManager()->getStorage($entity_type_id)->loadMultiple($entities);
  }
  $list = array();
  foreach ($entities as $entity) {
    $list[$entity->id()] = $entity->label();
  }
  //TODO sort these entities by weight but how?
  return $list;
}

/**
 * example implementation of hook_mcapi_transition().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param TransactionInterface $transaction
 * @param TransitionInterface $transition
 * @param array $context
 *   consists of op_plugin_id; config, the transition plugin configuration; old_state: the state of the transaction before the transition
 */
function mcapi_mcapi_transition(TransactionInterface $transaction, TransitionInterface $transition, array $context) {
  //TODO invoke rules hook
  if (\Drupal::currentUser()->id() == 1) drupal_set_message('Ran hook_transaction_operated');
  //example code
  if (@$context['config']['send']) {
    $recipients = array();
    //mail is sent to the user owners of wallets, and to cc'd people
    foreach (array('payer', 'payee') as $participant) {
      $recipients[] = User::load($transaction->{$participant}->entity->user_id())->mail->value;
    }
    //with multiple recipients we have to choose one language
    //just English for now bcoz rules will sort this out
    if ($recipients) {
      drupal_mail(
      'mcapi',
      'transition',
      implode(',', $recipients),
      'en',
      array(
      'mcapi' => $transaction,
      'cc' => $context['config']['cc'],
      'subject' => $context['config']['subject'],
      'body' => $context['config']['body']
      )
      );
    }
  }
}


/**
 * implements_hook_element_info().
 * @todo remove this
 */
function mcapi_element_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_element_info();
}

/**
 * process callback for worth form element
 * This single element processes multiple currencies as one value, like the checkboxes widget
 */
function mcapi_worth_element_process($element, FormStateInterface $form_state, $form) {
  form_load_include($form_state, 'inc', 'mcapi');
  return _mcapi_worth_element_process($element, $form_state, $form);
}


/**
 * process callback for mcapi_state form element
 *
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_entity_label_list('mcapi_state');
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_entity_label_list('mcapi_type');
  return $element;
}

/**
 * process callback for mcapi_currency_select form element
 *
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  $conditions = array();
  if ($element['#status']) {
    $conditions['status'] = TRUE;
  }
  if (empty($element['#options']) && !empty($element['#curr_ids'])) {
    //shows the intersection of all currencies and currencies provided
    $element['#options'] = array_intersect_key(
      mcapi_entity_label_list('mcapi_currency', $element['#curr_ids']),
      entity_load_multiple_by_properties('mcapi_currency', $conditions)
    );
  }
  elseif (empty($element['#options'])) {
    $element['#options'] = $element['#options'] = mcapi_entity_label_list('mcapi_currency', $conditions);
  }
  elseif ($element['#options'] == 'all') {
    $element['#options'] = mcapi_entity_label_list('mcapi_currency');
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}

/**
 * select_wallet element callbacks
 * these could all go in a different file
 */
/**
 * process callback for wallet_select element
 */
function mcapi_process_select_wallet($element, FormStateInterface $form_state) {
  $exchanges = array_keys(Exchange::referenced_exchanges());
  $element['#autocomplete_route_parameters'] = array('exchanges' => implode(',', $exchanges));
  return $element;
}

/**
 * value callback for wallet widget
 * takes from the autocomplete select_wallet field and returns an integer candidate wallet id.
 */
function form_type_select_wallet_value(&$element, $input, FormStateInterface $form_state) {
  if (empty($input)) return;
  if (is_numeric($input) && is_integer($input + 0)) {
    return $input;
  }
  //get the number after the last hash
  return substr($input, strrpos($input, '#')+1);
}

/**
 * element_validate callback for select_wallet
 * ensure the passed value is a wallet id, not of an intertrading wallet
 */
function local_wallet_validate_id(&$element, FormStateInterface $form_state) {
  $message = '';
  if (is_numeric($element['#value'])) {
    $wallet = Wallet::load($element['#value']);
    if (!$wallet) {
      $message = t('Invalid wallet id: @value', array('@value' => $element['#value']));
    }
    elseif($wallet->name->value == '_intertrading') {
      $message = t('You cannot trade with wallet #@value directly', array('@value' => $element['#value']));
    }
  }
  if ($message) {
    \Drupal::formBuilder()->setError($element, $form_state, $message);
  }
}

/**
 * element_prerender callback for select_wallet
 *
 * convert the #default value from a wallet id to the autocomplete format
 * ensure the autocomplete address is going to the right place
 */
function mcapi_prerender_wallet_field($element) {
  if (is_numeric($element['#default_value'])) {
    $wallet = Wallet::load($element['#default_value']);
    if ($wallet) {
      //this label contains the #id which is picked up by the value callback
      $element['#default_value'] = $wallet->label(NULL, FALSE);
    }
    else {
      drupal_set_message(t("Wallet @num does not exist", array('@num' => $element['#default_value'])), 'warning');
    }
  }
  return $element;
}

/**
 * implements hook_element_info_alter().
 * adds the 'balances' icon via css
 */
function mcapi_element_info_alter(&$items) {
  $items['toolbar']['#attached']['css'][] = drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css';
}

/**
 * field api default value callback
 * when creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @param ContentEntityInterface $entity,
 * @param array $field_definition,
 *
 * @return array
 *   The uuids of the exchanges of which the passed Entity is a member
 *
 * //TODO an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id(ContentEntityInterface $entity, $field_definition) {
  if ($entity->getEntityTypeId == 'user' && $entity->id() == 0)drupal_set_message('putting user 0 in default exchange. Prevent this!');
  $output = array();
  foreach (Exchange::referenced_exchanges(NULL, TRUE) as $exchange) {
    $output[]['target_uuid'] = $exchange->get('uuid')->value;
  }
  return $output;
}

/**
 * field api default value callback
 * TEMP...
 * when creating a new exchange, populate the currencies field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 *
 * @param ExchangeInterface $entity,
 * @param array $field_definition,
 * @param string $langcode
 *
 * @return array
 *   uuids whose keys I haven't understood yet
 */
function mcapi_default_currency_id(ExchangeInterface $exchange, $field_definition) {
  $output = array();
  //default currencies are the currencies of the exchanges of which the current user is a member
  foreach (exchange_currencies(Exchange::referenced_exchanges(NULL, TRUE)) as $currency) {
    $output[]['target_uuid'] = $currency->uuid;
  }
  return $output;
}

/**
 * entity reference field default_value callback for $transaction->exchange
 * Find an appropriate exchange, considering that intertrading hasn't been calculated yet
 *
 * @return uuid[]
 *   The uuid of the calculated exchange
 */
function mcapi_exchanges_default(TransactionInterface $entity, $field_definition) {
  $common = mcapi_wallet_common_exchanges($entity->payer->entity, $entity->payee->entity);
  if (!$common) {
    $common = $entity->payer->entity->in_exchanges();
  }
  $output[]['target_uuid'] = reset($common)->uuid->value;
  return $output;
}

//get all the exchanges common to 2 wallets
//this is only used in the above...
function mcapi_wallet_common_exchanges($wallet1, $wallet2) {
  if (!is_object($wallet2)){mdump($wallet1);mtrace();}
  return array_intersect_key($wallet1->in_exchanges(), $wallet2->in_exchanges());
}

/**
 * Determine whether the system architecture allows an entity to hold wallets.
 * Regardles of config
 * @param unknown $entity_type
 *   an entity OR entityType object
 *
 * @param string $bundle
 *   bundlename, if the first arg is an entityType
 *
 * @return boolean | string
 *   TRUE means the entity is an exchange, string is the fieldname
 */
function mcapi_wallet_owning_entity($entity, $bundle = '') {
  if ($entity instanceOf \Drupal\Core\Entity\Entity) {
    $entity_type = $entity->getEntityType();
    $bundle = $entity->bundle();
  }
  else $entity_type = $entity;
  $type_id = $entity_type->id();
  if ($type_id == 'user') return 'exchanges';
  elseif ($type_id == 'mcapi_exchange') return TRUE;
  //because simply $entity_type->getClass() instanceOf EntityOwnerInterface doesn't work
  $myReflection = new ReflectionClass($entity_type->getClass());
  if ($myReflection->isSubclassOf('\Drupal\user\EntityOwnerInterface')) {
    $fieldnames = Exchange::getEntityFieldnames();
    return @$fieldnames[$entity_type->id()];
  }
}

/**
 * implements hook_entity_insert()
 * give a new wallet to new entities, if the settings require
 */
function mcapi_entity_insert($entity) {
  //note that intertrading wallets are created in Exchange::postSave
  if (\Drupal::config('mcapi.wallets')->get('autoadd')) {
    if (mcapi_wallet_owning_entity($entity)) {
      $type = $entity->getEntityTypeId();
      //NB autoadd applies to ALL entity types or to none
      $maxes = \Drupal::config('mcapi.wallets')->get('entity_types');
      if ($max = @$maxes[$type .':'. $entity->bundle()]) {
        //no need to check what the max is, since this is the first wallet created for this entity
        Wallet::create(array(
          'entity_type' => $type,
          'pid' => $entity->id(),
          //default access controls are set automatically
        ))->save();
      }
    }
  }
  if ($entity->getEntityTypeId() == 'mcapi_wallet') {
    mcapi_save_wallet_index($entity->getOwner());
  }
}

/**
 * implements hook_ENTITY_TYPE_update().
 */
function mcapi_entity_update($entity) {
  if (mcapi_wallet_owning_entity($entity)) {
    mcapi_save_wallet_index($entity);
  }
}

function mcapi_save_wallet_index($owner) {
  //TODO move the deletion into here
  if ($wids = mcapi_get_wallet_ids($owner)) {
    db_delete('mcapi_wallet_exchanges_index')
      ->condition('wid', $wids)
      ->execute();
  }
  //update the exchanges index
  foreach ($wids as $wid) {
    $query = db_insert('mcapi_wallet_exchanges_index')->fields(array('wid', 'exid'));
    foreach (array_keys(Exchange::referenced_exchanges($owner)) as $exid) {
      $query->values(array('wid' => $wid, 'exid' => $exid));
    }
    $query->execute();
  }
}

/**
 * implements hook_entity_delete()
 * ensure any wallets belonging to the entity are moved to their parent's exchange
 * @todo this should be pre-deletion
 */
function mcapi_entity_delete($entity) {
  //see Exchange::preDelete();
  if (mcapi_wallet_owning_entity($entity)) {
    Wallet::orphan($entity);
  }
}

/**
 * implements hook_ENTITY_TYPE_delete().
 * updates the wallet exchanges index table when a wallet is deleted
 */
function mcapi_mcapi_wallet_delete($entity) {
  db_delete('mcapi_wallet_exchanges_index')->condition('wid', $entity->id())->execute();
}


/**
 * get all the currencies from (common to) the given exchanges, sorted
 * @param array $exchanges
 *
 * @param boolean $ticks
 *   filter out currencies with no exchange rate
 *
 * @param boolean $status
 *   filter out disabled currencies
 *
 * @return array
 *   the filtered currencies
 */
function exchange_currencies(array $exchanges, $ticks = FALSE) {
  $currencies = array();
  foreach ($exchanges as $exchange) {
    foreach ($exchange->get('currencies')->referencedEntities() as $currency) {
      if (!$ticks || $currency->ticks) {
        $currencies[$currency->id()] = $currency;
      }
    }
  }
  uasort($currencies, array('\Drupal\Component\Utility\SortArray', 'sortByWeightProperty'));
  return $currencies;
}


/**
 * developer-friendly wrapper around the wallet storage controller function, getOwnedWalletIds().
 *
 * @param Drupal\Core\Entity\ContentEntityInterface $entity
 *
 * @return array
 *   wallet ids belonging to the passed entity
 *
 * @todo put this as a static function in the Wallet
 */
function mcapi_get_wallet_ids(ContentEntityInterface $entity) {
  return \Drupal::EntityManager()->getStorage('mcapi_wallet')->getOwnedWalletIds($entity);
}

/**
 * implements hook_block_view_BLOCK_BASE_ID_alter
 * Add a links to the menu block, one for each exchange the current user is in.
 * The alternative, to create many links and give them all access control would be
 * rather expensive, I think
 *
 * @todo second opinion?
 */
function _mcapi_block_view_system_menu_block_alter(&$build, $block) {
  if($block->getPluginId() == 'system_menu_block:tools') {
    if (!array_key_exists('content', $build)) {
      $build['content'] = array();
    }
    foreach (Exchange::referenced_exchanges() as $exchange) {
      //does a menu link really require all of these properties
      $renderable = array(
      	'#theme' => 'menu_link',
        '#title' => $exchange->label(),
        '#href' => $exchange->url(),
        '#weight' => -100,
        '#localized_options' => array(),
        '#below' => array(),
        '#attributes' => array(),
        '#original_link' => array('menu_name' => 'tools'),//required by menu_block_view_system_menu_block_alter
      );
      array_unshift($build['content'], $renderable);
    }
    //TODO exchange admins links to their currency(s) OR a link to admin/accounting/currencies
  }
}

/**
 * implements hook_local_tasks_alter().
 * prevent the three fixed transaction display modes from being edited
 * this function will fail if mcapi is not heavier than field_ui module
 */
function mcapi_local_tasks_alter(&$tasks) {
  $names = array('certificate_mcapi_transaction', 'twig_mcapi_transaction', 'sentence_mcapi_transaction');
  foreach ($names as $name) {
    unset($tasks['field_ui.fields:field_display_'.$name]);
  }
}

/**
 * implements hook_entity_operation_alter();
 * prevent the transaction view modes from being tampered with
 */
function mcapi_entity_operation_alter(&$operations, $entity) {
  $ids = array(
    'mcapi_transaction.certificate',
    'mcapi_transaction.twig',
    'mcapi_transaction.sentence'
  );
  if (in_array($entity->id(), $ids)) $operations = array();
}

/**
 * Get all the wallet ids in given exchanges.
 * this can also be done with Wallet::filter() but is quicker.
 * maybe not worth it if this is only used once, in any case the index table is needed for views.
 * Each wallet owner has a required entity reference field pointing to exchanges.
 * The mcapi_wallet_exchanges_index is maintained by the WalletStorage entity
 *
 * @param array $exchange_ids
 *
 * @return array
 *   the non-orphaned wallet ids from the given exchanges
 */
function mcapi_wallets_in_exchanges(array $exchange_ids) {
  $query = db_select('mcapi_wallet_exchanges_index', 'w')
  ->fields('w', array('wid'));
  if ($exchange_ids) {
    $query->condition('exid', $exchange_ids);
  }
  return $query->execute()->fetchCol();
}

/**
 * Delete all transaction entities
 * For development only!
 * @todo move this to be a drush command
 */
function mcapi_wipeslate() {
  $conf = \Drupal::config('mcapi.misc');
  $controller = \Drupal::entityManager()->getStorage('mcapi_transaction');
  $entities = $controller->loadMultiple();
  $controller->delete($entities);
  echo 'all transactions deleted';
}

/**
 * Implements hook_hook_info().
 * @todo is it worth creating hook group and filename extension?
 */
function mcapi_hook_info() {
  $hooks = array(
    'mcapi_transaction_children',
    'mcapi_transaction_validate',
    'mcapi_transaction_alter',
    'mcapi_transition',
    //and all the entity hooks e.g
    'mcapi_wallet_update',
    'mcapi_wallet_delete'
    //...there are many
  );
  return array('group' => 'mcapi') + array_combine($hooks, $hooks);
}

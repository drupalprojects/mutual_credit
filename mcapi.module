<?php  // $Id: mcapi.module,v 1.1.2.6 2010/12/22 19:30:29 matslats Exp $: transactions.module,v 1.1.2.4 2009/10/14 10:03:54 matslats Exp $

include('mcapi.field.inc');

$controller_mod = variable_get('mcapi_controller', 'mcapi');
include(drupal_get_path('module', $controller_mod) .'/'. $controller_mod.'.controller');

define('MCPI_CURRENCY_UNDO_DELETE', 0);
define('MCPI_CURRENCY_UNDO_ERASE', 1);
define('MCPI_CURRENCY_UNDO_REVERSE', 2);

/**
 * @file
 * transactions can refer to up to 3 things:
 *  fieldable entity with one or more 'flows' in different currencies
 *  one or more of those entities with the same serial number
 *  a database transaction
 *
 *
 * Typical procedure might be
 * form validation
 *   //create the transaction object and save the extranneous fields
 *   //use drupal_alter to add any dependent transactions
 *   $transactions = array($transaction);
 *   drupal_alter('transactions', $transactions);
 *   transactions_insert($transactions, FALSE)
 *     hook_transaction_validate
 *     EntityController->insert($transactions, FALSE)
 * end form validation
 * form submission
 *   //use drupal_alter to add any dependent transactions
 *   $transactions = array($transaction);
 *   drupal_alter('transactions', $transactions);
 *   transactions_insert($transactions, TRUE);
 *     hook_transaction_validate
 *     EntityController->insert($transactions, TRUE)
 *     field_attach_insert('transaction', $transaction);
 *     //run hook_entity_insert
 * end form submission
 *
 */

//states are mutually exclusive
//the convention is that states > 0 are counted
define('TRANSACTION_STATE_FINISHED', 1);
define('TRANSACTION_STATE_ERASED', 0);
define('TRANSACTION_STATE_UNSAVED', NULL); //before the transaction ever reaches the db
define('TRANSACTION_BUILD_INFO_ARG', 0);


/**
 * implements hook_help()
 */
function mcapi_help($section, $arg) {
  switch ($section) {
    case 'admin/help#transaction':
      return t('Defines a contentType called transactions, manages them and does the accounting.');
    case 'admin/accounting':
      return '<p>'. t("This module, its development and implementations at !cforge,", array('!cforge' => l('Community Forge', 'http://communityforge.net')))  .' '.
        t("have been the full time commitment of one person since Spring 2008, and a second person since spring 2009.") . ' '.
        t("The results of this work are offered freely to all.") .'</p><p>'.
        t("We give all possible resources to this work, and live by reciprocal gifting as much as possible.") .' '.
        t("We look forward to the day when support is robust enough to pay staff and provide a reliable nonprofit public service.") .' '.
        t("Please consider supporting this work by:") . ' '.
        theme('item_list', array('items' => array(
          t("sending some scarce hard currency to the developer"),
          t("allying with us to build a global complementary currency ecosystem"),
          t("offering board and lodging for a month or two")
        )));
    case 'admin/accounting/record':
      return t('This is a base form provided for administration purposes only. For end-users, there are forms provided by other modules');
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  module_load_include('inc', 'mcapi');
  return mcapi_menu_inc();
}

/*
 * implements hook_forms
 */
function mcapi_forms($form_id, $args) {
  $forms['transaction_admin_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  return $forms;
}

function transaction_form($form, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  //the incoming transaction is either from $form_state, or from the build arguments or an empty object
  $transaction = isset($form_state['values']) ? (object)$form_state['values'] : (
    empty($form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]) ? new_transaction() : $form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]);
  _transaction_form($form, $form_state, $transaction);
  return $form;
}


/*
 * ctools plugin callback for editing a currency, determined by the ctools export_plugin
 * The form_id is actually ctools_export_ui_edit_item_form
 */
function mcapi_currency_form(&$form, &$form_state){
  form_load_include($form_state, 'inc', 'mcapi', 'currencies');
  $currency = isset($form_state['values']) ? (object)$form_state['values'] : 
    ($form_state['item']->data ? $form_state['item']->data : default_cur());
  //copy some settings from the default currency
  if (isset($currency->human_name)) {
    drupal_set_title( !empty($currency->human_name) ? $title = t("Edit currency '@name'", array('@name' => $currency->human_name)) : t('Declare currency') );
  }
  if (isset($form_state['values']['uid'])) {
    $currency->uid = $form_state['values']['uid'];
  }
  _mcapi_currency_form($form, $form_state, $currency);
}

/*
 * implements hook_hook_info
 */
function mcapi_hook_info() {
  //not sure why this was throught necessary
//  module_load_include('inc', 'mcapi');
  return array(
    //declare new transaction controllers
    'transaction_controller' => array(),
    //so any module can add validation to the transaction object
    'transactions_validate' => array(),
    //callbacks for determining access to the currency and aggregated stats
    'currency_access_callbacks' => array(),
    //declare permissions for transaction access control, per currency per operation
    'transaction_access_callbacks' => array(),
    //declare transaction states
    'mcapi_info_states' => array(),
    //declare transaction types
    'mcapi_info_types' => array(),
    //declare permissions to go into the community accounting section of the drupal permissions page
    'mcapi_info_drupal_permissions' => array(),
  );
}

/**
 * implements hook_permission
 * This hook can supply permissions that the module defines,
 */
function mcapi_permission() {
  return module_invoke_all('mcapi_info_drupal_permissions');
}

/*
 * implements mcapi hook_info_controller
 * the presence of this hook indicates there is a .controller file
 * with the name MODULE.controller
 */
function mcapi_transaction_controller(){}

/*
 * implements mcapi hook_info_states
 * DON"T call this hook directly as the keys will be lost. use mcapi_get_states()
 */
function mcapi_mcapi_info_states() {
  return array(
    TRANSACTION_STATE_FINISHED => array(
      'name' => t('Finished'),
      'description' => t('the last state of the workflow'),
      'default_access_callbacks' => array('mcapi_access_authenticated')
    ),
    TRANSACTION_STATE_ERASED => array(
      'name' => t('Undone'),
      'description' => t('marked deleted, but the transaction record remains'),
      'default_access_callbacks' => array()
    )
  );
}

/*
 * implements mcapi hook_info_types
 */
function mcapi_mcapi_info_types() {
  return array('default');
}

function mcapi_get_states($return_mode = 'full') {
  $states = array();
  foreach(module_implements('mcapi_info_states') as $module) {
    $function = $module . '_mcapi_info_states';
    $states += $function('states');
  }
  if ($return_mode == '#options') {//suitable for a dropdown
    foreach ($states as $key => $state) {
      $options[$key] = $state['name'];
    }
    return $options;
  }
  elseif ($return_mode == '#description') {
    foreach ($states as $key => $state) {
      $desc[] = $state['name'] .' - '. $state['description'] .'.';
    }
    return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
  }
  return $states;
}
//returns the available transaction types in an associative array
function mcapi_get_types() {
  foreach (module_invoke_all('mcapi_info_types') as $type) {
    $types[$type] = $type;
  }
  return $types;
}


/*
 * implements mcapi hook_mcapi_info_drupal_permissions
 * make permissions appear altogether on the permissions page
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency')
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    )
  );
}

/*
 * implements hook mcapi_permissions
 * each callback refers to 2 functions - itself and CALLBACK_views
 * Declare the access callbacks for (transactions in) currencies
 * each callback takes the following args
 * $transaction
 * $account
 * Multiple callbacks can be selected and access will be granted if any returns TRUE
 * TODO Update these callbacks in transaction_access_views_alter
 */
function mcapi_transaction_access_callbacks() {
  return array(
    'mcapi_xacc_participants' => t('the participants in the transaction'),
    'mcapi_access_authenticated' => t('Authenticated users'),
    'mcapi_access_accountant' => t("Accountants"),
    'mcapi_access_anyone' => t('General public')
  );
}

/**
 * special access function for transactions - NOT hook implementation
 * Grant view access to a transaction based on its state and the specified callback for that currency
 */
function transaction_view_access($transaction) {
  module_load_include('inc', 'mcapi');
  foreach ($transaction->worth[LANGUAGE_NONE] as $flow) {
    $callbacks = array_filter(currency_load($flow['currcode'])->transaction_access[$transaction->state]);
    //see hook_transaction_access_callbacks for a list of these functions
    foreach ($callbacks as $function) {
      if ($function($transaction)) return TRUE;
    }
  }
  return FALSE;
}

function transaction_undo_access($transaction) {
  module_load_include('inc', 'mcapi');
  foreach ($transaction->worth[LANGUAGE_NONE] as $item) {
    if (!currency_access('undo', $item['currcode'])) return FALSE;
  }
  return TRUE;
}

/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'transaction' => array(
      'template' => 'transaction',
      'pattern' => 'transaction__',
      'variables' => array(
        'transaction' => NULL,
        'view_mode' => 'certificate',
      )
    )
  ) + mcapi_theme_fields();
  return $items;
}


/**
 * Implements hook_entity_info()
 */
function mcapi_entity_info(){
  module_load_include('inc', 'mcapi');
  return mcapi_entity_info_inc();
}
//I don't believe this callback, part of the entity definition, has any purpose
function transaction_uri($transaction) {
  return array(
    'path' => 'transaction/' . $transaction->serial,
  );
}
function transaction_label($transaction){
  return t('Transaction #@serial', array('@serial' => $transaction->serial));
}
function currency_label($currency) {
  return $currency->human_name;
}

/**
 * menu callback
 * build a render array any number of transactions
 * compatible with $entity_info['view callback'] from entity module
 * first arg can be one or an array
 */
function transaction_view($transactions, $view_mode = 'certificate') {
  if (!is_array($transactions)) {
    $transactions = array($transactions->xid => $transactions);
  }
  if ($view_mode == 'sentence') {
    drupal_add_css('.transaction-sentence div{display:inline;}', array('type' => 'inline'));
  }
  entity_prepare_view('transaction', $transactions);
  //structure the transactions using serial numbers, assuming the first is always the main one
  $clusters = array();
  foreach($transactions as $transaction) {
    //render the fieldAPI fields.
    $transaction->additional = field_attach_view('transaction', $transaction, $view_mode);
    //$transactions must be keyed by xid if there is more than one
    //in preview mode this may not be the case
    //anyway it seems to work without
    if (!empty($transaction->xid)) {
      field_attach_prepare_view('transaction', array($transaction->xid => $transaction), $view_mode);
    }
    if (empty($clusters[$transaction->serial])) {
      $clusters[$transaction->serial] = $transaction;
    }
    else {
      $clusters[$transaction->serial]->children[] = $transaction;
    }
  }
  foreach ($clusters as $cluster) {
    $renderable[] = array(
      '#theme' => 'transaction',
      '#transaction' => $cluster,
      '#view_mode' => $view_mode,
    );
  }
  return $renderable;
}

/*
 * make the transaction variables into something which can be nicely themed
 */
function template_preprocess_transaction(&$variables) {
  $transaction = &$variables['transaction'];
  $variables['payer'] = format_username(user_load($transaction->payer));
  $variables['payee'] = format_username(user_load($transaction->payee));
  $variables['state'] = $transaction->state;
  $variables['recorded'] = format_date($transaction->created, 'medium');
  $variables['type'] = $transaction->type;
  //choose the transaction theme template based on the first currency of the transaction
  $flows = current($transaction->worth);
  $variables['theme_hook_suggestion'] = 'transaction__' . $flows[0]['currcode'];
  foreach (element_children($transaction->additional) as $fieldname) {
    $variables[$fieldname] = drupal_render($transaction->additional[$fieldname]);
    $variables['additional'][$fieldname] = $variables[$fieldname];//this is used for default theme implementation
  }
  $variables['children'] = array();
  if (!isset($transaction->children)) return;
  foreach ($transaction->children as $child) {
    $variables['children'] = transaction_view($child, 'sentence');
  }
}

// how else to get a list of tokens for including on form field descriptions?
function matslats_list_tokens($type1, $type2 = NULL) {
  $info = token_info();
  foreach(func_get_args() as $type) {
    foreach($info['tokens'][$type] as $tok => $data) {
      $tokens[] = "[$type:$tok]";
    }
  }
  return $tokens;
}


  //this runs every time a 'new_transaction()' is created
function new_transaction() {
  return (object) array(
    'xid' => 0,
    'payer' => NULL,
    'payee' => NULL,
    'creator' => $GLOBALS['user']->uid,
    'created' => REQUEST_TIME,
    'state' => TRANSACTION_STATE_UNSAVED,
    'type' => NULL,
    'extra' => array(),
    //'worth' => array('und'=> array(0 => array('currcode' => 'def_drup', 'quantity' => 0)))
  );
}

/*
 * wrapper around transactions_insert
 * take a transaction and derive any children
 * return the transaction, with ->children
 * boolean $really means whether this is a test insert or not.
 */
function transaction_insert_new($transaction, $really) {
  $transactions = array($transaction);
  //this is where the transaction is likely to acquire children, 
  //and serial numbers set by contrib modules
  drupal_alter('transactions', $transactions);

  transactions_insert($transactions, $really);
  return $transactions;
}

/*
 * INTERNAL API FOR MODULE DEVELOPERS
 *
 * These need to be better unified as regards exception handling
 * but I don't have much experience on that
 * for now, all validates must be done within try{}
 *
 * This is where we interface with the entity controller
 * array transactions_load($xids = array(), array('serial' => array(AB123, AB124), $clearcache);
 * try transactions_insert(&$transactions)
 * try transactions_undo($transaction)
 * try transaction_state($serials, $newstate);
 * array transaction_totals($uid, $currcode, $options)
 * //undocumented
 * transaction_load($serial)
 * transaction_delete($serial)
 *
 */

function transactions_load($xids = array(), $conditions = array(), $reset = FALSE) {
  $transactions = entity_load('transaction', $xids, $conditions, $reset);
  module_invoke_all('entity_load', $transactions, 'transaction');
  return $transactions;
}


/*
 * internal API function
 */
function transactions_insert(array $transactions, $really = FALSE) {
  //put all the transactions side by side ready for the entity controller to validate and insert
  module_invoke_all('transactions_validate', $transactions);
  entity_get_controller('transaction')->insert($transactions, $really);
  //we don't insert the fields if we are not $really saving
  if ($really) {
    foreach ($transactions as $transaction) {
      field_attach_insert('transaction', $transaction);
      module_invoke_all('entity_insert', $transaction, 'transaction');
    }
  }
}

function transactions_undo(array $transactions, $force = FALSE) {
  entity_get_controller('transaction')->undo($transactions);
  //depends on the undo mode
  if (variable_get('mcapi_controller_delete_mode', MCPI_CURRENCY_UNDO_REVERSE) == MCPI_CURRENCY_UNDO_DELETE) {
    foreach ($transactions as $transaction) {
      field_attach_delete('transaction', $transaction);
      module_invoke_all('entity_delete', $transaction, 'transaction');
    }
  }
}
//resave the transaction, but only change the state - this is not considered an update
function transaction_state(array $serials, $new_state, $really = FALSE) {
  $transactions = transactions_load(NULL, array('serial' => $serials));
  module_invoke_all('transactions_validate', $transactions);
  if (!$really) return;
  entity_get_controller('transaction')->state($serials, $new_state, $really);
}
//returns an object with properties
//->balance
//->gross_in
//->gross_out
//->count
function transaction_totals($uid, $currcode = NULL, $options = array()) {
  if (!$currcode) $currcode = key(currencies_load());
  $options += array(
    'states' => array(TRANSACTION_STATE_FINISHED),
  );
  //convert it to an object for cleaner syntax in php5
  $totals = (object)entity_get_controller('transaction')->sums($uid, $currcode, $options);
  //just out of interest (needed for intertrading) we'll store the smallest balances
  if (module_exists('intertrading_client') && $currcode == variable_get('intertrading_currcode', '')){
    save_smallest($totals->balance, $uid);
  }
  return $totals;
}

/*
 * API wrapper functions
 */

/**
 * load a cluster of transactions sharing a serial number
 * this is used to as a menu loader, so can't be in an inc file
 */
function transaction_load($serial) {
  static $serials = array();
  //the menu system alone may call this function several times in one page request
  if (empty($serials[$serial])) {
    //if this isn't done globally, entity_crud_get_info in the contributed 'entity' module, tries to load the controller without loading the file
    $transactions = transactions_load(array(), array('serial' => $serial));
    if (empty($transactions))throw new Exception(t('There is no transaction @serial', array('@serial' => $serial)));
    //take the first one off and make the rest its children, preserving their keys
    $transactions = array_reverse($transactions, TRUE);
    $transaction = array_pop($transactions);
    $transaction->children = $transactions;
    $serials[$serial] = $transaction;
  }
  return $serials[$serial];
}

function transactions_delete($transactions) {
  transactions_undo($transactions, MCPI_CURRENCY_UNDO_DELETE);
}


//deficit is an array keyed by by uid, ordered asc
function save_smallest($balance, $uid) {
  $deficits = variable_get('mcapi_deficit', array());
  $deficits[$uid] = $balance;
  sort($deficits);
  //save only the most extreme 3
  variable_set('mcapi_deficit', array_slice($deficits, 0, 3));
}

/*
 * validate callback for user id fields
 * borrowed from node_validate, where it really should have been a reusable function like this.
 * this is in the main module file where it can be found by both currency form and transaction form.
 */
function mcapi_validate_usernames(&$element, &$form_state) {
  $values = is_array($element['#value']) ? $element['#value'] : array($element['#value']);
  if (!array_filter($values)) return;
  foreach ($values as $value) {
    if (!is_numeric($value)) {
      $uid = user_load_by_name($value)->uid;
      if ($uid) {
        $element['#value'] = $uid;
        form_set_value($element, $uid, $form_state);
      }
      else {
        form_error($element, t('The username %name does not exist.', array('%name' => $value)));
      }
    }
  }
}
/*
 * return one currency object
 */
function currency_load($currcode) {
  $currencies = &drupal_static('currencies');
  if (empty($currencies))currencies_load();
  if (isset($currencies[$currcode])) {
    return $currencies[$currcode];
  }
  watchdog('mcapi', 'Nonexistent currency @currcode requested from list: @list',
    array('@currcode' => $currcode, '@list' => print_r($currencies, 1)));
}
/*
 * Load all the currencies from cache filter
 * then optionally return them filtered for which ones an account can use.
 */
function currencies_load($account = NULL, $refresh = FALSE) {
  $currencies = &drupal_static('currencies');
  if ($refresh) unset($currencies);
  if (empty($currencies)) {//first time this page request.
    if (!$refresh && $cache = cache_get('currencies')) {
      $currencies = $cache->data;
    }
    else {
      module_load_include('inc', 'mcapi', 'currencies');
      $currencies = currencies_load_all();
      cache_set('currencies', $currencies);
    }
  }
  if (empty($account)) return $currencies;
  module_load_include('inc', 'mcapi');
  $filtered = array();
  foreach ($currencies as $currcode => $currency) {
    if (currency_access('membership', $currcode, $account)) {
      $filtered[$currcode] = $currency;
    }
  }
  return $filtered;
}

/*
 * Implements variable module's hook_variable_info
 */
function mcapi_variable_info() {
  $vars['mcapi_controller'] = array(
    'type' => 'string',
    'title' => t('Transaction entity controller'),
    'default' => 'mcapi',
    'description' => t('The module that controls how the transactions are read and written to the database.'),
    'required' => TRUE,
  );
  return $vars;
}

/*
 * Implements ctools hook_ctools_plugin_api
 */
function mcapi_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi'),
  );
}
/*
 * Implements ctools hook_ctools_plugin_directory
 */
function mcapi_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/export_ui';//directory
  }
}
/*
 * Implements views hook_views_api
 */
function mcapi_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi') . '/views',
  );
}


/*
 * Bit of a one off, this one
 */
function mcapi_format_usernames($accounts) {
  foreach($accounts as $account) {
    $names[] = format_username($account);
  }
  return implode(' & ' ,$names);
}

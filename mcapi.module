<?php


use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\mcapi\Plugin\Field\FieldType\Worth;
use Drupal\Core\Utility\Token;

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//

define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {

    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorageController('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  $items['admin/accounting'] = array(
    'title' => 'Accounting',
    'description' => "Manage all aspects of your community's money system",
    'route_name' => 'mcapi.admin',
    'position' => 'right',
  );
  $items['admin/accounting/config'] = array(
    'title' => 'Other configuration',
    'description' => 'Miscellaneous settings which effect the system globally.',
    'route_name' => 'mcapi.admin_misc',
    'weight' => 20,
  );
  $items['admin/accounting/wallets'] = array(
    'title' => 'Wallets',
    'description' => 'Ownership, access control and auto-creation.',
    'route_name' => 'mcapi.admin_wallets',
    'weight' => 10,
  );
  $items['admin/accounting/currencies'] = array(
    'title' => 'Currencies',
    'description' => 'Each currency implies a set of values and a community of users who economic fortunes are intertwined.',
    'route_name' => 'mcapi.admin_currency_list',
  );
  $items['admin/accounting/exchanges'] = array(
    'title' => 'Exchanges',
    'description' => 'The groups, communities or marketplaces where transactions happen',
    'route_name' => 'mcapi.admin_exchange_list',
  );
  $items['admin/accounting/transactions'] = array(
    'title' => 'Transactions',
    'description' => 'Configuration around transaction states, types and operations.',
    'weight' => 2,
    'route_name' => 'mcapi.admin.transactions',
  );
  $items['admin/accounting/transactions/mass'] = array(
    'title' => 'Mass payments',
    'description' => 'Pay between one account and many.',
    'route_name' => 'mcapi.admin_mass',
  );
  $items['admin/accounting/transactions/operations'] = array(
    'title' => 'Configure workflow',
    'description' => 'Configure workflow and user experience for each transaction operation.',
    'weight' => 2,
    'route_name' => 'mcapi.admin.transactions.operations',
  );
  $items['admin/accounting/transactions/add'] = array(
    'title' => 'Record transaction',
    'description' => 'Log a transaction in the database',
    'route_name' => 'mcapi.transaction_admin',
  );

  return $items;
}

function mcapi_transaction_load($serial) {
  return current(entity_load_multiple('mcapi_transaction', array('serial' => $serial)));
}

/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($path, $arg) {
  switch ($path) {
    case 'admin/accounting':
      return t('The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital.');
    case 'admin/accounting/currencies':
      return implode(' ', array(
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.'),
        t('Retired currencies can no longer be used, but transactions are still visible.'),
      ));
      //@todo when hook_menu is removed take this out of help and put it on the page somehow
    case 'admin/accounting/transactions':
      //TODO how do we make this show at the top of a menu page without help module?
      module_load_include('inc', 'mcapi');
      $renderable = _workflow_help();
      return drupal_render($renderable);
      return implode(' ', array(
        t('Different transaction user stories can be configured here, although the actual structure has to be defined in code.')
      ));
    case 'admin/accounting/transactions/workflow':
      return implode(' ', array(
        t('The workflow is about moving transactions between states. This is always done through a form.'),
        t('The confirm forms are configured on this page.')
      ));
  }
}

/**
 * get a transaction operation plugin or array of all plugins
 *
 * @param string $op_name
 *   the plugin id of the operation
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 */
function transaction_operations($op_name = NULL) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_operation');
    foreach ($manager->getDefinitions() as $op => $info) {
      $plugins[$op] = $manager->createInstance($op);
    }
  }
  if ($op_name) return $plugins[$op_name];
  else return $plugins;
}
//shows the most common operations
function show_transaction_operations($view = TRUE) {
  $ops = transaction_operations();
  unset($ops['create']);
  if (!$view) unset($ops['view']);
  return $ops;
}


/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  module_load_include('inc', 'mcapi');
  return _mcapi_theme();
}

/**
 * implements hook_entity_view().
 * add a wallet summary view to the entity
 */
function mcapi_entity_view($entity, $mode, $language) {
  if ($wids = \Drupal::Entitymanager()->getStorageController('mcapi_wallet')->getWalletIds($entity)) {
    //@todo make this work on all entities
    module_load_include('inc', 'mcapi');
    $entity->content['wallet_balances'] = mcapi_view_wallets_balances($wids);
  }
}

/**
 * just gets the children and puts them side by side with the parent so they are easier to iterate through
 */
function mcapi_transaction_flatten($transaction) {
  $cluster = array($transaction);
  foreach ($transaction->children as $child) {
    $cluster[] = $child;
  }
  return $cluster;
}


/**
 * get all the transaction state entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The states, either full config entity objects, or just keys and names
 */
function mcapi_get_states($options = FALSE) {
  $states = entity_load_multiple('mcapi_state');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($states as $key => $state) {
      $pairs[$state->value] = $state->label;
    }
    return $pairs;
  }
  return $states;
}

/**
 * get all the transaction type entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The types, either full config entity objects, or just keys and names
 */
function mcapi_get_types($options = FALSE) {
  $types = entity_load_multiple('mcapi_type');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($types as $key => $type) {
      $types[$key] = $type->label;
    }
  }
  return $types;
}
/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 */
function mcapi_get_state_descriptions() {
  foreach (mcapi_get_states() as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'create own wallets' => array(
      'title' => t('Create own wallets'),
      'description' => t('Users can have as many wallets as they like.')
    ),
    'manage own exchanges' => array(
      'title' => t('Manage exchanges'),
      'description' => t('Accounting permissions in all exchanges of which the user is a member')
    ),
    'exchange helper' => array(
      'title' => t('Helper within an exchange'),
      'description' => t("Enhanced access within one's own exchanges")
    ),
    'configure mcapi' => array(
      'title' => t('Configure community accounting'),
      'description' => t('Design and setup the accounting system')
    ),
    'manage mcapi' => array(
      'title' => t('Manage community accounting'),
      'description' => t('Suitable for accountants')
    )
  );
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'operation') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  \Drupal::Token()->replace($params['subject'], $params, $options);
    $message['body'][] =  \Drupal::Token()->replace($params['body'], $params, $options);
    $message['headers']['cc'] = $params['cc'];
  }
}


/*
 * implements hook_field_extra_fields().
 */
function mcapi_field_extra_fields() {
  module_load_include('inc', 'mcapi');
  return _mcapi_field_extra_fields();
}

/**
 * Machine name callback
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 */
function mcapi_currency_load($id) {
  return entity_load('mcapi_currency', $id);
}

/**
 * get a context sensitive #options list of all the currencies (for one account)
 *
 * @param boolean $all
 *   FALSE to return only the currencies currentUser can access
 * @return array
 *   of currencies
 */
function mcapi_currency_list($all = TRUE) {
  if (!$all) {
    $currencies = exchange_currencies(referenced_exchanges());
  }
  if (empty($currencies)) {
    $currencies = entity_load_multiple('mcapi_currency');
  }
  $list = array();
  foreach ($currencies as $id => $currency) {
    if ($currency->status)$list[$id] = $currency->label();
  }
  return $list;
}

/**
 * return a list of exchanges from an entity_reference field in an entity
 *
 * @param ContentEntityInterface $entity
 *   any entity which has a reference field pointing towards mcapi_exchange entities
 * @return array
 *   of entities, keyed by exchange id
 *
 * @todo this should accept only ContentEntityInterface objects, but it fails when Drupal\user\Entity\User is passed
 */
function referenced_exchanges($entity = NULL) {
  if (is_null($entity)) {
    $entity = user_load(\Drupal::currentUser()->id());
  }
  if ($entity->entityType() == 'user') {
    $fieldname = 'field_exchanges';
  }
  else {
    module_load_include('inc', 'mcapi');
    $fieldname = get_exchange_entity_fieldnames($entity->entityType());
  }
  $exchanges = array();
  if ($fieldname) {
    foreach($entity->get($fieldname)->getValue() as $item) {
      //@todo one day we'll be able to just pull this array out rather than loading the entities ourselves
      $exchanges[$item['target_id']] =  entity_load('mcapi_exchange', $item['target_id']);
    }
  }
  //TEMP until entity_reference works
  return array_filter($exchanges);
  return $exchanges;
}

/**
 * get all the currencies from (common to) the given exchanges, sorted
 * @param array $exchanges
 */
function exchange_currencies(array $exchanges) {
  foreach ($exchanges as $exchange) {
    foreach ($exchange->get('field_currencies')->getValue() as $item) {
      $currency = mcapi_currency_load($item['target_id']);
      if ($currency->status) $currencies[$item['target_id']] = $currency;
    }
  }
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));
  return $currencies;
}

/**
 * Load currencies for a given user, or common to 2 given users
 * A list of all the currencies in the marketplaces of which the user is a member.
 *
 * @param AccountInterface $account
 * @param AccountInterface $account2
 * @return array
 *   of currencies
 */
function mcapi_get_available_currencies(AccountInterface $account = NULL, AccountInterface $account2 = NULL) {
  $exchanges = referenced_exchanges($account);
  if ($account2) {
    $exchanges = array_intersect($exchanges, referenced_exchanges($account2));
  }
  return exchange_currencies($exchanges);
}

/**
 * implements hook_mcapi_transaction_operated().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param TransactionInterface $transaction
 * @param array $context
 *   consists of op_plugin_id; config, the operation plugin configuration; old_state: the state of the transaction before the operation
 */
function mcapi_mcapi_transaction_operated($transaction, $context) {
  //TODO invoke rules hook
  //make a note that the proper way to trigger mails is via each operations' settings
}

/**
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_element_info();
}


/**
 * process callback for worths form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worths_element_process($element, &$form_state) {
  //the default value also tells us which currencies are available
  //if no defaults are set then all currencies should be present
  if (!isset($element['#default_value']) || empty($element['#default_value']) || $element['#preset']) {
    $element['#default_value'] = isset($element['#default_value']) ? (array)$element['#default_value'] : array();
  }
  if ($element['#mixed_mode'] || $element['#preset']) {
    //construct one widget for each default, each with its own currcode
    foreach ($element['#currencies'] as $currcode => $currency) {
      $element[$currcode]['#title'] = $currency->human_name;
      $element[$currcode]['#currcodes']= array($currcode);
      //some dispute about whether default_value should be a worths object or an array
      if (!is_object($element['#default_value'])){
        $element['#default_value'] = (object)$element['#default_value'];
      }
      $element[$currcode]['#default_value'] = $element['#default_value']->{$currcode};
    }
  }
  else {
    $keys = array_keys($element['#currencies']);
    $key = reset($keys);
    //need to better understand what is being passed as the top level element default value
    //in order populate the default properly
    $element[0] = array(
      '#title' => t('Worth'),
      '#currcodes' => $keys,
      '#default_value' => $element['#default_value']->$key,
    );
  }

  //now populate all the subwidgets with defaults
  foreach (element_children($element) as $delta) {
    $element[$delta]['#type'] = 'worth';
    $element[$delta]['#calc'] = $element['#calc'];
    $element[$delta]['#preset'] = $element['#preset'];
  }
  return $element;
}

/**
 * element_validate callback for worths field
 * just check that at least one value was submitted
 * @param array $element
 * @param array $form_state
 */
function mcapi_worths_element_validate($element, &$form_state) {
  if ($element['#required']) {
    $value_entered = FALSE;
    foreach (element_children($element) as $key) {
      $currency = entity_load('mcapi_currency', $element[$key]['currcode']['#value']);
      if ($element[$key][$currency->widget]['#value'] || $element[$key][$currency->widget]['#value'] === 0) {
        $value_entered = TRUE;
        break;
      }
    }

    if (!$value_entered) {
      $message = array_key_exists('#title', $element) ?
        t('!name field is required.', array('!name' => $elements['#title'])) :
        NULL;
      \Drupal::formBuilder()->setError($element, $form_state, $message);
    }
  }
}

/**
 * process callback for worth form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worth_element_process($element, &$form_state, $form) {
  $typedDataManager = \Drupal::typedData();
  if (!is_object($element['#default_value'])) {
  	$defaults = array('type' => 'field_item:worth', 'list' => TRUE);
    //TODO Gordon this isn't working.
    //$defaults need to be a \Drupal\Core\TypedData\DataDefinition\DataDefinitionInterface object
    //$element['#default_value'] = $typedDataManager->create($defaults, $element['#default_value']);
  }
  //the element is aware of a set of currcodes
  if (empty($element['#currcodes'])) {
    //best not rely on this, supply your own currencies that the user is permitted to use.
    //this defaults to all
    $element['#currcodes'] = array_keys(mcapi_get_available_currencies());
  }
  $element['currcode'] = array(
    '#title' => t('Currency'),
    '#type' => 'mcapi_currcodes',
    '#currcodes' => $element['#currcodes'],
    '#default_value' => array($element['#default_value']->currcode),
  );

  $element['currcode'] = mcapi_process_currcodes($element['currcode']);

  $parents =  $element['#parents'];
  $parents[] = 'currcode';

  $name = array_shift($parents);
  if (count($parents)) {
    $name .= '[' . implode('][', $parents) . ']';
  }

  $element['value'] = array(
    '#type' => 'value',
    '#default_value' => $element['#default_value']->value,
  );

  $currencies = entity_load_multiple('mcapi_currency', $element['#currcodes']);
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));

  foreach ($currencies as $currency) {
    $plugin = $currency->getWidgetPlugin();

    if (empty($element[$currency->widget])) {
      $element[$currency->widget] = array(
        '#title_display' => 'invisible',
      );
      if (count($element['#currcodes']) == 1) {
        $element[$currency->widget] += array(
          '#field_prefix' => $currency->prefix,
          '#field_suffix' => $currency->suffix,
        );
      }
      else {
        // Set up the dependent fields when the currency select box is changed.
        $element[$currency->widget]['#states'] = array(
          'visible' => array(
            ':input[name="' . $name . '"]' => array(
              array('value' => $currency->id()),
            ),
          ),
        );
      }

      $element[$currency->widget] = $plugin->formElement(array(0 => $element['#default_value']), 0, $element[$currency->widget], $form, $form_state);
    }
    else {
      // add the new additional currency.
      $element[$currency->widget]['#states']['visible'][':input[name="' . $name . '"]'][] = array('value' => $currency->id());
    }
  }
  return $element;
}

/**
 * element_validate callback for worth field
 * @param array $element
 * @param array $form_state
 */
function mcapi_worth_element_validate($element, &$form_state) {
//I don't like this...
  $currcode = empty($element['#value']['currcode']) ? $element['currcode']['#value'] : $element['#value']['currcode'];
if (!$currcode)drupal_set_message('problem validating worth element', 'error');

  if (!$currency = entity_load('mcapi_currency', $currcode)) {
    \Drupal::formBuilder()->setError($element, $form_state, t('%currcode is not a valid currency', array('%currcode' => $currcode)));
    return;
  }
  $plugin = $currency->getWidgetPlugin();

  $value = $element['#value'][$currency->widget];
  if (method_exists($plugin, 'asInteger')) {
    $value = $plugin->asInteger($value);
  }

  if ($element['#required'] && !$value && $value !== 0) {
    $elements['#required_but_empty'] = TRUE;
    if (isset($elements['#required_error'])) {
      \Drupal::formBuilder()->setError($element, $elements['#required_error']);
    }
    // A #title is not mandatory for form elements, but without it we cannot
    // set a form error message. So when a visible title is undesirable,
    // form constructors are encouraged to set #title anyway, and then set
    // #title_display to 'invisible'. This improves accessibility.
    elseif (isset($elements['#title'])) {
      \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
    }
    else {
      \Drupal::formBuilder()->setError($element);
    }
  }
  else {
    $values = array(
      'currcode' => $currcode,
      'value' => $value,
    );
    \Drupal::formBuilder()->setValue($element, $values, $form_state);
  }
}

/**
 * process callback for mcapi_state form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_get_states(TRUE);
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_get_types(TRUE);
  return $element;
}

/**
 * process callback for mcapi_currcodes form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  if (empty($element['#options']) && !empty($element['#currcodes'])) {
    $element['#options'] = array_intersect_key(mcapi_currency_list(), drupal_map_assoc($element['#currcodes']));
  }
  elseif (empty($element['#options'])) {
    $element['#options'] = $element['#options'] = mcapi_currency_list();
  }
  elseif ($element['#options'] == 'all') {
    $element['#options'] = mcapi_currency_list(TRUE);
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}


function form_type_local_wallets_value(&$element, $input, &$form_state) {
  if (empty($input)) return;
  //get the number from between the brackets
  preg_match('/.*\(([0-9]+)\)/', $input, $matches);
  return intval(array_pop($matches));
}
function local_wallet_validate_id(&$element, &$form_state) {
  $wallet = entity_load('mcapi_wallet', $element['#value']);
  foreach (referenced_exchanges() as $exchange) {
    if ($exchange->member($wallet)) return TRUE;
  }
}

/**
 * hide the exchange entity_reference selector if there is only one exchange
 * @todo convert these to hook_form_BASE_FORM_alter when the user entity settles down
 * @todo better still if there was a way of altering field instances we could ensure the cardinality was not greater than the number of entities to choose from, here and for mcapi_exchange->field_currencies
 */
function mcapi_form_user_register_form_alter(&$form, $form_state) {
  _mcapi_conceal_user_exchanges($form, $form_state);
}
function mcapi_form_user_form_alter(&$form, $form_state) {
  _mcapi_conceal_user_exchanges($form, $form_state);
}
function _mcapi_conceal_user_exchanges(&$form, $form_state) {

  if (count(referenced_exchanges()) < 2) {
    //setting #access to FALSE means the value is not submitted
    //$form['field_exchanges']['#access'] = FALSE;
    //$form['field_exchanges']['#attributes']['style'] = 'display:none;';
  }
}

/**
 * implements hook_entity_delete()
 * ensure any wallets belonging to the entity are moved to their parent's exchange
 * //@todo. in d8-alpha7 this fails with
 * Argument 1 passed to mcapi_entity_delete() must be an instance of EntityInterface, instance of Drupal\user\Entity\User given
 */
//function mcapi_entity_delete(EntityInterface $entity) {
function mcapi_entity_delete($entity) {
  if ($exchanges = referenced_exchanges($entity)) {
    $exchange = current($exchanges);//if the parent was in more than one exchange, this will effectively pick a random one.
    $wids = \Drupal::Entitymanager()->getStorageController('mcapi_wallet')->getWalletIds($entity);
    foreach (entity_load_multiple('mcapi_wallet', $wids) as $wallet) {
      //change the wallet names and change the parent to this entity's exchange
      $new_name = t(
        "Formerly !name's wallet: !label",
        array('!name' => $entity->label(), '!label' => $wallet->label())
      );
      $wallet->set('name', $new_name);
      $wallet->set('entity_type', 'mcapi_exchange');
      $wallet->set('pid', $exchange->id());
      $wallet->save();
    }
    drupal_set_message(t(
      "!name's wallets have been orphaned to exchange !exchange",
      array('!name' => $entity->label(), '!exchange' => l($exchange->label(), $exchange->uri()))
    ));
  }
}

/**
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, users can only be blocked, not deleted
 * TODO test this
 *
 * @param array $form
 * @param array $form_state
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/*
 * implements hook_toolbar
 * adds the 'balances' icon
 */
function mcapi_toolbar() {
  if (\Drupal::currentUser()->hasPermission('configure mcapi')) {
    drupal_add_css(drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css');
  }
}

/*
 * implements hook_config_translation_info().
 * Introduce dynamic translation tabs for translation of configuration.
 * //TODO
 * all config entities and field api fields have been added already
 */
function mcapi_config_translation_info(&$info) {
  //not sure how this works owing to lack of documentation but
  //I think rather than use this hook, we should use mcapi.config_translation.info
  //Here we might need to add states, types, operations
}
function mcapi_config_translation_info_alter(&$info) {
  echo 'mcapi_config_translation_info_alter';
  //print_r($info);
  //die();
}

/*
 * implements hook_config_translation_type_info_alter().
 * Associative array of configuration type definitions keyed by schema type names. The elements are themselves array with information about the type.
 * @param array $definitions
 *
 */
function mcapi_config_translation_type_info_alter(&$definitions) {
  //This has never been called as far as I can tell...
  echo 'mcapi_config_translation_type_info_alter'; print_r($definitions);die();
}


/**
 * field api default value callback
 * when creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @return
 *   an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id($entity, $field_definition, $langcode) {
  $output = array();
  foreach (referenced_exchanges() as $exchange) {
    $output[]['target_uuid'] = $exchange->get('uuid')->value;
  }
  drupal_set_message('a bug in alpha8 prevents more than one default entityreference field widget value from showing.');
  return $output;
}

/**
 * field api default value callback
 * TEMP...
 * when creating a new exchange, populate the currencies field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @return
 *   an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_currency_id($entity, $field_definition, $langcode) {
  $output = array();
  //temporary until we work out what the default should be.
  $output[]['target_uuid'] = entity_load('mcapi_currency', 'credunit')->get('uuid');

  drupal_set_message('a bug in alpha8 prevents more than one default entityreference field widget value from showing.');
  return $output;
}

/*
 * implements hook_user_create()
 * give a new wallet to every user
 */
function mcapi_user_insert($account) {
  $config = \Drupal::config('mcapi.wallets');
  if (!$config->get('unique_names') && $name = $config->get('autoadd_name')) {
    entity_create('mcapi_wallet', array(
      'name' => $name,
      'entity_type' => 'user',
      'pid' => $account->id(),
      'access_view' => 'dunno',
      'access_payee' => 'dunno',
      'access_payer' => 'dunno',
    ))->save();
  }
}

/**
 * get the entity from a Request object, whatever the entitytype
 * this is quite hacky
 *
 * @param Request $request
 * @return EntityInterface object
 */
function mcapi_request_get_entity($request) {
  foreach ($request->attributes->get('_route_params') as $key => $value) {
    if (substr($key, 0, 1) == '_')continue;
    return $value;
  }
}

/**
 *
 * implements hook_mcapi_transaction_pre_validate().
 * Add transactions to the children property
 * DEV PURPOSES ONLY
 *
 * @param TransactionInterface $transaction
 */
function mcapi_mcapi_transaction_children(TransactionInterface $transaction) {
  //get a wallet belonging to the current exchange
  $wids = mcapi_get_wallet_ids(entity_load('mcapi_exchange', $transaction->get('exchange')->value));
  if (!$wids) return;
  drupal_set_message('Time to test hook_mcapi_transaction_pre_validate');
  //but we can't do it until we know how to populate a worths field
  //get the first 2 wallets

  $extra = entity_create('mcapi_transaction', array(
    'payer' => $transaction->get('payer')->value,
    'payee' => current($wids),
    'worths' => array('credunit' => array('currcode' => 'credunit', 'value' => 60)),
    'type' => 'auto'
  ));
  return array($extra);
}

/**
 * developer-friendly wrapper around the wallet storage controller function, getWalletIds().
 * @param EntityInterface $entity
 * @return array
 *   wallet ids belonging the to the passed entity
 */
function mcapi_get_wallet_ids(EntityInterface $entity) {
  return \Drupal::EntityManager()->getStorageController('mcapi_wallet')->getWalletIds($entity);
}
/*
 * implements hook_block_view_BLOCK_BASE_ID_alter
 * Add a links to the menu block, one for each exchange the current user is in.
 * The alternative, to create many links and give them all access control would be
 * rather expensive, I think
 * @todo second opinion, GORDON?
 */
function _mcapi_block_view_system_menu_block_alter(&$build, $block) {
  if($block->getPluginId() == 'system_menu_block:tools') {
    if (!array_key_exists('content', $build)) {
      $build['content'] = array();
    }
    foreach (referenced_exchanges() as $exchange) {
      //does a menu link really require all of these properties
      $uri = $exchange->uri();
      $renderable = array(
      	'#theme' => 'menu_link',
        '#title' => $exchange->label(),
        '#href' => $uri['path'],
        '#weight' => -100,
        '#localized_options' => array(),
        '#below' => array(),
        '#attributes' => array(),
        '#original_link' => array('menu_name' => 'tools'),//required by menu_block_view_system_menu_block_alter
      );
      array_unshift($build['content'], $renderable);
    }
    //@todo exchange admins links to their currency(s) OR a link to admin/accounting/currencies
  }
}


<?php  // $Id: mcapi.module,v 1.1.2.6 2010/12/22 19:30:29 matslats Exp $: transactions.module,v 1.1.2.4 2009/10/14 10:03:54 matslats Exp $

/**
 * @file
 * transactions and currencies are fieldable entities, balances & other stats are in a cache table exposed to views.
 *
 * This .module file contains only the hooks and functions which might be called when the module is passive
 * If the module is doing anything requiring mutual_credit functionality as generating a block or a page, the inc is included
 *
 * NOTES ON THE TRANSACTION QUANTITY
 * Quantity is stored as a decimal in the DB for easy calculation
 * The transaction object stores the amount as a decimal fraction
 * In preprocessing  an hour currency the decimal is multiplied by 0.6 to become hours:minutes,
 * The theme_money function then attaches the icon or currency name
 *
 *
 *
 */


//states are mutually exclusive
define ('TRANSACTION_STATE_FINISHED', 0);
define ('TRANSACTION_STATE_ERASED', -1);
define ('TRANSACTION_STATE_VALIDATING', -2);


/**
 * implements hook_help()
 */
function mcapi_help($section) {
  switch ($section) {
    case 'admin/help#transaction':
      return t('Defines a contentType called transactions, manages them and does the accounting.');
    case 'admin/accounting/acknowledgements':
      return '<p>'. t("This module, its development and implementations at !cforge,", array('!cforge' => l('Community Forge', 'http://communityforge.net')))  .' '.
        t("have been the full time commitment of one person since Spring 2008, and a second person since spring 2009.") . ' '.
        t("The results of this work are offered freely to all.") .'</p><p>'.
        t("We give all possible resources to this work, and live by reciprocal gifting as much as possible.") .' '.
        t("We look forward to the day when support is robust enough to pay staff and provide a reliable nonprofit public service.") .' '.
        t("Please consider supporting this work by:") . ' '.
        theme('item_list', array('items' => array(
          t("sending some scarce hard currency to the developer"),
          t("allying with us to build a global complementary currency ecosystem"),
          t("offering board and lodging for a month or two")
        )));
      case 'admin/accounting/record':
        return t('This is a base form provided for administration purposes only. For end-users, there are forms provided by other modules');
      case 'user/%/transactions_list':
        return t("This page isn't intended for end users. It merely demonstrates the API call 'statement'.");
  }
}

/*
 * Needed for the views 2 module
 */
function mcapi_views_api() {
  return array(
    'api' => '3.0-alpha1', //TODO update this to v3
    'path' => drupal_get_path('module', 'mcapi') .'/views',
  );
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  module_load_include('inc', 'mcapi');
  return mcapi_menu_inc();
}
function mcapi_menu_alter(&$items) {
  foreach (array_keys($items) as $key) {
    //we don't need to see the page for arranging the bundle fields,
    if (substr($key, 0, 41) == 'admin/accounting/transaction/edit/display' || substr($key, 0, 38) == 'admin/accounting/currency/edit/display') {
      unset($items[$key]);
    }
  }
  unset($items['admin/accounting/transaction/edit/display']);
  unset($items['admin/accounting/currency/edit/display']);
  //but we do want to manage the fields for two entity types on one page.
  $items['admin/accounting/currency/edit/fields']['title'] = 'Currency fields';
  $items['admin/accounting/transaction/edit/fields']['title'] = 'Transaction fields';
}

/*
 * implements hook_forms
 */
function mcapi_forms($form_id, $args) {
  if (empty($args[0]->xid)) {
    $args[0] = new transaction;
  }
 
  $forms['transaction_admin_form'] = array(
    'callback' => 'transaction_form',
    'callback arguments' => $args
  );
  return $forms;
}

/*
 * hook for modules to declare new transactions types and states
 */
function mcapi_hook_info() {
  return array(
    'transaction_info' => array()
  );
}

function mcapi_transaction_info($prop) {
  $info = array(
    'states' => array(
      'unset' => t('Unset'),//this should never reach the database
      TRANSACTION_STATE_FINISHED => t('Finished'),
      //TRANSACTION_STATE_ERASED => t('Erased'), //internal use only
      //TRANSACTION_STATE_VALIDATING => t('Validating') //internal use only
    ),
    //access needs to have the same array keys as 'states'
    'access' => array(
      TRANSACTION_STATE_FINISHED => 'mcapi_access_finished',
      TRANSACTION_STATE_ERASED => 'mcapi_access_erased',
      TRANSACTION_STATE_VALIDATING => 'mcapi_access_validating',
    ),
    'types' => array(
      'unspecified'
    ),
    //this is experimental
    'controllers' => array(
      'default'
    )
  );
  return $info[$prop];

}

/**
 * implements hook_permission
 * This hook can supply permissions that the module defines,
 */
function mcapi_permission() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t('Use unrestricted currencies'),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency'),
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    ),
  );
}

/**
 * special access function for transactions - NOT hook implementation
 * $ops can be array('view', 'update', 'erase')
 * User 1 cannot update or delete if the currency type doesn't allow
 */
function transaction_access($op, $transaction, $account = NULL) {if (!$transaction)ddebug_backtrace();
  static $states;
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $currency = currency_load($transaction->cid);
  if (!$states) {
    $states = module_invoke_all('transaction_info', 'access');
  }
  $function = $states[$transaction->state];
  return $function($op, $transaction, $account, $currency);
}

function mcapi_access_finished($op, $transaction, $account, $currency) {
  $participated = $account->uid == $transaction->payee_uid || $account->uid == $transaction->payer_uid;
  $owner = $transaction->creator == $account->uid;
  $accountant = user_access('manage all transactions');
  switch ($op) {
    case 'view'://users can always view their own pages
      switch ($currency->extra['privacy']) {
        case 0: return $participated;
        case 1: return $participated || $accountant;
        case 2: $callback = $currency->extra['access_callback'];
          return $callback('view', $currency, $GLOBALS['user']->uid);
        case 2: return $GLOBALS['user']->uid;
        case 3: return TRUE;
    }
    case 'update':
      if ($currency->extra['update_mode'] < 1) return;
      switch ($currency->extra['user_editable_mode']) {
        case 0:
        case 1:
        case 2: return $accountant;
        case 3: return $accountant || $participated;
      }
    case 'erase':
      if ($currency->extra['delete_mode'] < 1) return;
      switch($currency->extra['user_editable_mode']) {
        case 0: return $accountant;
        case 1: return $accountant;
        case 2: return $accountant;
        case 3: return $accountant || $participated;
      }
  }
}

function mcapi_access_erased($op, $transaction, $account, $currency) {
  switch ($op) {
    case 'view':
      return user_access('manage all transactions');
    }
}
function mcapi_access_validating($op, $transaction, $account, $currency) {
  return $GLOBALS['user']->uid == $transaction->creator;
}

/*
 * determine whether a user has permission to use/edit a currency
 * This could get rather complicated, and vary from system to system
 * Right now 
 * 
 */
function currency_access($op, $currency, $uid = NULL) {
  if (!$currency) {ddebug_backtrace();return FALSE;}
  
  if (empty($uid)) $uid = $GLOBALS['user']->uid;
  switch ($op) {
    case 'edit':
      return $uid == $currency->uid || user_access('configure all currencies');
    case 'view'://which is to say, view transactions in
      switch($currency->extra['privacy']) {
        case 0: return TRUE;
        case 1: return currency_access('use', $currency, $uid);
        case 2: return NULL; //can't be calculated here
        case 3: return NULL;
      }
      //I"m not yet sure exactly what a user of the currency is?
      //does it denote the right to use, which is thus far not stored in the db
      //or does it denote that user has used?
    case 'use':
    case 'initiate':
      $function = $currency->extra['access_callback'];
      return $function == 'user_access' ? user_access('transact', user_load($uid)) : $function($op, $currency, $uid);
  }
}
/*
 * determines which currencies a user can use
 */
function currency_choose($op, $uid) {
  $currencies = currencies_load();
  foreach ($currencies as $currency) {
    if (currency_access($op, $currency, $uid)) {
      $currencies[$currency->cid] = $currency;
    }
  }
  return $currencies;
}
function currency_select($currencies) {
  foreach ($currencies as $currency) {
    $selection[$currency->cid] = $currency->name;
  }
  return $selection;
}

/*
 * callback function for currency usage
 * viral spread means that anyone can use the currency, but only after someone has traded with them first.
 * So this function just returns true for 'initiate' if the user created or has used the currency
 * $ops can be
 * 'view' meaning view transactions in that currency
 * 'initiate' meaning start transactions in that currency
 * 'use' meaning you can have a balance
 */
function currencies_access_viral($op, $currency, $uid) {
  //return all the currencies which the user has ever used, or created
  if ($currency->uid == $uid || $op == 'use') return TRUE;
  if ($op == 'initiate' || $op == 'view') {
    return db_query('SELECT xid FROM mcapi_transactions WHERE payer_uid = :payer or payee_uid = :payee',
       array(':payer' => $uid, ':payee' => $uid)
    )->execute()->fetchField();
  }
}


/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $path .='/theme';
  $items = array(
    'transaction' => array(
      'template' => 'transaction',
      'pattern' => 'transaction__',
      'path' => $path,
      'variables' => array(
        'transaction' => NULL,
        'view_mode' => 'certificate',
      )
    ),
    'balances' => array(
      'template' => 'balances',
      'path' => $path,
      'variables' => array(
        'balances' => array() //array with cid for keys
      )
    )
  );
  return $items;
}

/*
 * This function might merit a 'mode' later on
 * $quantity should be a float, integer, array or string - it matters which
 */
function mcapi_format_money($quantity, $cid) {
  $currency = currency_load($cid);
  $subdivision = NULL;
  //the static variable saves processing the icon every time
  $formats = &drupal_static(__FUNCTION__);
  if (!isset($formats[$cid])) {
    if (strpos($currency->format, '@icon') !== FALSE) {
      foreach($currency->field_image as $lang) {
        foreach ($lang as $props) {
          $props['path'] = $props['uri'];
          continue 2;
        }
      }
    }
    $formats[$cid] = str_replace('@icon', isset($props) ? theme('image', $props) : '', $currency->format);
  }
  switch (gettype($quantity)) {
    case 'array': 
      $integer = array_shift($quantity);
      $subdivision = array_shift($quantity);
      break;
    case 'string':
      $integer = $quantity;
      break;
    default:
      $integer = abs(intval($quantity));
      if ($currency->divisions) {
        $fraction = fmod($quantity, 1) * 100;
        if (is_array($currency->divisions)) {
          $subdivision = $currency->divisions[$fraction];
        }
        else $subdivision = $fraction;
      }
    }
  return strtr(
    $formats[$cid],
    array(
      '@minus' => $quantity < 0 ? '-' :'',
      '@integer' => $integer,
      '@subdivision' => $subdivision
    )
  );
}


function template_preprocess_balances(&$vars) {
  $currencies = currencies_load();
  foreach ($vars['balances'] as $cid => $amounts) {
    $vars['currencies'][$cid] = $currencies[$cid];
    foreach ($amounts as $key => $quantity) {
      if ($key != 'count') {
        $vars['balances'][$cid][$key] = mcapi_format_money($quantity, $cid);
      }
    }
  }
}

/*
 * Implements hook_user_view
 */
function mcapi_user_view($account) {
  $balances = transaction_controller('get_cache', $account->uid);
  $account->content['mcapi'] = array(
    '#title' => t('Monetary activity'),
    '#type' => 'user_profile_category',
    'balances' => array(
      '#theme' => 'balances',
      '#title' => t('Balances'),
      '#balances' => $balances,
    )
  );
}


/**
 * Implements hook_entity_info()
 */
function mcapi_entity_info(){
  module_load_include('inc', 'mcapi');
  return mcapi_entity_info_inc();
}

function transaction_uri($transaction) {
  return array(
    'path' => 'transaction/' . $transaction->xid,
  );
}
function transaction_label($transaction){
  return $transaction->description;
}
function currency_label($currency) {
  return $currency->name;
}


/**
 * load a single transaction, from the $xid
 * this is used to as a menu loader, so can't be in an inc file
 */
function transaction_load($xid) {
  $transaction = array_pop(transaction_controller('load', array($xid)));
  return $transaction;
}

function currency_load($cid = NULL) {
  $currencies = &drupal_static('currencies');
  if (!$currencies) {
    $currencies = refresh_currs();
  }
  return $currencies[$cid];
}
function currencies_load() {
  $currencies = &drupal_static('currencies');
  if (!$currencies) {
    $currencies = refresh_currs();
  }
  return $currencies;
}
function refresh_currs(){
  $currencies = &drupal_static('currencies');
  if (!$currencies) {
    $currencies = currency_controller('load', FALSE);
    cache_set('currencies', $currencies);
  }
  return $currencies;
}



/*
 * takes an array of objects, with the nid as array keys and returns an array with just the titles
 * for preparing form field select options
 * Seems a bit random, but there you go...
 */
function mcapi_title_selector($objects, $title_key, $zero_val = 'unspecified') {
  $options = array();
  if ($zero_val && count($objects) > 1) {
    $options[] = $zero_val;
  }
  foreach ($objects as $id => $object) {
    if (is_array($object)) {
      $options[$id] = $object[$title_key];
    }
    else {
      $options[$id] = $object->$title_key;
    }
  }
  return $options;
}

/**
 * Implements hook_image_default_styles().
 */
function mcapi_image_default_styles() {
  return array(
    'curr_icon' => array(
      'effects' => array(
        array(
          'name' => 'image_scale',
          'data' => array('width' => 16, 'height' => 16, 'upscale' => 0),
          'weight' => 0,
        ),
      ),
    )
  );
}


/**
 * build a render array for the transaction
 * not sure if this is needed
 */
function transaction_view($transaction, $view_mode = 'certificate') {
  //this is almost certainly a full page view, so I dare to set the title here
  $page_title = t('Transaction Certificate #@xid', array('@xid' => $transaction->xid));
  drupal_set_title($page_title);

  // This is only needed if there are fields on the transaction entity
  field_attach_prepare_view('transaction', array($transaction->xid => $transaction), 'default');

  entity_prepare_view('transaction', array($transaction->xid => $transaction));
  $build = array(
    '#theme' => 'transaction',
    '#transaction' => $transaction,
    '#view_mode' => $view_mode,
  );

  if (!empty($node->nid) && !($view_mode == 'certificate')) {
    $build['#contextual_links']['transaction'] = array('transaction', array($transaction->xid));
  }
  return $build;
}

/*
 * make the transaction variables into something which can be nicely themed
 */
function template_preprocess_transaction(&$arguments) {
  $transaction = $arguments['transaction'];

  $arguments['theme_hook_suggestion'] = 'transaction__' . $transaction->cid;
  $arguments += array(
    'description' => $transaction->description,
    'payer' => theme('username', array('account' => user_load($transaction->payer_uid))),
    'payee' => theme('username', array('account' => user_load($transaction->payee_uid))),
    'amount' => mcapi_format_money($transaction->quantity, $transaction->cid),
    'state' => $transaction->state,
    'recorded' => format_date($transaction->created, 'medium'),
    'type' => $transaction->type
  );
}

// this shouldn't be necessary, but how else to get a dynamic list of tokens?
function mcapi_get_tokens() {
  module_load_include('tokens.inc', 'mcapi');
  $info = mcapi_token_info();
  $markers = array_keys($info['tokens']['transaction']);
  $tokens = array();
  foreach ($markers as $token) {
    $tokens[] = "[transaction:$token]";
  }
  return implode(', ', $tokens);
}

/*
 * implements hook_query_TAG_alter
 * the saved view adds the tag 'transaction_access'
 * this modifies the query only to show the transactions visible to the user.
 * in practice, this means filtering by currency firstly
 * but currencies with view control based on who traded is more complicated
 */
function mcapi_query_transaction_access_alter(&$query) {
  $uid = $GLOBALS['user']->uid;
  //what currencies can the current user see?
  $currencies = currency_choose('view', $uid);
  $eachcurrency = db_or();
  foreach ($currencies as $currency) {
    switch ($currency->extra['privacy']) {
      case 1: //show only transactions in currencies that authenticated user can see
        if (!$GLOBALS['user']->uid) continue;
        //if you are logged in, then its the same as if there were no restrictions
      case 0: //in effect, no restrictions
        $eachcurrency->condition('cid', $currency->cid);
        break;
      case 2: //show only transactions in currencies where I have a cached balance
        $cached = transaction_controller('get_cache', $uid);
        if (isset($cached[$currency->cid]) || user_access('manage all transactions')) {
          $eachcurrency->condition('cid', $currency->cid);
        }
        break;
      case 3: //participants, accountant and user 1
        if (!user_access('manage all transactions')) continue;
        //and if you do have permission, then that's like privacy being 4, for this currency.
      case 4: //only participants
        $eachcurrency->condition(db_and()
          ->condition('cid', $currency->cid)
          ->condition(db_or()
            ->condition('payer_uid', $uid)
            ->condition('payee_uid', $uid)
            ->condition('uid', $uid)
          )
        );
    }
  }
  $query->condition($eachcurrency);
}

/*
 * Callback to help build transaction entity from $form_state
 */
function transaction_entity_builder($entity_type, $entity, $form, &$form_state) {
  $entity->description = isset($form_state['values']['description']) ?  $form_state['values']['description'] : t('no description given');
  $entity->state = isset($form_state['values']['state']) ?  $form_state['values']['state'] : TRANSACTION_STATE_FINISHED; //shouldn't really be omitted
  $entity->creator = isset($form_state['values']['creator']) ?  $form_state['values']['creator'] : $GLOBALS['user']->uid;
  $entity->created = REQUEST_TIME;
}


/*
 * form submit callback from the base transaction form, hence used by all forms
 * hence must be in .module file
 * this is what actually saves the data
 * $form_state['#transaction'] was created in the validation stage
 */
function transaction_all_submit($form, &$form_state) {
  //if (!empty($form_state['rebuild'])) return;
  $transaction = transaction_controller('save', $form_state['#transaction'], TRUE);
  if ($transaction) {
    field_attach_submit('transaction', $transaction, $form, $form_state);
  }
}

/*
 * this creates a nice default object, nicer than 'new stdClass'
 * but should I go ahead put a load of methods in here?
 * and how should this object be extended with other variables?
 * is there some kind of hook
 */
class currency {
  //these fields correspond to the datbase fields, but what to do with the fields which live serialized in $data?
  //and why use this to create objects when the entitycontroller fetches existing objects from the database result?
  //should this be in the entity controller?
  //could do with some advice
  public $cid;
  public $name;
  public $format;
  public $divisions_conf;
  public $extra = array();
  public $uid;

  //this runs every time a 'new currency' is created
  //but what about when the currency is loaded from the db
  public function __construct(){
    $this->uid = $GLOBALS['user']->uid;
  }
}
class transaction {
  //these fields correspond to the datbase fields, but what to do with the fields which live serialized in $data?
  //and why use this to create objects when the entitycontroller fetches existing objects from the database result?
  //should this be in the entity controller?
  //could do with some advice
  public $xid;
  public $description;
  public $payer_uid;
  public $payee_uid;
  public $cid;
  public $quantity;
  public $type;
  public $state;
  public $extra = array();
  public $creator;
  public $created;
  public $modifer;
  public $modified;

  //this runs every time a 'new currency' is created
  //but what about when the currency is loaded from the db
  public function __construct(){
    $this->creator = $GLOBALS['user']->uid;
    $this->state = 'unset';//this isn't one of the declared states and should cause an error if saved
    $this->type = 'unspecified';
  }
}

/*
 * INTERNAL API FOR MODULE DEVELOPERS
 * entity controllers must work comply
 *
 * This is where we interface with the entity controller
 * array transaction_controller('load', array(94), $conditions)
 * object transaction_controller('validate', $transaction)
 * object transaction_controller('save', $transaction)
 * array transaction_controller('get_cache', $uid)
 * array transaction_controller('statement', $uid, $from, $to)
 * NULL transaction_controller('erase', $transaction)
 * int transaction_controller('count', $conditions)
 * and
 * array currency_controller('load', array(94), $conditions)
 * array currency_controller('save', $transaction)
 * NULL currency_controller('delete', $transaction) //only if there are no transactions left
 *
 */

//all this business with func_get_args is a bit horrible as it means, I think, we can't pass references.
//so all calls to these functions need to expect a return;
function transaction_controller() {
  $args = func_get_args();
  $function = array_shift($args);
  return mcapi_controller('transaction', $function, $args);
}

function currency_controller() {
  $args = func_get_args();
  $function = array_shift($args);
  return mcapi_controller('currency', $function, $args);
}
function mcapi_controller($entity_type, $function, $args) {
  module_load_include('controller', 'mcapi', variable_get('mcapi_controller', 'default'));
  $method = array(entity_get_controller($entity_type), $function);
  try{
    $result = call_user_func_array($method, $args);
  }
  catch (Exception $e) {
    drupal_set_message($e, 'error');
    drupal_set_message('That was a caught exception');
    return;
  }
  return $result;
}

//module_invoke_all uses array_merge and loses the keys.
//so this function retrives the states using module_implements instead
function mcapi_transaction_states(){
  $states = array();
  foreach (module_implements('transaction_info') as $module) {
    $function = $module .'_transaction_info';
    $states += $function('states');
  }
  return $states;
}

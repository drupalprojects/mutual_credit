<?php


use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\mcapi\Plugin\Field\FieldType\Worth;

//delete modes
define('MCAPI_UNDO_STATE_DELETE', NULL);
define('MCAPI_UNDO_STATE_ERASE', 0);
define('MCAPI_UNDO_STATE_REVERSE', 2);

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//
//depending on the delete mode, erased transactions may or may not be counted
define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {

    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorageController('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  $items['admin/accounting'] = array(
    'title' => 'Accounting',
    'description' => "Manage all aspects of your community's money system",
    'route_name' => 'mcapi.admin',
    'position' => 'right',
  );
  $items['admin/accounting/config'] = array(
    'title' => 'Settings',
    'description' => 'Miscellaneous settings which effect the system globally.',
    'route_name' => 'mcapi.admin_misc',
    'weight' => 20,
  );
  $items['admin/accounting/currencies'] = array(
    'title' => 'Currencies',
    'description' => 'Each currency implies a set of values and a community of users who economic fortunes are intertwined. Most communities will want only one currency, but if you are hosting many communities in one drupal instance, or if there is an appetite for experimentation, different currencies can be provided. User can access many potentially very different currencies. Mixed payments are also possible, but this is pushing the boundaries of the software.',
    'route_name' => 'mcapi.admin_currency_list',
  );
  $items['admin/accounting/workflow'] = array(
    'title' => 'Transaction workflow',
    'description' => 'Configuration around transaction states, types and operations',
    'weight' => 2,
    'route_name' => 'mcapi.workflow',
  );
  $items['admin/accounting/workflow/operations'] = array(
    'title' => 'Transaction workflow operations',
    'description' => 'Configuration around transaction states, types and operations',
    'weight' => 2,
    'route_name' => 'mcapi.workflow.operations',
  );
  /*
  $items['transact/admin'] = array(
    'title' => 'Record transaction',
    'description' => 'Log a transaction in the database',
    'route_name' => 'mcapi.transaction_admin',
  );
  */
  return $items;
}
/**
 * Community Accounting API wrapper function, see transaction.api.php
 * update the transaction and notify the rest of the system
 * WARNING updating a transaction will NOT update the child transactions
 */
function transaction_update($op, $transaction, $old_state = NULL) {
  //entity_metadata_wrapper('transaction', $transaction)->update();
  entity_get_controller('mcapi_transaction')->update($transaction);
  //this will have fired
  //hook_entity_presave
  //hook_entity_insert OR hook_entity_update
  module_invoke_all('transaction_update', $op, $transaction, $old_state);

  //TODO
  //invoke rules
}

/*
 * Community Accounting API function, see transaction.api.php
 * Undo according to the appropriate delete mode.
 * NB No accounting checks take place before deletings.
 */
function transaction_undo($serial) {
  //load all the transactions sharing this serial as equals in an array, not as parent/children

}

/**
 * element pre_render callback
 */
function mcapi_pre_render_summary($element) {
  static $results = array();//TODO should this be drupal_static?
	$uid = $element['#account']->uid->value;
  //occasionally we'll appreciate a static result
  $result = &$results[$uid][$element['#currency']->id()];
  if (empty($result)) {
    $storage = \Drupal::entityManager()->getStorageController('mcapi_transaction');
    $data = $storage->summaryData($element['#account'], $element['#currency'], $element['#filters']);
    foreach ($data as $key => $val) {
      $result['#'.$key] = $val;
    }
  }
  return $element + $result;
}

/*
 * Community Accounting API wrapper function, to load a transaction by serial number
 * see transaction.api.php
 */
function transaction_load($serial = NULL) {
  return entity_load('mcapi_transaction', array('serial' => $serial));
}


/**
 * Community Accounting API wrapper function, see transaction.api.php
 */
function transaction_filter(array $conditions, $offset = 0, $limit = 25, $fieldapi = array()) {
  if ($fieldapi) {
    $offset = 0; $limit = 0;
  }
  $serials = entity_get_controller('mcapi_transaction')->filter($conditions, $offset, $limit);
  if ($serials && $fieldapi) {
    $filtered = array();
    //we just need to load one transaction for each serial number
    $serials = array_unique($serials);//TODO ONLINE ENSURE THAT KEYS ARE PRESERVED
    foreach (entity_load('mcapi_transaction', array_keys($serials)) as $transaction) {
      foreach ($fieldapi as $fieldname => $value) {
        $items = field_get_items('transaction', $transaction, $fieldname);
        if (current($items[0]) == $value) $filtered[$transaction->xid] = $transaction->serial;
      }
    }
    $serials = $filtered;
  }
  return $serials;
}

/*
 * DRUPAL & CONTRIB HOOK IMPLEMENTATIONS
 */

/**
 * implements hook_help()
 */
function mcapi_help($section, $arg) {
  switch ($section) {
    case 'admin/accounting':
      return implode(' ', array(
        t("The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital."),
        t("This software has been five years in the conceiving and making and has been supported only by informal donations.")
      ));
    case 'admin/accounting/workflow':
      module_load_include('admin.inc', 'mcapi');
      //TODO put this somewhere more suitable
      return mcapi_workflow_help();
  }
}


function transaction_operations() {
	//TODO when to use drupal_static and when to use drupal_static_fast?
	$operations = &drupal_static('__FUNCTION__', array());
	if (empty($operations)) {
		$manager = \Drupal::service('plugin.manager.mcapi.transaction_operation');
		foreach ($manager->getDefinitions() as $op => $info) {
			$operations[$op] = $manager->createInstance($op);
		}
	}
	return $operations;
}
function transaction_access_plugins() {
	//TODO when to use drupal_static and when to use drupal_static_fast?
	$plugins = &drupal_static('__FUNCTION__', array());
	if (empty($plugins)) {
		$manager = \Drupal::service('plugin.manager.mcapi.transaction_access');
		foreach ($manager->getDefinitions() as $plugin => $info) {
			$plugins[$op] = $manager->createInstance($op);
		}
	}
	//TODO Gordon I spent a good hour and I can't see why the the definitions aren't found for this plugin
	//but are found in for the transaction_operations above. I've tried to mirror everything and can't see the difference.
	return $plugins;

}


/**
 * implements hook_permission
 * This hook can supply permissions that the module defines.
 * doing it with another hook allows us to collect all the mutual credit permissions in one section of the permissions page
 */
function mcapi_permission() {
  return module_invoke_all('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'mcapi_transaction' => array(
      'render element' => 'transaction',
      'template' => 'transaction',
      'file' => 'mcapi.inc'
    ),
    'certificate' => array(
      'render element' => 'transaction',
      'template' => 'certificate',
      'pattern' => 'certificate__',
      'file' => 'mcapi.inc'
    ),
    'worth_element'=> array(
      'render element' => 'element',
    ),
  	'mcapi_summary' => array(
  	  'template' => 'mcapi_summary',
  		//might be appropriate to have a pattern here
  		'variables' => array(
  			'account' => NULL,
  			'currency' => NULL,
  			'balance' => 0,
  			'gross_in' => 0,
  			'gross_out' => 0,
  			'volume' => 0,
  			'count' => 0,
  			'partners' => 0,
  	  ),
    ),
    'balance_bars' => array(
      'template' => 'balance_bars',
      'variables' => array(
        'account' => '',
        'currency' => '',
      ),
      'file' => 'mcapi.inc'
    ),
    'balance_histories_gchart' => array(
      'template' => 'balance_histories_gchart',
      'variables' => array(
        'account' => NULL,
      	'currcodes' =>array(),
        'width' => 250,
        'resample' => 'simple'
      ),
      'file' => 'mcapi.inc'
    )
  );
  return $items;
}

/**
 * Implements hook_search_info().
 */
function mcapi_search_info() {
  return array(
    'title' => 'Transactions',
    'path' => 'transaction',
  );
}

/*
 * implement hook_user_view().
 */
function mcapi_user_view($account, $mode, $language) {
  if (\Drupal::config('mcapi.misc')->get('profile_summary')) {
    module_load_include('inc', 'mcapi');
    $account->content['mcapi_summary'] = mcapi_user_summary($account);
    $account->content['mcapi_summary']['#weight'] = 5;
  }
}


/**
 * implements hook_uid_renum() from uid_login module
 */
function mcapi_uid_renum($old, $new) {
  foreach(array('payer', 'payee') as $participant) {
    db_update('mcapi_transactions')->fields(array($participant => $new))->condition($participant, $old)->execute();
  }
}

/**
 * implements hook_accounting_validate
 * Some wiggle room has been left in case for any reason we want to store transactions with missing fields
 */
function mcapi_accounting_validate(array $transactions){
  $errors = array();
  foreach ($transactions as $key => $transaction) {

  	//TODO How to get the uids????
  	continue;

    //no usecase is currently envisaged where someone might pay themselves in one currency in one transaction
    if ($transaction->payer > 0) {
      if ($transaction->payer->value == $transaction->payee->value) {
        if ($key == 0) {
          $errors[] = t('A transaction must involve two different users');
        }
        else {
          unset($transactions[$key]);
        }
      }
    }
    //a transaction can only be finished if all these fields are filled in.
    if ($transaction->state >= TRANSACTION_STATE_FINISHED) {
      $required = array('payer', 'payee',  'type');
      foreach ($required as $fieldname) {
        if (!$transaction->$fieldname->value) {
          $errors[] = t("@fieldname required for completed transaction", array('@fieldname' => $fieldname));
        }
      }
    }
  }
  if ($errors) {
    throw new Exception(implode("<br />", $errors));
  }
}


/**
 * implements mcapi hook_info_states().
 * DON"T call this implementation directly as the keys will be lost. use mcapi_get_states()
 */
function mcapi_mcapi_info_states() {
  $states = array(
    TRANSACTION_STATE_FINISHED => array(
      'name' => t('Cleared'),
      'description' => t('the last state of the workflow'),
    ),
  );
  $undomode = \Drupal::config('mcapi.misc')->get('delete_mode');
  //don't attempt to liven the link coz this function can run while bootstrapping and that means trouble
  $description = t("See !mode settings for more info", array('!mode' => l(t('Undo mode'), 'admin/accounting/misc')));
  if ($undomode != MCAPI_UNDO_STATE_DELETE) {
    $states[TRANSACTION_STATE_UNDONE] = array(
      'name' => t('Undone'),
      'description' => $description,
    );
  }
  return $states;
}

/**
 * Implements hook_field_display_ENTITY_TYPE_alter().
 */
function mcapi_field_display_transaction_alter(&$display, $context) {
  // Hide field labels in search index.
  if ($context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}


/**
 * implements mcapi hook_info_types().
 */
function mcapi_mcapi_info_types() {
  $types = array('default', 'auto');
  if (\Drupal::config('mcapi.misc')->get('delete_mode') == MCAPI_UNDO_STATE_REVERSE) {
    $types[] = 'reversal';
  }
  return $types;
}

/**
 * gather up all the transaction states from the hooks and present them in a given format
 * #options is suitable for choosing in a form element
 * #description is suitable for a chunk of description text explaining what the states mean
 * #full is the full array returned from the callback, keyed by constant value
 */
function mcapi_get_states($return_mode = '#options') {
  static $states;
  if (empty($states)) {
    $states = array();
    foreach(module_implements('mcapi_info_states') as $module) {
      $function = $module . '_mcapi_info_states';
      $states += $function('states');
    }
  }
  if ($return_mode == '#full') return $states;
  elseif ($return_mode == '#description') {
    foreach ($states as $key => $state) {
      $desc[] = $state['name'] .' - '. $state['description'] .'.';
    }
    return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
  }
  else {//suitable for a dropdown
    foreach ($states as $key => $state) {
      $options[$key] = $state['name'];
    }
    return $options;
  }
  return $states;
}
//returns the available transaction types in an associative array
function mcapi_get_types() {
  foreach (module_invoke_all('mcapi_info_types') as $type) {
    $types[$type] = $type;
  }
  return $types;
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 * make permissions appear altogether on the permissions page
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency')
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    )
  );
}
/*
 * get all the transaction access callbacks,
 * might as well be cached, or put in config??
 * Multiple callbacks can be selected and access will be granted if any returns TRUE
 *
 * each callback refers to 2 functions - itself and CALLBACK_views
 * each callback takes the following args
 * $transaction, $account
 */
function transaction_access_callbacks() {
	if (!$cache = \Drupal::cache()->get('transaction_access_callbacks')) {
		$callbacks = module_invoke_all('transaction_access_callbacks');
		foreach (array_keys($callbacks) as $callback) {
			if (!function_exists($callback)) {
				unset($callbacks[$callback]);
				//message for developers doesn't need translating
				drupal_set_message("{$callback} does not exist", 'warning');
			}
			//TODO include the file(s) where these callbacks would live
			if (module_exists('views')) {
        module_load_include('views.inc', 'mcapi');
				if (!function_exists($callback.'_views')) {
			    unset($callbacks[$callback]);
          drupal_set_message("{$callback}_views does not exist", 'warning');
				}
			}
		}
    //TODO this cache should be cleared whenever a currency is edited and whenever a user's entitlement to use a currency could be affected
    \Drupal::cache()->set('transaction_access_callbacks', $callbacks, CacheBackendInterface::CACHE_PERMANENT);
    return $callbacks;
  }
  else {
    return $cache->data;
  }
}

/**
 * implements hook transaction_access_callbacks().
 */
function mcapi_transaction_access_callbacks() {
  return array(
    'mcapi_transaction_access_callback_perm_transact' => t("Users with permission to '@perm'", array('@perm' => t('Transact'))),
    'mcapi_transaction_access_callback_perm_manage_all' => t("Users with permission to '@perm'", array('@perm' => t('Manage all transactions'))),
    'mcapi_transaction_access_callback_payee' => t('The payee in the transaction'),
    'mcapi_transaction_access_callback_payer' => t('The payer in the transaction'),
    'mcapi_transaction_access_callback_open' => t('Anyone, even anonymous users'),
    'mcapi_transaction_access_callback_creator' => t('The creator of the transaction'),
  );
}

/*
 * helper function to run through all the access callbacks after the operation's own access callback has done its tests
*/
function _transaction_check_access_callbacks($callbacks, $transaction) {
	foreach ($callbacks as $function) {
		if ($function($transaction)) return TRUE;
	}
	return FALSE;
}

/*
 * implements hook_user_delete().
 * all transactions revert to the reservoir
 * Of course normally you wouldn't delete a user in a mutual credit system
 */
function mcapi_user_delete($account) {
  foreach (mcapi_currency_list(NULL, $account, TRUE) as $currcode => $currname) {
    entity_get_controller('transaction')->mergeAccounts(mcapi_currency_load($currcode)->reservoir, $account->uid);
  }
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transaction_mail_action') {
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['subject'], $params, $options);
    $message['body'][] =  token_replace($params['body'], $params, $options);
  }
  elseif ($key == 'operation') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['config']['subject'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['headers']['cc'] = $params['config']['cc'];
    $message['headers']['bcc'] = $params['config']['bcc'];
  }
}



/*
 * implements hook_field_extra_fields().
 */
function mcapi_field_extra_fields() {
  $props = \Drupal::entityManager()->getFieldDefinitions('mcapi_transaction');
  $fields = array('payer', 'payee', 'worths', 'description', 'state', 'type');
  $form = array('payer', 'payee', 'worths', 'description');
	foreach ($fields as $weight => $fieldname) {
		$extra['mcapi_transaction']['mcapi_transaction']['display'][$fieldname] = array(
			'label' => $props[$fieldname]['label'],
			'description' => $props[$fieldname]['description'],
			'weight' => $weight,
		);
		$extra['mcapi_transaction']['mcapi_transaction']['form'][$fieldname] = array(
			'label' => $props[$fieldname]['label'],
			'description' => $props[$fieldname]['description'],
			'weight' => $weight,
		);
	}
	return $extra;
}

//return a currency
//almost always you would call entity_load directly!
//used my machine_name_process
function mcapi_currency_load($currcode) {
  return entity_load('mcapi_currency', $currcode);
}

/*
 * get an #options list of all the currencies (for one account)
 */
function mcapi_currency_list(array $currencies = NULL, AccountInterface $account = NULL, $check_access = TRUE) {
  $list = array();

  if (!$account) {
    $account = \Drupal::currentUser();
  }

  if (empty($currencies)) {
    if ($check_access) {
      $currencies = mcapi_get_available_currencies($account);
      $check_access = FALSE; // No need to check the access again, so set it to false;
    }
    else {
      $currencies = entity_load_multiple('mcapi_currency');
    }
  }

  if ($check_access) {
    $currencies = array_intersect_key($currencies, mcapi_get_available_currencies($account));
  }

  foreach ($currencies as $currency) {
    $list[$currency->id()] = $currency->label();
  }
  return $list;
}

//get all the currencies a user can access, ready for an #options array
function mcapi_get_available_currencies(AccountInterface $account = NULL) {
  if (!isset($account)) {
    $account = \Drupal::currentUser();
  }
  $cid = 'currencies:' . $account->id();
  if (!$cache = \Drupal::cache()->get($cid)) {
    $available = array();
    $cache_tags = array('mcapi.available_currency' => array());
    $currencies = entity_load_multiple('mcapi_currency');
    $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
    uasort($currencies, array($info['class'], 'sort'));
    foreach ($currencies as $currency) {
      if ($currency->status && $currency->access('membership', $account)) {
        $available[$currency->id()] = $currency->label();
        $cache_tags['mcapi.available_currency'] = $currency->id();
      }
    }
    //TODO this cache should be cleared whenever a currency is edited and whenever a user's entitlement to use a currency could be affected
    \Drupal::cache()->set($cid, $available, CacheBackendInterface::CACHE_PERMANENT, $cache_tags);
    return $available;
  }
  else {
    return $cache->data;
  }
}



/*
 * implements hook_trigger_info().
 * we need a trigger for each transaction_operation
 * TODO convert these into rules, or something
 */
function __mcapi_trigger_info() {
  $triggers['mcapi']['transaction_children']['label'] = t('Create dependent transactions before inserting.');
  $triggers['mcapi']['transaction_undo']['label'] = t('Respond to transaction deletion.');
  $triggers['mcapi']['transaction_update']['label'] = t('Respond to transaction changing.');
  $triggers['mcapi']['transaction_post_insert']['label'] = t('Respond to a new transaction.');
  return $triggers;
}

/*
 * pull trigger transaction_children().
 * will only fire if the trigger module is enabled
 * sends the volitional transaction to the action callbacks where it can be changed.
 * Action callbacks may return a new transaction to be added to the $transactions
 */
function trigger_transaction_children($transaction) {
	$children = array();
  foreach (trigger_get_assigned_actions('transaction_children') as $aid => $info) {
    module_load_include('admin.inc', 'mcapi');
    $result = actions_do($aid, $transaction, $info);
    if (is_object($result[$aid])) {
      $children[] = $result[$aid];
    }
  }
  return $children;
}

/*
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  return array(
    // this is used by the field API for mixed transaction forms
    'worths' => array(
      '#title' => t('Worth'),
      '#input' => TRUE,
      '#title_display' => 'before',
      '#element_validate' => array('mcapi_worths_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#process' => array('mcapi_worths_element_process'),
      '#tree' => TRUE,
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worths-element.css',
        )
      ),
      // custom properties, used for configuration
      '#currcodes' => array_keys(mcapi_get_available_currencies()),
      '#mixed_mode' => \Drupal::config('mcapi.misc')->get('mix_mode'),
      '#preset' => FALSE, //ensures all currencies are showing
      '#calc' => FALSE, //allow a formula
    ),
    // this one is used internally only,
    // although you could probably use it to build a form if you wanted to ignore all multicurrency functionality
    'worth' => array(
      '#input' => TRUE,
      '#title_display' => 'attribute',
      '#process' => array('mcapi_worth_element_process'),
      '#value_callback' => 'mcapi_form_type_worth_value',
      '#element_validate' => array('mcapi_worth_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worth-element.css',
        )
      ),
      // custom properties, used for configuration
      '#currcodes' => array_keys(mcapi_get_available_currencies()),
      '#calc' => FALSE,
    ),
    'mcapi_states' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_states', 'ajax_process_form'),
      '#theme_wrappers' => array('radios'),
      '#pre_render' => array('form_pre_render_conditional_form_element'),
    ),
    'mcapi_types' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_types', 'ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#theme' => 'select'
    ),
    'mcapi_currcodes' => array(
      '#input' => TRUE,
      '#title_display' => 'invisible',
      '#process' => array('mcapi_process_currcodes','ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#theme' => 'select',
      '#multiple' => TRUE,
      '#options' => array(),//array of currcodes and currency names
    ),
    'mcapi_summary' => array(
      '#pre_render' => array('mcapi_pre_render_summary'),
      //other themes are possible, like and balance_bars and google-ometer
      '#theme' => 'mcapi_summary',
      '#currcode' => 'credunit',
      '#account' => NULL,//needed
      '#filters' => array()
    )
  );
}


function mcapi_worths_element_process($element, &$form_state) {
  $currencies = mcapi_get_available_currencies();

  //the default value also tells us which currencies are available
  //if no defaults are set then all currencies should be present
  if (!isset($element['#default_value']) || empty($element['#default_value']) || $element['#preset']) {
    $element['#default_value'] = isset($element['#default_value']) ? (array)$element['#default_value'] : array();
  }

  if ($element['#mixed_mode'] || $element['#preset']) {
    //construct one widget for each default, each with its own currcode
    foreach ($currencies as $currcode => $name) {
      $element[$currcode]['#title'] = $name;
      $element[$currcode]['#currcodes']= array($currcode);
      $element[$currcode]['#default_value'] = $element['#default_value']->{$currcode};
    }
  }
  else {
    $keys = array_keys($currencies);
    $key = reset($keys);
    $element[$key] = array(
      '#title' => t('Worth'),
      '#currcodes' => $element['#currcodes'],
      '#default_value' => $element['#default_value']->$key,
    );
    if (array_key_exists('#max', $element) && $element['#max']) {
      $element['#description'] = $element['#description'] . t('Max: !num', array('!num' => $element['#max']));
    }
  }
  //now populate all the subwidgets with defaults
  foreach (element_children($element) as $delta) {
    $element[$delta]['#type'] = 'worth';
    $element[$delta]['#calc'] = $element['#calc'];
    $element[$delta]['#preset'] = $element['#preset'];
  }
  return $element;
}

function mcapi_worths_element_validate($element, &$form_state) {
  if ($element['#required']) {
    $value_entered = FALSE;

    $currencies = $element['#currcodes'];
    if (!isset($element['#mixed_mode']) || !$element['#mixed_mode']) {
      $currencies = array(reset($currencies));
    }

    foreach ($currencies as $currcode) {
      $newcode = empty($element[$currcode]['currcode']['#value']) ? $element[$currcode]['currcode']['#default_value'] : $element[$currcode]['currcode']['#value'];
      $currency = entity_load('mcapi_currency', $newcode);

      if ($element[$currcode][$currency->widget]['#value'] || $element[$currcode][$currency->widget]['#value'] === 0) {
        $value_entered = TRUE;
        break;
      }
    }

    if (!$value_entered) {
      $elements['#required_but_empty'] = TRUE;
      if (isset($elements['#required_error'])) {
        \Drupal::formBuilder()->setError($element, $elements['#required_error']);
      }
      // A #title is not mandatory for form elements, but without it we cannot
      // set a form error message. So when a visible title is undesirable,
      // form constructors are encouraged to set #title anyway, and then set
      // #title_display to 'invisible'. This improves accessibility.
      elseif (isset($elements['#title'])) {
        \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
      }
      else {
        \Drupal::formBuilder()->setError($element);
      }
    }
  }
}

function mcapi_worth_element_process($element, &$form_state, $form) {
  $typedDataManager = \Drupal::typedData();
  if (!is_object($element['#default_value'])) {
    $element['#default_value'] = $typedDataManager->create(array('type' => 'field_item:worth', 'list' => TRUE), $element['#default_value']);
  }

  $element['#title_display'] = 'attribute';
  //the element is aware of a set of currcodes
  if (empty($element['#currcodes'])) {
    //best not rely on this, supply your own currencies that the user is permitted to use.
    //this defaults to all
    $element['#currcodes'] = array_keys(mcapi_get_available_currencies());
  }
  $element['currcode'] = array(
    '#title' => t('Currency'),
    '#type' => 'mcapi_currcodes',
    '#currcodes' => $element['#currcodes'],
    '#default_value' => $element['#default_value']->currcode,
  );
  $parents =  $element['#parents'];
  $parents[] = 'currcode';

  $name = array_shift($parents);
  if (count($parents)) {
    $name .= '[' . implode('][', $parents) . ']';
  }

  $element['value'] = array(
    '#type' => 'value',
    '#value' => $element['#default_value']->value,
  );

  $currencies = entity_load_multiple('mcapi_currency', $element['#currcodes']);
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));

  foreach ($currencies as $currency) {
    $plugin = $currency->getWidgetPlugin();

    if (empty($element[$currency->widget])) {
      $element[$currency->widget] = array(
        '#title_display' => 'invisible',
      );
      if (count($element['#currcodes']) == 1) {
        $element[$currency->widget] += array(
          '#field_prefix' => $currency->prefix,
          '#field_suffix' => $currency->suffix,
        );
      }
      else {
        // Set up the dependent fields when the currency select box is changed.
        $element[$currency->widget]['#states'] = array(
          'visible' => array(
            ':input[name="' . $name . '"]' => array(
              array('value' => $currency->id()),
            ),
          ),
        );
      }

      $element[$currency->widget] = $plugin->formElement(array(0 => $element['#default_value']), 0, $element[$currency->widget], $form, $form_state);
    }
    else {
      // add the new additional currency.
      $element[$currency->widget]['#states']['visible'][':input[name="' . $name . '"]'][] = array('value' => $currency->id());
    }
  }

  return $element;
}

function mcapi_worth_element_validate($element, &$form_state) {
  $currcode = empty($element['#value']['currcode']) ? $element['currcode']['#value'] : $element['#value']['currcode'];
  if (!$currency = entity_load('mcapi_currency', $currcode)) {
    \Drupal::formBuilder()->setError($element, $form_state, t('%currcode is not a valid currency', array('%currcode' => $currcode)));
    return;
  }
  $plugin = $currency->getWidgetPlugin();

  $value = $element['#value'][$currency->widget];
  if (method_exists($plugin, 'asInteger')) {
    $value = $plugin->asInteger($value);
  }

  if ($element['#required'] && !$value && $value !== 0) {
    $elements['#required_but_empty'] = TRUE;
    if (isset($elements['#required_error'])) {
      \Drupal::formBuilder()->setError($element, $elements['#required_error']);
    }
    // A #title is not mandatory for form elements, but without it we cannot
    // set a form error message. So when a visible title is undesirable,
    // form constructors are encouraged to set #title anyway, and then set
    // #title_display to 'invisible'. This improves accessibility.
    elseif (isset($elements['#title'])) {
      \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
    }
    else {
      \Drupal::formBuilder()->setError($element);
    }
  }
  else {
    $values = array(
      'currcode' => $currcode,
      'value' => $value,
    );
    \Drupal::formBuilder()->setValue($element, $values, $form_state);
  }
}

function mcapi_process_states($element) {
  $element['#options'] = mcapi_get_states('#options');
  $element = form_process_radios($element);
  return $element;
}

function mcapi_process_types($element) {
  $element['#options'] = mcapi_get_types();
  return $element;
}

function mcapi_process_currcodes($element) {
  if (empty($element['#options']) && !empty($element['#currcodes'])) {
    $element['#options'] = array_intersect_key(mcapi_get_available_currencies(), drupal_map_assoc($element['#currcodes']));
  }
  else if (empty($element['#options'])) {//assume it is a user object
    //limit the choice to the currencies available to this user
    $element['#options'] = mcapi_get_available_currencies();
  }
  else if ($element['#options'] == 'all') {
    $currencies = entity_load_multiple('mcapi_currency');
    $element['#options'] = array();
  }

  if (empty($element['#options'])) {
    $element['#options'] = array();
    foreach ($currencies as $currcode => $currency) {
      $element['#options'][$currcode] = $currency->label();
    }
  }

  if (count($element['#options']) == 1 && isset($element['#options'][$element['#default_value']])) {
    //$element['#type'] = 'value';
    $element['#theme'] = array();
    $element['#theme_wrappers'] = array();
    $element['#value'] = $element['#default_value'];
  }

  return $element;
}


/*
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, they can only be blocked, not deleted
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  form_load_include($form_state, 'admin.inc', 'mcapi');
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/*
 * implements alter hook_user_cancel_methods().
 * creates a new method
 */
function mcapi_user_cancel_methods_alter(&$methods) {
  module_load_include('admin.inc', 'mcapi');
  $methods['user_cancel_mcapi'] = array(
    'title' => t('Disable the account and delete its content.'),
    'description' => t('Your account will be blocked and you will no longer be able to log in. All of your content will be deleted.'),
  );
}

function mcapi_toolbar() {
  if (\Drupal::currentUser()->hasPermission('manage all transactions')) {
    drupal_add_css(drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css');
  }
}


/*
 * transaction_access callbacks
*/
function mcapi_transaction_access_callback_perm_transact() {
	return user_access('transact');
}
function mcapi_transaction_access_callback_perm_manage_all() {
	return user_access('manage all transactions');
}
function mcapi_transaction_access_callback_payee($transaction) {
	return \Drupal::currentUser()->id() == $transaction->payee->value;
}
function mcapi_transaction_access_callback_payer($transaction) {
	return \Drupal::currentUser()->id() == $transaction->payer->value;
}
function mcapi_transaction_access_callback_open() {
	return TRUE;
}
function mcapi_transaction_access_callback_creator($transaction) {
	return \Drupal::currentUser()->id() == $transaction->creator;
}


function mcapi_transaction_access_callback_perm_transact_views($query, $condition, $state) {
	$condition->condition(1, user_access('transact'));
}
function mcapi_transaction_access_callback_perm_manage_all_views($query, $condition, $state) {
	$condition->condition(1, user_access('manage all transactions'));
}
function mcapi_transaction_access_callback_payee_views($query, $condition, $state) {
	$condition->condition('mcapi_transactions.payee', \Drupal::currentUser()->id());
}
function mcapi_transaction_access_callback_payer_views($query, $condition, $state) {
	$condition->condition('mcapi_transactions.payer', \Drupal::currentUser()->id());
}
function mcapi_transaction_access_callback_open_views($query, $condition, $state) {
	$condition->condition(1, 1);
}
function mcapi_transaction_access_callback_creator_views($query, $condition, $state) {
	$condition->condition('mcapi_transactions.creator', \Drupal::currentUser()->id());
}


/*
 * implements hook_config_translation_info().
 * Introduce dynamic translation tabs for translation of configuration.
 * //TODO
 */
function mcapi_config_translation_info() {
  //dunno what to return here
}
/*
 * implements hook_config_translation_type_info_alter().
 */
function mcapi_config_translation_type_info_alter($info) {
	debug($info);
}

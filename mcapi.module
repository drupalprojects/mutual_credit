<?php

/**
 * @file
 * mcapi.module
 * @todo We need events, or triggers for when a user joins an exchange (and leaves)
 */

use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\mcapi\Plugin\Field\FieldType\Worth;
use Drupal\Core\Utility\Token;
use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\mcapi\Entity\TransactionInterface;
use Drupal\field\Field;

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//

define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {

    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorage('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * wrapper around entity_load_multiple
 * load many transactions and key them by serial number instead of xid
 * @param mixed
 *   a serial number or array of serial numbers
 * @return mixed
 *   an array of transaction entities or one transaction entity, depending on the input
 */
function mcapi_transaction_load_by_serial($serials) {
  $transactions = array();
  if ($serials) {
    $results = entity_load_multiple_by_properties('mcapi_transaction', array('serial' => (array)$serials));
    //put all the transaction children under the parents
    foreach ($results as $xid => $transaction) {
      if ($pxid = $transaction->get('parent')->value) {
        $results[$pxid]->children[] = $transaction;
        unset($results[$xid]);
      }
    }
    //I had a problem on uninstalling the tester module that all the parents were somehow deleted already
    //which rather screwed up this function.
    //change the array keys for the serial numbers
    foreach ($results as $transaction) {
      $transactions[$transaction->serial->value] = $transaction;
    }
  }
  if (is_array($serials)) return $transactions;
  else return reset($transactions);
}
/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($path, $arg) {
  switch ($path) {
    case 'admin/accounting':
      return t('The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital.');
    case 'admin/accounting/currencies':
      return implode(' ', array(
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.'),
        t('Retired currencies can no longer be used, but transactions are still visible.'),
      ));
      //@todo when hook_menu is removed take this out of help and put it on the page somehow
    case 'admin/accounting/transactions':
      //TODO how do we make this show at the top of a menu page without help module?
      module_load_include('inc', 'mcapi');
      $renderable = _workflow_help();
      return drupal_render($renderable);
      return implode(' ', array(
        t('Different transaction user stories can be configured here, although the actual structure has to be defined in code.')
      ));
    case 'admin/accounting/transactions/workflow':
      return implode(' ', array(
        t('The workflow is about moving transactions between states. This is always done through a form.'),
        t('The confirm forms are configured on this page.')
      ));
  }
}

/**
 * get a transaction transition plugin or array of all plugins
 * N.B. transitions are NOT configurable entities, but plugins with a settings file each
 *
 * @param string $op_name
 *   the plugin id of the transition
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 * @todo allow transitions to be disabled to save processing.
 * @todo rename transitions to transitions because d8 now has entity transitions which are not configurable and not very extensible.
 */
function transaction_transitions($op_name = NULL) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_transition');
    $plugins = $manager->loadActive();
  }
  if ($op_name) return $plugins[$op_name];
  else return $plugins;
}

//shows the most common transitions
function show_transaction_transitions($view = TRUE) {
  $ops = transaction_transitions();
  unset($ops['create']);
  if (!$view) unset($ops['view']);
  return $ops;
}


/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  module_load_include('inc', 'mcapi');
  return _mcapi_theme();
}

/**
 * implements hook_entity_view().
 * add a wallet summary view to wallet-enabled entities
 */
function mcapi_entity_view($entity, $mode, $language) {
  $build = array();
  //check the entity is of a type which can own a wallet.
  $quants = \Drupal::config('mcapi.wallets')->get('entity_types');
  $key = $entity->getEntityTypeId() .':'. $entity->bundle();
  if (array_key_exists($key, $quants) && $quants[$key]) {
    module_load_include('inc', 'mcapi');
    $entity->content['wallets_summaries'] = mcapi_view_wallets_summaries($entity);
  }
}


/**
 * Implements hook_form_alter();
 * Add a submit callback to ContentEntityForms for contentTypes which reference exchanges
 * Form_alter is rather a blunt instrument but it is the best available.
 * Would be better to use hook_entity_presave or postsave but the old values aren't available there
 */
function mcapi_form_alter(&$form, &$form_state) {
  if (array_key_exists('controller', $form_state) && $form_state['controller'] instanceof \Drupal\Core\Entity\ContentEntityFormController) {
    $entity = $form_state['controller']->getEntity();
    module_load_include('inc', 'mcapi');
    $lookup = bundles_in_exchanges();
    $entity_type = $entity->getEntityTypeId();
    if (array_key_exists($entity_type, $lookup)) {
      if (array_key_exists($entity->bundle(), $lookup[$entity_type])) {
        form_load_include($form_state, 'inc', 'mcapi');
        //
        array_unshift($form['actions']['submit']['#submit'], 'mcapi_exchanges_changed_submit');
      }
    }
  }
}

/**
 * just gets the children and puts them side by side with the parent
 * Makes it easier to iterate through
 *
 * @param TransactionInterface $transaction
 *
 * @return array
 *   transactions with the cloned parent transaction first and children property removed
 */
function mcapi_transaction_flatten(TransactionInterface $transaction) {
  $clone = clone($transaction);
  $flatarray = array($clone);
  foreach ($clone->children as $child) {
    $flatarray[] = $child;
  }
  unset($clone->children);
  return $flatarray;
}

/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 * NOT CURRENTLY USED
 */
function mcapi_get_state_descriptions() {
  foreach (entity_load_multiple('mcapi_state') as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  $perms = array(
    'create own wallets' => array(
      'title' => t('Create own wallets'),
      'description' => t('Users can have as many wallets as they like.')
    ),
    'manage own exchanges' => array(
      'title' => t('Manage exchanges'),
      'description' => t('Accounting permissions in all exchanges of which the user is a member')
    ),
    'configure mcapi' => array(
      'title' => t('Configure community accounting'),
      'description' => t('Design and setup the accounting system')
    ),
    'manage mcapi' => array(
      'title' => t('Manage community accounting'),
      'description' => t('Suitable for accountants')
    )
  );
  if (\Drupal::config('mcapi.misc')->get('editable')) {
    $perms['edit transactions'] = array(
    	'title' => t('Edit transactions'),
      'description' => t('Use the Edit transition on transactions in your exchange. See config for details.')
    );
  }
  return $perms;
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transition') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  \Drupal::Token()->replace($params['subject'], $params, $options);
    $message['body'][] =  \Drupal::Token()->replace($params['body'], $params, $options);
    $message['headers']['cc'] = $params['cc'];
  }
}


/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_entity_extra_field_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_entity_extra_field_info();
}

/**
 * Machine name callback
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 */
function mcapi_currency_load($id) {
  return entity_load('mcapi_currency', $id);
}


function mcapi_entity_label_list($entities, $entity_type = '') {
  if (!is_object(reset($entities))) {
    $entities = empty($entities) ?
      entity_load_multiple($entity_type) :
      entity_load_multiple($entity_type, $entities);
  }
  $list = array();
  foreach ($entities as $entity) {
    $list[$entity->id()] = $entity->label();
  }
  //TODO sort these entities by weight but how?
  return $list;
}

/**
 * return a list of exchanges from an entity_reference field in an entity
 * If an exchange is passed, it returns itself
 *
 * @param ContentEntityInterface $entity
 *   any Content Entity which has a reference field pointing towards mcapi_exchange entities
 * @return array
 *   of entities, keyed by exchange id
 * @todo cache this
 */
function referenced_exchanges(ContentEntityInterface $entity = NULL, $enabled = FALSE, $open = FALSE) {
  $exchanges = array();
  if (is_null($entity)) {
    $entity = entity_load('user', \Drupal::currentUser()->id());
  }
  $entity_type = $entity->getEntityTypeId();
  if ($entity_type == 'mcapi_exchange') {
    //an exchange references itself only
    $exchanges[$entity->id()] = $entity;
  }
  else{
    $fieldnames = get_exchange_entity_fieldnames();
    if ($fieldname = $fieldnames[$entity_type]) {
      foreach($entity->get($fieldname)->getValue(TRUE) as $item) {
        if ($item['entity']) {//an empty $item means the exchangeItemList is empty
          if ($enabled && !$item['entity']->status->value) continue;
          if ($open && !$item['entity']->open->value) continue;
          $exchanges[$item['target_id']] = $item['entity'];
        }
      }
    }
  }
  return $exchanges;
}

/**
 * get a list of all the entity types which have an entity reference field pointing to mcapi_exchange
 *
 * @param string $type
 *   (optional) the name of the entity type
 *
 * @return array
 *   a mapping of entityTypeId to the name of the exchanges entity_reference
 *   field or the fieldname for the given entitytype
 *
 * @todo cache and static this. cache should be cleared whenever fieldInfo changes
 */
function get_exchange_entity_fieldnames() {
  $types = array();
  foreach (Field::FieldInfo()->getInstances() as $entity_type => $data1) {
    if (in_array($entity_type, array('mcapi_exchange', 'mcapi_transaction', 'mcapi_wallet'))) continue;
    foreach ($data1 as $bundle => $fields) {
      foreach ($fields as $fieldname => $fieldInfo) {
        if ($fieldInfo->getType() == 'entity_reference') {
          if ($fieldInfo->getSetting('target_type') == 'mcapi_exchange') {
            $types[$entity_type] = $fieldname;
            continue 3;
          }
        }
      }
    }
  }
  return $types;
}

/**
 * get all the currencies from (common to) the given exchanges, sorted
 * @param array $exchanges
 * @param boolean $ticks
 *   filter out currencies with no exchange rate
 * @param boolean $status
 *   filter out disabled currencies
 * @return array
 *   the filtered currencies
 */
function exchange_currencies(array $exchanges, $ticks = FALSE) {
  $currencies = array();
  foreach ($exchanges as $exchange) {
    foreach ($exchange->get('currencies')->getValue() as $item) {
      if (empty($item))continue;//this should never happen because an exchange can't have no currencies
      $currency = mcapi_currency_load($item['target_id']);
      if ($ticks && !$currency->get('ticks')) continue;
      $currencies[$item['target_id']] = $currency;
    }
  }
  uasort($currencies, array('\Drupal\Component\Utility\SortArray', 'sortByWeightProperty'));
  return $currencies;
}

/**
 * Load currencies for a given wallet, or common to 2 given users
 * A list of all the currencies in the marketplaces of which the user is a member.
 *
 * @param AccountInterface $account
 *   an entity which might be in an exchange
 * @return array
 *   of currencies
 * @todo move this to where it is needed
 */
function mcapi_currencies_for_user(AccountInterface $account = NULL, $status = FALSE, $ticks = FALSE) {
  return exchange_currencies(referenced_exchanges($account, $status), $ticks);
}

/**
 * implements hook_mcapi_transaction_operated().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param TransactionInterface $transaction
 * @param array $context
 *   consists of op_plugin_id; config, the transition plugin configuration; old_state: the state of the transaction before the transition
 */
function mcapi_mcapi_transaction_operated($transaction, $context) {
  //TODO invoke rules hook
  //make a note that the proper way to trigger mails is via each transitions' settings
  drupal_set_message('Ran hook_transaction_operated');
}

/**
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_element_info();
}

/**
 * process callback for worth form element
 * This single element processes multiple currencies as one value, like the checkboxes widget
 */
function mcapi_worth_element_process($element, &$form_state, $form) {
  form_load_include($form_state, 'inc', 'mcapi');
  return _mcapi_worth_element_process($element, $form_state, $form);
}

/**
 * value callback for worth element
 * expects $input structured thus:
 * array(curr_id => array(subelement1 => n, subelement2 => n))
 * needs to output a worths array thus
 * array(curr_id => n) where n is the raw database value
 *
 * SHIT this is being overwritten by the widget children
 * the $element being passed is BEFORE it was processed
 */
function mcapi_form_type_worth_value(&$element, $input = FALSE, &$form_state) {
  if ($input === FALSE) return;
  foreach ($input as $curr_id => $parts) {
    $currency = mcapi_currency_load($curr_id);
    unset($element[$curr_id]);//this prevents the children values overwriting the output of this function
    $quant = $currency->unformat($parts);
    if (!$quant && empty($currency->zero))continue;
    $output[$curr_id] = $quant;
  }
  //this prevents the element being processed again, generating children
  //and the children overwriting the value we just made.
  //I'd be very interested to know what the reccommended way is
  $element['#default_value'] = array();
  return $output;
}

/**
 * element_validate callback for worth field
 *
 * @param array $element
 * @param array $form_state
 */
function mcapi_worth_element_validate($element, &$form_state) {
  if ($element['#value'] < 0) {
    \Drupal::formBuilder()->setError($element, $form_state, t('Negative amounts not allowed'));
  }
}

/**
 * process callback for mcapi_state form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_entity_label_list(array(), 'mcapi_state');
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_entity_label_list(array(), 'mcapi_type');
  return $element;
}

/**
 * process callback for mcapi_currency_select form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  $conditions = array();
  if ($element['#status']) $conditions['status'] = TRUE;
  if (empty($element['#options']) && !empty($element['#curr_ids'])) {
    //shows the intersection of all currencies and currencies provided
    $element['#options'] = array_intersect_key(
      mcapi_entity_label_list($element['#curr_ids'], 'mcapi_currency'),
      entity_load_multiple_by_property('mcapi_currency', $conditions)
    );
  }
  elseif (empty($element['#options'])) {
    $currencies = entity_load_multiple('mcapi_currencies', $conditions);
    $element['#options'] = $element['#options'] = mcapi_entity_label_list($currencies);
  }
  elseif ($element['#options'] == 'all') {
    $element['#options'] = mcapi_entity_label_list(entity_load_multiple('mcapi_currencies'));
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}

/**
 * select_wallet element callbacks
 * these could all go in a different file
 */
/**
 * process callback for wallet_select element
 */
function mcapi_process_select_wallet($element, &$form_state) {
  $element['#autocomplete_route_name'] = $element['#local']
    ? 'mcapi.wallets.autocomplete'
    : 'mcapi.wallets.autocomplete_all';
  return $element;
}
/**
 * value callback
 * takes from the autocomplete select_wallet field and returns an integer candidtate wallet id.
 */
function form_type_select_wallet_value(&$element, $input, &$form_state) {
  if (empty($input)) return;
  if (is_numeric($input) && is_integer($input + 0)) {
    return $input;
  }
  //get the number from between the brackets
  preg_match('/.*\(([0-9]+)\)/', $input, $matches);
  return intval(array_pop($matches));
}

/**
 * element_validate callback for select_wallet
 * ensure the passed value is a wallet id
 */
function local_wallet_validate_id(&$element, &$form_state) {
  if (!entity_load('mcapi_wallet', $element['#value'])) {
   \Drupal::formBuilder()->setError($element, $form_state, t('Invalid wallet id: @value', array('@value' => $element['#value'])));
  }
}

/**
 * element_prerender callback for select_wallet
 * convert the #default value from a wallet id to the autocomplete format
 * ensure the autocomplete address is going to the right place
 */
function mcapi_prerender_wallet_field($element) {
  if (is_numeric($element['#default_value'])) {
    $wallet = entity_load('mcapi_wallet', $element['#default_value']);
    $element['#default_value'] = _mcapi_wallet_autocomplete_value($wallet);
  }
  return $element;
}

/**
 * Helper function to create a human/machine readable wallet name
 * the wallet id is included in brackets at the end of the human name
 * @param EntityInterface $wallet
 * @return string
 */
function _mcapi_wallet_autocomplete_value(ContentEntityInterface $wallet) {
  //the brackets are used to identify the wallet id at the other end
  return $wallet->getLabel() .' ('.$wallet->id().')';
}


/**
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, users can only be blocked, not deleted
 * TODO test this
 *
 * @param array $form
 * @param array $form_state
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/**
 * implements hook_element_info_alter().
 * adds the 'balances' icon via css
 */
function mcapi_element_info_alter(&$items) {
  $items['toolbar']['#attached']['css'][] = drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css';
}

/**
 * field api default value callback
 * when creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @return string
 *   The uuid of the exchange
 * //TODO an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id($entity, $field_definition, $langcode) {
  $output = array();
  foreach (referenced_exchanges($entity, TRUE) as $exchange) {
    $output[]['target_uuid'] = $exchange->get('uuid')->value;
  }
  drupal_set_message('a bug in alpha11 prevents more than one default entityreference field widget value from showing.');
  return $output;
}

/**
 * field api default value callback
 * TEMP...
 * when creating a new exchange, populate the currencies field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @return
 *   an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_currency_id($entity, $field_definition, $langcode) {
  $output = array();
  //temporary until we work out what the default should be.
  $output[]['target_uuid'] = entity_load('mcapi_currency', 1)->get('uuid');

  drupal_set_message('a bug in alpha11 prevents more than one default entityreference field widget value from showing.');
  return $output;
}

/**
 * implements hook_entity_insert()
 * give a new wallet to every user, and every new exchange, if the settings require
 */
function mcapi_entity_insert($entity) {
  $type = $entity->getEntityTypeId();
  if (!\Drupal::config('mcapi.wallets')->get('autoadd')) return;
  $entity_bundle = $type .':'. $entity->bundle();
  $max = \Drupal::config('mcapi.wallets')->get('entity_types.'.$entity_bundle);
  if (!$max) return;
  //no need to check what the max is, since this is the first wallet created for this entity
  $wallet = array(
    'name' => $type == 'mcapi_exchange' ? '_intertrading' : '',
    'entity_type' => $type,
    'pid' => $entity->id(),
    'viewers' => 'dunno',
    'payers' => 'dunno',
    'payees' => 'dunno',
  );
  $wallet = entity_create('mcapi_wallet', $wallet);
  $wallet->save();
}

/**
 * implements hook_entity_delete()
 * ensure any wallets belonging to the entity are moved to their parent's exchange
 * @todo this should be pre-deletion
 */
function mcapi_entity_delete($entity) {
  //see Exchange::preDelete();
  if ($entity instanceof ContentEntityInterface && $exchanges = referenced_exchanges($entity)) {
    $exchange = current($exchanges);//if the parent entity was in more than one exchange, this will pick a random one to take ownership
    $wids = \Drupal::Entitymanager()->getStorage('mcapi_wallet')->getOwnedWalletIds($entity);
    drupal_set_message($entity->getEntityTypeId() . $entity->id() .' owns wallets '. implode(', ', $wids));
    foreach (entity_load_multiple('mcapi_wallet', $wids) as $wallet) {
      $wallet->orphan($exchange);
    }
  }
}

//fetch an entity reference computed entity value
//TODO decide whether to delete this
function _mcapi_fetch_ref(ContentEntityInterface $entity, $fieldname, $calculated = FALSE) {
  $val = $entity->get($fieldname)->getValue($calculated);
  if ($calculated) return $val[0]['entity'];
  else return $val[0]['target_id'];
}

/**
 * get the entity from a Request object, whatever the entitytype
 * this is quite hacky
 *
 * @param Request $request
 * @return ContentEntityInterface object
 */
function mcapi_request_get_entity($request) {
  foreach ($request->attributes->get('_route_params') as $key => $value) {
    if (substr($key, 0, 1) == '_')continue;
    return $value;
  }
}

/**
 * developer-friendly wrapper around the wallet storage controller function, getOwnedWalletIds().
 * @param Drupal\Core\Entity\ContentEntityInterface $entity
 * @return array
 *   wallet ids belonging to the passed entity
 */
//TODO this is
function mcapi_get_wallet_ids(ContentEntityInterface $entity) {
  return \Drupal::EntityManager()->getStorage('mcapi_wallet')->getOwnedWalletIds($entity);
}

/**
 * implements hook_block_view_BLOCK_BASE_ID_alter
 * Add a links to the menu block, one for each exchange the current user is in.
 * The alternative, to create many links and give them all access control would be
 * rather expensive, I think
 * @todo second opinion?
 */
function _mcapi_block_view_system_menu_block_alter(&$build, $block) {
  if($block->getPluginId() == 'system_menu_block:tools') {
    if (!array_key_exists('content', $build)) {
      $build['content'] = array();
    }
    foreach (referenced_exchanges(NULL, TRUE) as $exchange) {
      //does a menu link really require all of these properties
      $renderable = array(
      	'#theme' => 'menu_link',
        '#title' => $exchange->label(),
        '#href' => $exchange->url(),
        '#weight' => -100,
        '#localized_options' => array(),
        '#below' => array(),
        '#attributes' => array(),
        '#original_link' => array('menu_name' => 'tools'),//required by menu_block_view_system_menu_block_alter
      );
      array_unshift($build['content'], $renderable);
    }
    //@todo exchange admins links to their currency(s) OR a link to admin/accounting/currencies
  }
}
/**
 * get the Transition links for a transaction
 * @param Transaction $transaction
 * @param boolean $view_link
 *
 * @return array
 *   a renderable array
 */
function mcapi_get_links(Transaction $transaction, $view_link = FALSE) {
  static $transactionViewBuilder;
  if (!$transactionViewBuilder) {
    $transactionViewBuilder = \Drupal::EntityManager()->getViewBuilder('mcapi_transaction');
  }
  return $transactionViewBuilder->renderLinks($transaction, 'sentence');
}
/**
 * Delete all transaction entities
 * For development only!
 */
function mcapi_wipeslate() {
  $controller = \Drupal::entityManager()->getStorage('mcapi_transaction');
  $entities = $controller->loadMultiple();
  $controller->delete($entities, TRUE);
}

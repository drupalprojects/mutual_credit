<?php


use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\mcapi\Plugin\Field\FieldType\Worth;

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//

define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {

    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorageController('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  $items['admin/accounting'] = array(
    'title' => 'Accounting',
    'description' => "Manage all aspects of your community's money system",
    'route_name' => 'mcapi.admin',
    'position' => 'right',
  );
  $items['admin/accounting/config'] = array(
    'title' => 'Other configuration',
    'description' => 'Miscellaneous settings which effect the system globally.',
    'route_name' => 'mcapi.admin_misc',
    'weight' => 20,
  );
  $items['admin/accounting/wallets'] = array(
    'title' => 'Wallets',
    'description' => 'Ownership, access control and auto-creation.',
    'route_name' => 'mcapi.admin_wallets',
    'weight' => 10,
  );
  $items['admin/accounting/currencies'] = array(
    'title' => 'Currencies',
    'description' => 'Each currency implies a set of values and a community of users who economic fortunes are intertwined.',
    'route_name' => 'mcapi.admin_currency_list',
  );
  $items['admin/accounting/exchanges'] = array(
    'title' => 'Exchanges',
    'description' => 'The groups, communities or marketplaces where transactions happen',
    'route_name' => 'mcapi.admin_exchange_list',
  );
  $items['admin/accounting/transactions'] = array(
    'title' => 'Transactions',
    'description' => 'Configuration around transaction states, types and operations.',
    'weight' => 2,
    'route_name' => 'mcapi.admin.transactions',
  );
  $items['admin/accounting/transactions/mass'] = array(
    'title' => 'Mass payments',
    'description' => 'Pay between one account and many.',
    'route_name' => 'mcapi.admin_mass',
  );
  $items['admin/accounting/transactions/operations'] = array(
    'title' => 'Configure workflow',
    'description' => 'Configure workflow and user experience for each transaction operation.',
    'weight' => 2,
    'route_name' => 'mcapi.admin.transactions.operations',
  );
  $items['admin/accounting/transactions/add'] = array(
    'title' => 'Record transaction',
    'description' => 'Log a transaction in the database',
    'route_name' => 'mcapi.transaction_admin',
  );

  return $items;
}

function mcapi_transaction_load($serial) {
  return current(entity_load_multiple('mcapi_transaction', array('serial' => $serial)));
}

/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($path, $arg) {
  switch ($path) {
    case 'admin/accounting':
      return t("The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital.");
    case 'admin/accounting/currencies':
      return implode(' ', array(
        t('Most community projects now have only one currency.'),
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.')
      ));
      //@todo when hook_menu is removed take this out of help and put it on the page somehow
    case 'admin/accounting/transactions':
      //TODO how do we make this show at the top of a menu page without help module?
      module_load_include('inc', 'mcapi');
      $renderable = _workflow_help();
      return drupal_render($renderable);
      return implode(' ', array(
        t('Different transaction user stories can be configured here, although the actual structure has to be defined in code.')
      ));
    case 'admin/accounting/transactions/workflow':
      return implode(' ', array(
        t("The workflow is about moving transactions between states. This is always done through a form."),
        t("The confirm forms are configured on this page.")
      ));
  }
}

/**
 * get a transaction operation plugin or array of all plugins
 *
 * @param string $op_name
 *   the plugin id of the operation
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 */
function transaction_operations($op_name = NULL) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_operation');
    foreach ($manager->getDefinitions() as $op => $info) {
      $plugins[$op] = $manager->createInstance($op);
    }
  }
  if ($op_name) return $plugins[$op_name];
  else return $plugins;
}
function show_transaction_operations($view = TRUE) {
  $ops = transaction_operations();
  unset($ops['create']);
  if (!$view) unset($ops['view']);
  return $ops;
}

/**
 * get a transaction access plugin or array of all plugins
 *
 * @param string $options
 *   return just the plugin names, suitable for a formAPI select widget #options
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 */
function transaction_access_plugins($options = FALSE) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_access');
    foreach ($manager->getDefinitions() as $plugin => $info) {
      $plugins[$plugin] = $manager->createInstance($plugin);
    }
  }
  if ($options) {
    $names = array();
    foreach ($plugins as $key => $info) {
      $names[$key] = $info->label();
    }
    return $names;
  }
  else return $plugins;
}


/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'mcapi_transaction' => array(
      'render element' => 'transaction',
      'template' => 'transaction',
      'file' => 'mcapi.inc'
    ),
    //the above is the theme wrapper for the below
    //so they both take the same render_element
    'certificate' => array(
      'render element' => 'transaction',
      'template' => 'certificate',
      'pattern' => 'certificate__',
      'file' => 'mcapi.inc'
    ),
    'mcapi_twig' => array(
      'variables' => array(
    	  'mcapi_transaction' => NULL,
        'twig' => '',
        'showlinks' => FALSE
      ),
      'file' => 'mcapi.inc'
    ),
    'worth_element'=> array(
      'render element' => 'element',
    ),
    'wallet' => array(
      'template' => 'wallet',
      'variables' => array(
    	  'wallet' => NULL
      ),
      'file' => 'mcapi.inc'
    ),
    //TODO
    'balance_bars' => array(
      'template' => 'balance_bars',
      'variables' => array(
        'account' => '',
        'currency' => '',
      ),
      'file' => 'mcapi.inc'
    ),
    'balance_histories_gchart' => array(
      'template' => 'balance_histories_gchart',
      'variables' => array(
        'account' => NULL,
        'currcodes' =>array(),
        'width' => 250,
        'resample' => 'simple'
      ),
      'file' => 'mcapi.inc'
    )
  );
  return $items;
}

/**
 * implements hook_user_view().
 * add a wallet summary view to the user profile
 */
function mcapi_user_view($account, $mode, $language) {
  module_load_include('inc', 'mcapi');
  $account->content['mcapi_summary'] = mcapi_view_wallet_summaries($account);
}

/**
 * just gets the children and puts them side by side with the parent so they are easier to iterate through
 */
function mcapi_transaction_flatten($transaction) {
  $cluster = array($transaction);
  foreach ($transaction->children as $child) {
    $cluster[] = $child;
  }
  return $cluster;
}


/**
 * get all the transaction state entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The states, either full config entity objects, or just keys and names
 */
function mcapi_get_states($options = FALSE) {
  $states = entity_load_multiple('mcapi_state');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($states as $key => $state) {
      $pairs[$state->value] = $state->label;
    }
    return $pairs;
  }
  return $states;
}

/**
 * get all the transaction type entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The types, either full config entity objects, or just keys and names
 */
function mcapi_get_types($options = FALSE) {
  $types = entity_load_multiple('mcapi_type');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($types as $key => $type) {
      $types[$key] = $type->label;
    }
  }
  return $types;
}
/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 */
function mcapi_get_state_descriptions() {
  foreach (mcapi_get_states() as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions")
    ),
    'create own wallets' => array(
      'title' => t('Create own wallets'),
      'description' => t('Users can have as many wallets as they like.')
    ),
    'manage own exchanges' => array(
      'title' => t('Manage exchanges'),
      'description' => t('Accounting permissions in all exchanges of which the user is a member')
    ),
    'configure mcapi' => array(
      'title' => t('Configure community accounting'),
      'description' => t('Design and setup the accounting system')
    ),
    'manage mcapi' => array(
      'title' => t('Manage community accounting'),
      'description' => t('Suitable for accountants')
    ),
  );
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transaction_mail_action') {//deprecated, probably
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['subject'], $params, $options);
    $message['body'][] =  token_replace($params['body'], $params, $options);
  }
  elseif ($key == 'operation') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['config']['subject'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['headers']['cc'] = $params['config']['cc'];
  }
}


/*
 * implements hook_field_extra_fields().
 */
function mcapi_field_extra_fields() {
  $extra = array(
    'user' => array(
      'user' => array(
        'display' => array(
          'mcapi_summary' => array(
            'label' => t('Trading summary'),
            'description' => t("Statistics from the user's wallets"),
            'weight' => 5,
          ),
        )
      )
    )
  );
  $props = \Drupal::entityManager()->getFieldDefinitions('mcapi_transaction');
  $fields = array('payer', 'payee', 'worths', 'description', 'state', 'type');
  foreach ($fields as $weight => $fieldname) {
    $extra['mcapi_transaction']['mcapi_transaction']['display'][$fieldname] = array(
      'label' => $props[$fieldname]['label'],
      'description' => $props[$fieldname]['description'],
      'weight' => $weight,
    );
  }
  $form = array('payer', 'payee', 'worths', 'description');
  foreach ($form as $weight => $fieldname) {
    $extra['mcapi_transaction']['mcapi_transaction']['form'][$fieldname] = array(
      'label' => $props[$fieldname]['label'],
      'description' => $props[$fieldname]['description'],
      'weight' => $weight,
    );
  }
  return $extra;
}

/**
 * Machine name callback
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 */
function mcapi_currency_load($id) {
  return entity_load('mcapi_currency', $id);
}

/**
 * get a context sensitive #options list of all the currencies (for one account)
 *
 * @param boolean $all
 *   FALSE to return only the currencies currentUser can access
 * @return array
 *   of currencies
 */
function mcapi_currency_list($all = TRUE) {
  if (!$all) {
    $currencies = exchange_currencies(referenced_exchanges(\Drupal::currentUser(), 'field_exchanges'));
  }
  if (empty($currencies)) {
    $currencies = entity_load_multiple('mcapi_currency');
  }
  $list = array();
  foreach ($currencies as $id => $currency) {
    $list[$id] = $currency->label();
  }
  return $list;
}

/**
 * return a list of exchanges from an entity_reference field in an entity
 *
 * @param EntityInterface $entity
 * @param string $fieldname
 *   the name of the field containing the exchanges, if known
 * @return array
 *   of entities, keyed by exchange id
 */
function referenced_exchanges(EntityInterface $entity, $fieldname = NULL) {
  if (!$fieldname) {
    module_load_include('inc', 'mcapi');
    get_exchange_entity_fieldnames($entity->type());
  }
  if(is_a($entity, 'Drupal\Core\Session\UserSession')) {
    $entity = entity_load('user', $entity->id());
  }
  $exchanges = array();
  foreach($entity->get($fieldname)->getValue() as $item) {
    //@todo one day we'll be able to just pull this array out rather than loading the entities ourselves
    $exchanges[$item['target_id']] =  entity_load('mcapi_exchange', $item['target_id']);
  }
  return $exchanges;
}

/**
 * get all the currencies from (common to) the given exchanges, sorted
 * @param array $exchanges
 */
function exchange_currencies(array $exchanges) {
  foreach ($exchanges as $exchange) {
    foreach ($exchange->get('field_currencies')->getValue() as $item) {
      $currency = mcapi_currency_load($item['target_id']);
      if ($currency->status) $currencies[$item['target_id']] = $currency;
    }
  }
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));
  return $currencies;
}

/**
 * Load currencies for a given user, or common to 2 given users
 * A list of all the currencies in the marketplaces of which the user is a member.
 *
 * @param AccountInterface $account
 * @param AccountInterface $account2
 * @return array
 *   of currencies
 */
function mcapi_get_available_currencies(AccountInterface $account = NULL, AccountInterface $account2 = NULL) {
  if (!isset($account)) {
    $account = \Drupal::currentUser();
  }
  else {
    $account = user_load($account->id());
  }
  $exchanges = referenced_exchanges($account, 'field_exchanges');
  if ($account2) {
    $exchanges = array_intersect($exchanges, referenced_exchanges($account2, 'field_exchanges'));
  }
  return exchange_currencies($exchanges);
}

/**
 * implements hook_mcapi_transaction_operated().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param object $plugin
 * @param TransactionInterface $transaction
 * @param array $context
 *   consists of id, the operation plugin id; config, the operation plugin configuration; old_state: the state of the transaction before the operation
 */
function mcapi_mcapi_transaction_operated($plugin, $transaction, $context) {
  //TODO invoke rules hook
  //make a note that the proper way to trigger mails is via each operations' settings
}

/**
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  return array(
    // this is used by the field API for mixed transaction forms
    'worths' => array(
      '#title' => t('Worth'),
      '#input' => TRUE,
      '#title_display' => 'before',
      '#element_validate' => array('mcapi_worths_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#process' => array('mcapi_worths_element_process'),
      '#tree' => TRUE,
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worths-element.css',
        )
      ),
      // custom properties, used for configuration
      '#mixed_mode' => \Drupal::config('mcapi.misc')->get('mix_mode'),
      '#preset' => FALSE, //ensures all currencies are showing
      '#calc' => FALSE, //allow a formula
    ),
    // this one is used internally only,
    // although you could probably use it to build a form if you wanted to ignore all multicurrency functionality
    'worth' => array(
      '#input' => TRUE,
      '#title_display' => 'attribute',
      '#process' => array('mcapi_worth_element_process'),
      '#value_callback' => 'mcapi_form_type_worth_value',
      '#element_validate' => array('mcapi_worth_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worth-element.css',
        )
      ),
      // custom properties, used for configuration
      '#calc' => FALSE,
    ),
    'mcapi_states' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_states', 'ajax_process_form'),
      '#theme_wrappers' => array('radios'),
      '#pre_render' => array('form_pre_render_conditional_form_element'),
    ),
    'mcapi_types' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_types', 'ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#theme' => 'select'
    ),
    'mcapi_currcodes' => array(
      '#input' => TRUE,
      '#title_display' => 'invisible',
      '#process' => array('mcapi_process_currcodes','ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#multiple' => TRUE,
      '#options' => array(),//array of currcodes and currency names
    )
  );
}

/**
 * process callback for worths form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worths_element_process($element, &$form_state) {
  //@todo remove this when it is tested enough
  if (!isset($element['#currencies'])) {echo 'worths element MUST have #currencies key'; mtrace();}

  //the default value also tells us which currencies are available
  //if no defaults are set then all currencies should be present
  if (!isset($element['#default_value']) || empty($element['#default_value']) || $element['#preset']) {
    $element['#default_value'] = isset($element['#default_value']) ? (array)$element['#default_value'] : array();
  }
  if ($element['#mixed_mode'] || $element['#preset']) {
    //construct one widget for each default, each with its own currcode
    foreach ($element['#currencies'] as $currcode => $currency) {
      $element[$currcode]['#title'] = $currency->human_name;
      $element[$currcode]['#currcodes']= array($currcode);
      //some dispute about whether default_value should be a worths object or an array
      if (!is_object($element['#default_value'])){
        $element['#default_value'] = (object)$element['#default_value'];
      }
      $element[$currcode]['#default_value'] = $element['#default_value']->{$currcode};
    }
  }
  else {
    $keys = array_keys($element['#currencies']);
    $key = reset($keys);
    //need to better understand what is being passed as the top level element default value
    //in order populate the default properly
    $element[0] = array(
      '#title' => t('Worth'),
      '#currcodes' => $keys,
      '#default_value' => $element['#default_value']->$key,
    );
  }

  //now populate all the subwidgets with defaults
  foreach (element_children($element) as $delta) {
    $element[$delta]['#type'] = 'worth';
    $element[$delta]['#calc'] = $element['#calc'];
    $element[$delta]['#preset'] = $element['#preset'];
  }
  return $element;
}

/**
 * element_validate callback for worths field
 * @param array $element
 * @param array $form_state
 */
function mcapi_worths_element_validate($element, &$form_state) {
  if ($element['#required']) {
    $value_entered = FALSE;

    $currencies = $element['#currcodes'];
    if (!isset($element['#mixed_mode']) || !$element['#mixed_mode']) {
      $currencies = array(reset($currencies));
    }

    foreach ($currencies as $currcode) {
      $curr_element = $element[$currcode];
      $newcode = $curr_element['currcode']['#default_value'];
if (!$newcode) drupal_set_message('problem validating worths element', 'error');
      $currency = entity_load('mcapi_currency', $newcode);
      if ($curr_element[$currency->widget]['#value'] || $curr_element[$currency->widget]['#value'] === 0) {
        $value_entered = TRUE;
        break;
      }
    }

    if (!$value_entered) {
      $elements['#required_but_empty'] = TRUE;
      if (isset($elements['#required_error'])) {
        \Drupal::formBuilder()->setError($element, $elements['#required_error']);
      }
      elseif (isset($elements['#title'])) {
        \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
      }
      else {
        \Drupal::formBuilder()->setError($element);
      }
    }
  }
}

/**
 * process callback for worth form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worth_element_process($element, &$form_state, $form) {
  $typedDataManager = \Drupal::typedData();
  if (!is_object($element['#default_value'])) {
  	$defaults = array('type' => 'field_item:worth', 'list' => TRUE);
    //TODO Gordon this isn't working.
    //$defaults need to be a \Drupal\Core\TypedData\DataDefinition\DataDefinitionInterface object
    //$element['#default_value'] = $typedDataManager->create($defaults, $element['#default_value']);
  }
  //the element is aware of a set of currcodes
  if (empty($element['#currcodes'])) {
    //best not rely on this, supply your own currencies that the user is permitted to use.
    //this defaults to all
    $element['#currcodes'] = array_keys(mcapi_get_available_currencies());
  }
  $element['currcode'] = array(
    '#title' => t('Currency'),
    '#type' => 'mcapi_currcodes',
    '#currcodes' => $element['#currcodes'],
    '#default_value' => array($element['#default_value']->currcode),
  );

  $element['currcode'] = mcapi_process_currcodes($element['currcode']);

  $parents =  $element['#parents'];
  $parents[] = 'currcode';

  $name = array_shift($parents);
  if (count($parents)) {
    $name .= '[' . implode('][', $parents) . ']';
  }

  $element['value'] = array(
    '#type' => 'value',
    '#default_value' => $element['#default_value']->value,
  );

  $currencies = entity_load_multiple('mcapi_currency', $element['#currcodes']);
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));

  foreach ($currencies as $currency) {
    $plugin = $currency->getWidgetPlugin();

    if (empty($element[$currency->widget])) {
      $element[$currency->widget] = array(
        '#title_display' => 'invisible',
      );
      if (count($element['#currcodes']) == 1) {
        $element[$currency->widget] += array(
          '#field_prefix' => $currency->prefix,
          '#field_suffix' => $currency->suffix,
        );
      }
      else {
        // Set up the dependent fields when the currency select box is changed.
        $element[$currency->widget]['#states'] = array(
          'visible' => array(
            ':input[name="' . $name . '"]' => array(
              array('value' => $currency->id()),
            ),
          ),
        );
      }

      $element[$currency->widget] = $plugin->formElement(array(0 => $element['#default_value']), 0, $element[$currency->widget], $form, $form_state);
    }
    else {
      // add the new additional currency.
      $element[$currency->widget]['#states']['visible'][':input[name="' . $name . '"]'][] = array('value' => $currency->id());
    }
  }
  return $element;
}

/**
 * element_validate callback for worth field
 * @param array $element
 * @param array $form_state
 */
function mcapi_worth_element_validate($element, &$form_state) {
//I don't like this...
  $currcode = empty($element['#value']['currcode']) ? $element['currcode']['#value'] : $element['#value']['currcode'];
if (!$currcode)drupal_set_message('problem validating worth element', 'error');

  if (!$currency = entity_load('mcapi_currency', $currcode)) {
    \Drupal::formBuilder()->setError($element, $form_state, t('%currcode is not a valid currency', array('%currcode' => $currcode)));
    return;
  }
  $plugin = $currency->getWidgetPlugin();

  $value = $element['#value'][$currency->widget];
  if (method_exists($plugin, 'asInteger')) {
    $value = $plugin->asInteger($value);
  }

  if ($element['#required'] && !$value && $value !== 0) {
    $elements['#required_but_empty'] = TRUE;
    if (isset($elements['#required_error'])) {
      \Drupal::formBuilder()->setError($element, $elements['#required_error']);
    }
    // A #title is not mandatory for form elements, but without it we cannot
    // set a form error message. So when a visible title is undesirable,
    // form constructors are encouraged to set #title anyway, and then set
    // #title_display to 'invisible'. This improves accessibility.
    elseif (isset($elements['#title'])) {
      \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
    }
    else {
      \Drupal::formBuilder()->setError($element);
    }
  }
  else {
    $values = array(
      'currcode' => $currcode,
      'value' => $value,
    );
    \Drupal::formBuilder()->setValue($element, $values, $form_state);
  }
}

/**
 * process callback for mcapi_state form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_get_states(TRUE);
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_get_types(TRUE);
  return $element;
}

/**
 * process callback for mcapi_currcodes form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  if (empty($element['#options']) && !empty($element['#currcodes'])) {
    $element['#options'] = array_intersect_key(mcapi_currency_list(), drupal_map_assoc($element['#currcodes']));
  }
  elseif (empty($element['#options'])) {
    $element['#options'] = $element['#options'] = mcapi_currency_list();
  }
  elseif ($element['#options'] == 'all') {
    $element['#options'] = mcapi_currency_list(TRUE);
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}

/**
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, users can only be blocked, not deleted
 * TODO test this
 *
 * @param array $form
 * @param array $form_state
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/*
 * implements hook_toolbar
 * adds the 'balances' icon
 */
function mcapi_toolbar() {
  if (\Drupal::currentUser()->hasPermission('configure mcapi')) {
    drupal_add_css(drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css');
  }
}


function mcapi_entity_query_alter() {
  drupal_set_message('hook_entity_query_alter');
}

/*
 * implements hook_config_translation_info().
 * Introduce dynamic translation tabs for translation of configuration.
 * //TODO
 * all config entities and field api fields have been added already
 */
function mcapi_config_translation_info(&$info) {
  //not sure how this works owing to lack of documentation but
  //I think rather than use this hook, we should use mcapi.config_translation.info
  //Here we might need to add states, types, operations
}

function mcapi_config_translation_info_alter(&$info) {
  echo 'mcapi_config_translation_info_alter';
  //print_r($info);
  //die();
}
/*
 * implements hook_config_translation_type_info_alter().
 * Associative array of configuration type definitions keyed by schema type names. The elements are themselves array with information about the type.
 * @param array $definitions
 *
 */
function mcapi_config_translation_type_info_alter(&$definitions) {
  //This has never been called as far as I can tell...
  echo 'mcapi_config_translation_type_info_alter'; print_r($definitions);die();
}

/**
 * implements hook_mcapi_transaction_children().
 * temp just to test children
 * Altering the $transaction will have no effect
 * @param TransactionInterface $transaction
 * @return array
 */
function mcapi_mcapi_transaction_children($transaction) {
  $values = array('payer' => 1,'payee' => 2, 'worths' => array('credunit' => 1));
  $transaction = entity_create('mcapi_transaction', $values);
  return array($transaction);
}

/**
 * field api default value callback
 * when editing or creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @return
 *   an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id($entity, $field_definition, $langcode) {
  $output = array();
  foreach (referenced_exchanges(\Drupal::currentUser(), 'field_exchanges') as $exchange) {
    $output[]['target_uuid'] = $exchange->get('uuid')->value;
  }
  drupal_set_message('a bug in alpha8 prevents more than one default entityreference field widget value from showing.');
  return $output;
}

/*
 * implements hook_user_create()
 * give a new wallet to every user
 */
function mcapi_user_insert($account) {
  entity_create('mcapi_wallet', array(
    'name' => 'default',
    'entity_type' => 'user',
    'pid' => $account->id(),
    'access_view' => 'dunno',
    'access_payee' => 'dunno',
    'access_payer' => 'dunno',
  ))->save();
}

/**
 * get the entity from a Request object, whatever the entitytype
 * this is quite hacky
 *
 * @param Request $request
 * @return EntityInterface object
 */
function wallet_get_params($request) {
  foreach ($request->attributes->get('_route_params') as $key => $value) {
    if (substr($key, 0, 1) == '_')continue;
    return $value;
  }
}

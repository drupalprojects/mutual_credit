<?php


use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Cache\CacheBackendInterface;

//delete modes
define('MCAPI_CURRENCY_UNDO_DELETE', 0);
define('MCAPI_CURRENCY_UNDO_ERASE', 1);
define('MCAPI_CURRENCY_UNDO_REVERSE', 2);

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//
//depending on the delete mode, erased transactions may or may not be counted
define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);



/**
 * Community Accounting API wrapper function, see transaction.api.php
 * arguments:
 *   $transaction - an object, probably originally created by entity_controller->create()
 *   $really - Boolean whether to actually save this, or just test-write and revoke.
 * Defaults to TRUE to be compatible with the Entity API 'save callback'
 */
function transaction_cluster_create(stdclass $transaction, $really = TRUE) {
  $transactions = array($transaction);
  //this is where the transaction can acquire dependents,
  drupal_alter('transaction_cluster', $transactions);
  $serial = transaction_cluster_write($transactions, $really);
  //all the transactions in the cluster have the same serial, and the same state,
  if ($really) {
    module_invoke_all('transaction_post_insert', $serial);
  }
  //the transactions have been altered I think
  return $transactions;
}

/**
 * Community Accounting API function, see transaction.api.php
 * all will be given the SAME serial number, which is what makes them a cluster
 * return the serial number if $really is TRUE
 * this should always be inside a try!!!
 */
function transaction_cluster_write(array $cluster, $really = TRUE) {
  if (!empty(current($cluster)->serial)) {
    throw new Exception ('Cannot insert transactions which already have a serial numbers: '.$transaction->serial);
  }

  //put all the transactions side by side ready for the entity controller to validate and insert
  module_invoke_all('accounting_validate', $cluster);

  $serial = entity_get_controller('mcapi_transaction')->next_serial();
  $t = db_transaction();
  $created = REQUEST_TIME -1;

  try{
    module_invoke_all('transaction_pre_insert', $cluster);
    foreach ($cluster as $transaction) {
      $transaction->serial = $serial;
      //it makes a mess of the running balances if transactions with the same serial number have the same time as well.
      $transaction->created = $created++;
      //this property is used for example in the intertrading module to save the remote participant's details.
      $transaction->data = (isset($transaction->extra)) ? $transaction->extra : array();
      //$wrapper = entity_metadata_wrapper('transaction', $transaction);
      //$wrapper->insert();
      ///TEMP
      entity_get_controller('mcapi_transaction')->insert($transaction, $really);
      //write the fields
      field_attach_insert('transaction', $transaction);
    }
    module_invoke_all('transaction_cluster_write', $cluster, $really);
  }
  catch (Exception $e) {
    $t->rollback();
    watchdog_exception('transaction', $e);
    throw $e;
  }
  if ($really) {
    return $serial;
  }
  $t->rollback();
  reset($cluster)->serial = 0;
  return $cluster;
}

/**
 * Community Accounting API wrapper function, see transaction.api.php
 * update the transaction and notify the rest of the system
 * WARNING updating a transaction will NOT update the dependent transactions
 * $transaction is the main, or volitional transaction. $children are ignored
 * $op is the machine name of the operation
 */
function transaction_update($op, $transaction, $old_state = NULL) {
  //entity_metadata_wrapper('transaction', $transaction)->update();
  entity_get_controller('mcapi_transaction')->update($transaction);
  //this will have fired
  //hook_entity_presave
  //hook_entity_insert OR hook_entity_update
  //it is rare that field API fields will have changed, but we'll just save them here to be sure.
  field_attach_update('transaction', $transaction);
  module_invoke_all('transaction_update', $op, $transaction, $old_state);

/*
  //this is a bit of a shortcut past normal rules invocation - possibly bad practice
  if (module_exists('rules') && $event = rules_get_cache('event_' . $hook)) {
    //because the rules integration only understands the type entity:transaction
    $event->executeByArgs(array($transaction, $arg1));
  }
  */
}

/*
 * Community Accounting API function, see transaction.api.php
 * Undo according to the appropriate delete mode.
 * NB No accounting checks take place before deletings.
 */
function transaction_undo($serial) {
  //load all the transactions sharing this serial as equals in an array, not as parent/children
  $xids = array_keys(transaction_filter(array('serial' => $serial)));
  $transactions = entity_load('mcapi_transaction', $xids);
  switch(\Drupal::config(mcapi.misc)->get('delete_mode')) {
    case MCAPI_CURRENCY_UNDO_ERASE:
      $transaction = current($transactions);
      $old_state = $transaction->state;
      $transaction->state = TRANSACTION_STATE_UNDONE;
      break;

    case MCAPI_CURRENCY_UNDO_DELETE:
      foreach ($transactions as $transaction) {
        field_attach_delete('transaction', $transaction);
        $xids[] = $transaction->xid;
      }
      entity_get_controller('mcapi_transaction')->delete($xids);
      entity_delete_multiple($entity_type, $xids);
      break;

    case MCAPI_CURRENCY_UNDO_REVERSE:
      foreach($transactions as $transaction) {
        $reversed = clone $transaction;
        $reversed->xid = NULL;
        $reversed->payer = $transaction->payee;
        $reversed->payee = $transaction->payer;
        $reversed->type = 'reversal';
        unset($reversed->created);
        $reversed->description = t('Reversal of: @label', array('@label' => $entity['label callback']($transaction)));
        $reverseds[] = $reversed;
      }
      try{
        //this is basically the same as in transaction_cluster_write, but without invoking accounting_validate
        entity_metadata_wrapper('transaction', $reversed)->insert(TRUE);
        field_attach_insert('transaction', $reversed);
      }
      catch (Exception $e){
        drupal_set_message(t('Failed to reverse transaction: @message', array('@message' => $e->getMessage())));
      }
      break;
  }
  module_invoke_all('transaction_undo', $serial);
  //once even one transaction has been deleted, the undo_mode cannot be changed
  \Drupal::config('mcapi.misc')->set('change_undo_mode', FALSE);
}

/**
 * Community Accounting API function, see transaction.api.php
 */
function transaction_totals($uid, $currcode = NULL, $filters = array()) {
  if (!$currcode) {
    $currencies = currencies_load();
    $currcode = key($currencies);
  }
  if (empty($filters)) {
    $filters = array(array('state', 0, '>'));
  }
  //convert it to an object for cleaner syntax in php5
  return (object)entity_get_controller('mcapi_transaction')->sums($uid, $currcode, $filters);
}

/*
 * Community Accounting API wrapper function, to load a transaction cluster by serial number
 * see transaction.api.php
 * this is used to as a menu loader, so can't be in an inc file
 * entity_load($entity_type, $ids = FALSE, $conditions = array(), $reset = FALSE)
 * This is rather awkward as it trys to key loaded transactions by serial number
 * but fieldAPI likes to receive arrays keyed by xid
 */
function transaction_load($serial = NULL) {
  //the menu system alone may call this function several times in one page request
  //so it is worth caching it
  static $loaded = array();
  //if no serial specified replace with the last transaction that this user created.
  if ($serial === NULL) {
    static $last;
    if (!$last) {
      $serials = transaction_filter(array('creator' => \Drupal::currentUser()->id()));
      if (count($serials)) $serial = max($serials);
    }
  }
  $serials = (array)$serial;
  foreach ($serials as $serial_num) {
    if (empty($loaded[$serial_num])) {
      $serials = transaction_filter(array('serial' => $serial_num));
      $transactions = entity_load('mcapi_transaction', array_keys($serials));
      if (empty($transactions)) {
        throw new Exception(t('Unable to load transaction @serial', array('@serial' => $serial_num)));
      }
      //take the first one off and make the rest its dependents, preserving their keys
      $transactions = array_reverse($transactions, TRUE);
      $transaction = array_pop($transactions);
      $transaction->dependents = $transactions;
      $loaded[$serial_num] = $transaction;
    }
  }
  //only return the one or ones we asked for
  if (is_array($serial)) return array_intersect_key($loaded, array_flip($serial));
  else return $loaded[$serial];
}


/**
 * Community Accounting API wrapper function, see transaction.api.php
 */
function transaction_filter(array $conditions, $offset = 0, $limit = 25, $fieldapi = array()) {
  if ($fieldapi) {
    $offset = 0; $limit = 0;
  }
  $serials = entity_get_controller('mcapi_transaction')->filter($conditions, $offset, $limit);
  if ($serials && $fieldapi) {
    $filtered = array();
    //we just need to load one transaction for each serial number
    $serials = array_unique($serials);//TODO ONLINE ENSURE THAT KEYS ARE PRESERVED
    foreach (entity_load('mcapi_transaction', array_keys($serials)) as $transaction) {
      foreach ($fieldapi as $fieldname => $value) {
        $items = field_get_items('transaction', $transaction, $fieldname);
        if (current($items[0]) == $value) $filtered[$transaction->xid] = $transaction->serial;
      }
    }
    $serials = $filtered;
  }
  return $serials;
}

/*
 * DRUPAL & CONTRIB HOOK IMPLEMENTATIONS
 */

/**
 * implements hook_help()
 */
function mcapi_help($section, $arg) {
  switch ($section) {
    case 'admin/accounting':
      return implode(' ', array(
        t("The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital."),
        t("This software has been five years in the conceiving and making and has been supported only by informal donations.")
      ));
    case 'admin/accounting/workflow':
      module_load_include('admin.inc', 'mcapi');
      return mcapi_workflow_help();
  }
}


/**
 * implements hook_menu()
 */
function mcapi_menu() {
  $items['admin/accounting'] = array(
    'title' => t('Accounting'),
    'description' => t("Manage all aspects of your community's money system"),
    'weight' => 2,
    'route_name' => 'mcapi.admin',
  );

  $items['admin/accounting/config'] = array(
    'title' => t('Misc settings'),
    'route_name' => 'mcapi.admin_misc',
    'weight' => 20,
  );
  $items['admin/accounting/currencies'] = array(
    'title' => t('Currencies'),
    'description' => t('Each currency implies a set of values and a community of users who economic fortunes are intertwined. Most communities will want only one currency, but if you are hosting many communities in one drupal instance, or if there is an appetite for experimentation, different currencies can be provided. User can access many potentially very different currencies. Mixed payments are also possible, but this is pushing the boundaries of the software.'),
    'route_name' => 'mcapi.admin_currency_list',
  );
  $items['admin/accounting/workflow'] = array(
    'title' => 'Workflow',
    'description' => 'Configuration around transaction states, types and operations',
    'weight' => 2,
    'route_name' => 'mcapi.workflow',
  );
  $items['transact/log'] = array(
    'title' => 'Record transaction',
    'description' => 'Log a transaction in the database',
    'route_name' => 'mcapi.transaction_log',
  );
  /*
  $operations = transaction_operations(FALSE, FALSE);

  //these are all the other exposed operations
  $items["transaction/%transaction/nojs/%"] = array(
    'page callback' => 'mcapi_get_op_form',
    'page arguments' => array(3, 1),
    'access callback' => 'entity_access',
    'access arguments' => array(3, 'transaction', 1),
    'type' => MENU_CALLBACK,
    'delivery callback' => 'drupal_deliver_html_page',
    'file' => 'mcapi.inc'
  );
  $items["transaction/%transaction/ajax/%"] = array(
    'page callback' => 'mcapi_get_op_form',
    'page arguments' => array(3, 1, 2),
    'access callback' => 'entity_access',
    'access arguments' => array(3, 'transaction', 1),
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
    'file' => 'mcapi.inc'
  );
  if (isset($info['filepath'])) {
    $items["transaction/%transaction/$ajax/%"] += array(
      'file' => $info['filepath'],
      'file path' => drupal_get_path('module', $info['module'])
    );
  }

  if ($aid = db_query("SELECT aid FROM {actions} WHERE callback = 'mcapi_transaction_mail_action'")->fetchfield()) {
    $items['admin/accounting/mail_action'] = array(
      'title' => 'Completion mails',
      'description' => 'configure mail notifications sent when the transaction completes',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('system_actions_configure', $aid),
      'access arguments' => array('administer actions'),
      'weight' => 8,
      'file' => 'system.admin.inc',
      'file path' => drupal_get_path('module', 'system')
    );
  }
  */
  return $items;
}


/**
 * implements hook_permission
 * This hook can supply permissions that the module defines.
 * doing it with another hook allows us to collect all the mutual credit permissions in one section of the permissions page
 */
function mcapi_permission() {
  return module_invoke_all('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'mcapi_transaction' => array(
      'render element' => 'transaction',
      'template' => 'transaction'
    ),
    'transaction' => array(
      'render element' => 'transaction'
    ),
    'certificate' => array(
      'template' => 'certificate',
      'pattern' => 'certificate__',
      'variables' => array(
        'object' => NULL,
        'id' => '',
        'links' => array(),
      ),
      'file' => 'mcapi.inc'
    ),
    'worth_element'=> array(
      'render element' => 'element',
    ),
    'worth_item'=> array(
      'variables' => array(
        'currcode' => NULL,
        'quantity' => '',
      ),
      'file' => 'mcapi.inc'
    ),
    'transaction_totals' => array(
      'template' => 'transaction_totals',
      'pattern' => 'transaction_totals__',
      'variables' => array(
        'currcode' => '',
        'totals' => array()
      ),
      'file' => 'mcapi.inc'
    ),
  	'balance_bars' => array(
  		'template' => 'balance_bars',
  		'variables' => array(
  			'uid' => '',
  			'currcode' => '',
  			'totals' => NULL
  		),
  	  'file' => 'mcapi.inc'
  	),
  );
  return $items;
}

/**
 * Implements hook_search_info().
 */
function mcapi_search_info() {
  return array(
    'title' => 'Transactions',
    'path' => 'transaction',
  );
}

/**
 * Implements hook_search_access().
 * the reality is more complex since the transactions are visible according to currency settings
 */
function mcapi_search_access() {
  return user_access('transact');
}

/**
 * Implements hook_search_reset().
 */
function mcapi_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'transaction')
    ->execute();
}

/**
 * Implements hook_search_status().
 * based on node_search_status()
 */
function mcapi_search_status() {
  return array(
    'remaining' => db_query("SELECT COUNT(*) FROM {mcapi_transactions} x LEFT JOIN {search_dataset} d ON d.type = 'transaction' AND d.sid = x.xid WHERE d.sid IS NULL OR d.reindex <> 0")->fetchField(),
    'total' => db_query('SELECT COUNT(*) FROM {mcapi_transactions}')->fetchField()
  );
}

/**
 * Implements hook_search_execute().
 * based on node_search_execute()
 */
function mcapi_search_execute($keys = NULL, $conditions = NULL) {
  // Build matching conditions
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery')->extend('PagerDefault');
  $query->join('mcapi_transactions', 'x', 'x.serial = i.sid');
  $query->addTag('transaction_view_access')->searchExpression($keys, 'mcapi');

  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }
  $find = $query->limit(10)->execute();
  $results = array();
  foreach ($find as $item) {
    // Render the node.
    $transaction = transaction_load($item->sid);//sid is actually the serial number
    if (!transaction_operation_access('mcapi_view', $transaction, \Drupal::currentUser())) continue;
    $uri = entity_uri('transaction', $transaction);
    $results[$item->sid] = array(
      'link' => url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE))),
      'title' => transaction_label($transaction),
      'transaction' => $transaction,
    );
  }
  krsort($results);
  return $results;
}


/**
 * Implements hook_update_index().
 */
function mcapi_update_index() {
  module_load_include('inc', 'mcapi');
  $xs = db_query("SELECT x.serial, x.xid
    FROM {mcapi_transactions} x
    LEFT JOIN {search_dataset} d ON d.type = 'transaction' AND d.sid = x.serial
    WHERE d.sid IS NULL OR d.reindex <> 0")->fetchAll();
  foreach($xs as $trans) {
    //is this achievable using GROUP BY?
    $xids[$trans->serial][] = $trans->xid;
  }

  //coz field_info_fields isn't available during update.php
  //D8 surely this is done automatically?S
  if (substr($_SERVER['SCRIPT_NAME'], -9) == 'index.php' && module_exists('field')) {
    foreach(field_info_fields() as $field) {
      if ($field['module'] == 'text' && isset($field['bundles']['transaction'])) {
        $instances[$field['field_name']] = $field['field_name'];
      }
    }
    foreach ($xids as $serial => $xids) {
      $text = array();
      foreach(instances as $fieldname) {
        $info = field_info_field($fieldname);
        $table = 'field_data_'.$fieldname;
        $column = $fieldname.'_value';
        $text[] = db_query("SELECT $column FROM {$table} WHERE entity_id IN (".implode(',', $xids).") AND entity_type = 'transaction'")->fetchField();
      }
      search_index($serial, 'mcapi', implode(' ', $text));
    }
  }
}
/*
 * implement hook_user_view().
 */
function mcapi_user_view($account, $mode, $language) {
  if ($account->id() == \Drupal::currentUser()->id() || currency_access('trader_data', 'credunit')) {
    if (\Drupal::config('mcapi.misc')->get('show_balances')) {
      module_load_include('inc', 'mcapi');
      $account->content['balances'] = mcapi_balances_view($account->uid);
    }
  }
}

/**
 * implements hook_block_info().
 */
function mcapi_block_info() {
  $blocks = array();
  if (variable_get('mcapi_show_balances', 0)) {
    $blocks[balances] = array('info' => 'MC '. t("Balances"));
  }
  return $blocks;
}

/**
 * implements hook_block_view().
 */
function mcapi_block_view($delta) {
  module_load_include('inc', 'mcapi');
  if ($settings = _mcapiblock_settings($delta, 'trader_data')) {
    if (empty($settings['account']) || empty($settings['account']->uid)) return;
    return array(
      'subject' => $settings['account']->uid == \Drupal::currentUser()->id() ?
        t('Trading status') :
        t("@user's account", array('@user' => strip_tags(format_username($settings['account'])))),
      'content' => mcapi_balances_view($settings['account']->uid, $settings['currcodes']),
      '#settings' => $settings,//this is read by mcapi_signatures_block_view_alter
    );
  }
}

/**
 * implements hook_block_configure().
 */
function mcapi_block_configure($delta, $form = array()) {
  $currencies = currencies_load();
  module_load_include('inc', 'mcapi');
  $settings = variable_get('mcapiblock_'. $delta, array('currcodes' => array(), 'user_source' => 0));
  $form['currcodes'] = currency_picker_element(array_keys($currencies), NULL, TRUE);
  $form['user_source'] = array(
    '#title' => t('User'),
    '#type' => 'radios',
    '#options' => array(
      0 => t('Show as part of profile being viewed'),
      1 => t('Show for logged in user')
    ),
  );
  foreach ($form as $fieldname => $element) {
    $form[$fieldname]['#default_value'] = @$settings[$fieldname];
  }
  return $form;
}

/*
 * implements hook_block_save().
 * used by dependent modules - save these two values
 */
function mcapi_block_save($delta, $values) {
  variable_set('mcapiblock_'. $delta,
    array(
      'currcodes' => (array)$values['currcodes'],
      'user_source' => $values['user_source']
    )
  );
}


/*
 * implements hook_init().
 * make the drupal_static variable 'currencies' available
 */
function mcapi_init() {
  drupal_add_css(drupal_get_path('module', 'mcapi') .'/mcapi.css');
}

/**
 * Implements hook_entity_info().
 */
function mcapi_entity_info(){
  //TODO
  // Search integration is provided by node.module, so search-related
  // view modes for nodes are defined here and not in search.module.
  if (module_exists('search')) {
    $entities['transaction']['view modes'] += array(
      'search_index' => array(
        'label' => t('Search index'),
        'custom settings' => FALSE,
      ),
      'search_result' => array(
        'label' => t('Search result'),
        'custom settings' => FALSE,
      ),
    );
  }
}


/**
 * implements hook_uid_renum() from uid_login module
 */
function mcapi_uid_renum($old, $new) {
  foreach(array('payer', 'payee') as $participant) {
    db_update('mcapi_transactions')->fields(array($participant => $new))->condition($participant, $old)->execute();
  }
}


/**
 * Implements ctools hook_ctools_plugin_api().
 */
function mcapi_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi'),
  );
}
/**
 * Implements ctools hook_ctools_plugin_directory().
 */
function mcapi_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/export_ui';//directory
  }
}
/**
 * Implements views hook_views_api().
 */
function mcapi_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi') . '/views',
  );
}

/**
 * menu callback for adding transaction entity
 */
function transaction_form($form, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  $arg0 = &$form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG];

  if (!empty($arg0) && !is_object($arg0)) {
    throw new Exception('Bad argument passed to transaction_form(): '.print_r($arg0, 1));
  }
  //populate the form's #transaction either with submitted values, or with the build argument, or with an empty transaction
  $form['#transaction'] = isset($form_state['values']) ? entity_create('transaction', $form_state['values']) : (
    !empty($arg0) ? $arg0 : entity_create('transaction', array()));

  _transaction_form($form, $form_state);
  //this determines whether the function calls transaction_cluster_create() or transaction_cluster_write()
  $form['#validate'] = array('transaction_form_validate');
  $form['#submit'] = array('transaction_form_submit');
  return $form;
}


/**
 * implements hook_accounting_validate
 * Some wiggle room has been left in case for any reason we want to store transactions with missing fields
 */
function mcapi_accounting_validate($transactions){
  $errors = array();
  foreach ($transactions as $key => $transaction) {
    //no usecase is currently envisaged where someone might pay themselves in one currency in one transaction
    if ($transaction->payer > 0) {
      if ($transaction->payer == $transaction->payee) {
        if ($key == 0) {
          $errors[] = t('A transaction must involve two different users');
        }
        else {
          unset($transactions[$key]);
        }
      }
    }
    //a transaction can only be finished if all these fields are filled in.
    if ($transaction->state >= TRANSACTION_STATE_FINISHED) {
      $required = array('payer', 'payee',  'type');
      foreach ($required as $fieldname) {
        if (!$transaction->$fieldname) {
          $errors[] = t("@fieldname required for completed transaction", array('@fieldname' => $fieldname));
        }
      }
    }
  }
  if ($errors) {
    throw new Exception(implode("<br />", $errors));
  }
}

/**
 * implements mcapi hook_info_controller().
 * the presence of this hook indicates there is a .controller file
 * with the name MODULE.controller
 */
function mcapi_transaction_controller(){}

/**
 * implements mcapi hook_info_states().
 * DON"T call this hook directly as the keys will be lost. use mcapi_get_states()
 */
function mcapi_mcapi_info_states() {
  $states = array(
    TRANSACTION_STATE_FINISHED => array(
      'name' => t('Cleared'),
      'description' => t('the last state of the workflow'),
      'default_access_callbacks' => array('mcapi_access_authenticated')
    ),
  );
  $deletemode = \Drupal::config('mcapi.misc')->get('delete_mode');
  //don't attempt to liven the link coz this function can run while bootstrapping and that means trouble
  $description = t("See 'delete mode' settings for more info, !link", array('!link' => 'admin/accounting/misc'));
  if ($deletemode != MCAPI_CURRENCY_UNDO_DELETE) {
    $states[TRANSACTION_STATE_UNDONE] = array(
      'name' => t('Undone'),
      'description' => $description,
      'default_access_callbacks' => array()
    );
  }
  return $states;
}

/**
 * Implements hook_field_display_ENTITY_TYPE_alter().
 */
function mcapi_field_display_transaction_alter(&$display, $context) {
  // Hide field labels in search index.
  if ($context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}


/**
 * implements mcapi hook_info_types().
 */
function mcapi_mcapi_info_types() {
  $types = array('default', 'dependent');
  if (\Drupal::config('mcapi.misc')->get('delete_mode') == MCAPI_CURRENCY_UNDO_REVERSE) {
    $types[] = 'reversal';
  }
  return $types;
}

/**
 * gather up all the transaction states from the hooks and present them in a given format
 * #options is suitable for choosing in a form element
 * #description is suitable for a chunk of description text explaining what the states mean
 * #full is the full array returned from the callback, keyed by constant value
 */
function mcapi_get_states($return_mode = '#options') {
  static $states;
  if (empty($states)) {
    $states = array();
    foreach(module_implements('mcapi_info_states') as $module) {
      $function = $module . '_mcapi_info_states';
      $states += $function('states');
    }
  }
  if ($return_mode == '#full') return $states;
  elseif ($return_mode == '#description') {
    foreach ($states as $key => $state) {
      $desc[] = $state['name'] .' - '. $state['description'] .'.';
    }
    return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
  }
  else {//suitable for a dropdown
    foreach ($states as $key => $state) {
      $options[$key] = $state['name'];
    }
    return $options;
  }
  return $states;
}
//returns the available transaction types in an associative array
function mcapi_get_types() {
  foreach (module_invoke_all('mcapi_info_types') as $type) {
    $types[$type] = $type;
  }
  return $types;
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 * make permissions appear altogether on the permissions page
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency')
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    )
  );
}


/**
 * implements hook mcapi_permissions().
 * each callback refers to 2 functions - itself and CALLBACK_views
 * Declare the access callbacks for (transactions in) currencies
 * each callback takes the following args
 * $transaction, $account
 * Multiple callbacks can be selected and access will be granted if any returns TRUE
 */
function mcapi_transaction_access_callbacks() {
  return array(
    'transaction_access_callback_perm_transact' => t("Users with permission to '@perm'", array('@perm' => t('Transact'))),
    'transaction_access_callback_perm_manage_all' => t("Users with permission to '@perm'", array('@perm' => t('Manage all transactions'))),
    'transaction_access_callback_payee' => t('The payee in the transaction'),
    'transaction_access_callback_payer' => t('The payer in the transaction'),
    'transaction_access_callback_open' => t('Anyone, even anonymous users'),
    'transaction_access_callback_creator' => t('The creator of the transaction'),
  );
}


/*
 * implements hook_user_delete().
* all transactions revert to the reservoir
*/
function mcapi_user_delete($account) {
	foreach (currencies_load($account) as $currency) {
		entity_get_controller('transaction')->mergeAccounts($currency->reservoir, $account->uid);
	}
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transaction_mail_action') {
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['subject'], $params, $options);
    $message['body'][] =  token_replace($params['body'], $params, $options);
  }
  elseif ($key == 'operation') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['config']['subject'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['headers']['cc'] = $params['config']['cc'];
    $message['headers']['bcc'] = $params['config']['bcc'];
  }
}

/**
 * implements hook_mail_alter().
 * add the cc
 */
function mcapi_mail_alter(&$message) {
  if (isset($message['params']['cc'])) {
    $message['headers']['Cc'] = $message['params']['cc'];
  }
}

/**
 * access control for currency
 * there are three ops possible
 * - membership
 * - trader_data
 * - system_data
 * each containing a permission
 */
function currency_access($op, $currcode, $account = NULL) {
  if (!$account) $account = \Drupal::currentUser();
  $uid = is_object($account) ? $account->uid : \Drupal::currentUser()->id();
  static $calculated = array();
  if (!isset($calculated[$op][$currcode][$uid])) {
    $currency = entity_load('mcapi_currencies', $currcode);
    $callback = strtok($currency->access[$op], ':');
    $arg = strtok(':');
    $calculated[$op][$currcode][$uid] = in_user_chooser_segment($callback, array($arg), $account->uid);
  }
  return $calculated[$op][$currcode][$uid];
}


/**
 * menu callback (also declared as $entity_info['view callback'])
 * build a render array for any number of transactions
 * first arg can be one or an array of transactions, WITH CHILDREN LOADED as in transaction_load
 * not sure what the best file for this function is, not that it works in conjunction with the preprocess
 * $transactions an array of transactions, keyed by xid, each one having its dependents already set
 * $view mode, defaults to token with the saved transaction sentence, but an arbitrary token string can also be used
 */
function transaction_view($transactions, $view_mode = 'certificate', $suppress_ops = FALSE) {
  if (!is_array($transactions))$transactions = array($transactions->xid => $transactions);

  global $language;
  //special case for the 'are you sure' form where the transaction was test written and deleted
  //that means the fieldAPI data cannot be retrieved the normal way
  $transaction = &current($transactions);
  if (!property_exists($transaction, 'serial') || empty($transaction->serial)) {
    foreach ($transactions as $transaction) {
      $variables['classes_array'][] = 'preview';
      //remove all fieldAPI fields because the entity isn't in the database yet and doesn't have an entity_id
      foreach (field_info_instances('transaction', 'transaction') as $fieldname => $instance) {
        unset($transaction->{$fieldname});
      }
    }
  }
  else {
    field_attach_prepare_view('transaction', $transactions, 'certificate');
  }
  entity_prepare_view('transaction', $transactions);

  foreach ($transactions as $transaction) {
    $tx = array(
      '#theme_wrappers' => array('transaction'),
      '#class' => array(
         'transaction',
         $view_mode == 'certificate' ? 'certificate' : 'sentence',
         'state-'.$transaction->state,
         $transaction->type
      ),
      '#object' => $transaction,
    );
    switch ($view_mode) {
      case 'certificate':
        $tx['#theme'] = 'certificate';
        //we will reveal the ajax links only on the certificate
        $tx['#links'] = $suppress_ops ? array() : transaction_get_links($transaction, TRUE, FALSE);
        break;
      default: //an arbitrary token string, don't forget there is a token for [transaction:links]
        $tx['#markup'] = token_replace(
          $view_mode,
          array('transaction' => $transaction),
          array('language' => $language, 'sanitize' => FALSE)
        );
        break;
    }
    $renderable['transaction'][$transaction->xid] = $tx;
  }
  $type = 'transaction';//must be sent as a reference
  drupal_alter(array('transaction_view', 'entity_view'), $renderable, $type);
  return $renderable;
}

/**
 * theme wrapper implementation
 * a wrapper round transactions of all view modes
 * puts the operations after the transaction
 */
function theme_transaction($vars) {
  $transaction = $vars['transaction'];
  if (property_exists($transaction['#object'], 'serial')) {
    $transaction['#id'] = 'transaction-'. $transaction['#object']->serial;
  }
  element_set_attributes($transaction, array('class', 'id'));
  //id is hardcoded here because ajax operations will break if it changes
  return '<div '. $transaction['#attributes'] . '>
    '. $transaction['#children'] .'
  </div>';
}

function mcapi_currencies_load($currcode) {
  return entity_load('mcapi_currencies', $currcode);
}

function mcapi_get_available_currencies(AccountInterface $account = NULL) {
  if (!isset($account)) {
    $account = \Drupal::currentUser();
  }
  $cid = 'currencies:' . $account->id();

  if (!$cache = \Drupal::cache()->get($cid)) {
    $avaiable = array();
    foreach (entity_load_multiple('mcapi_currencies') as $currency) {
      if ($currency->access('membership', $account)) {
        $avaiable[$currency->id()] = $currency->name;
      }
    }
    \Drupal::cache()->set($cid, $avaiable, CacheBackendInterface::CACHE_PERMANENT, array('mcapi.available_currency'));
    return $avaiable;
  }
  else {
    return $cache->data;
  }
}

/**
 * return one currency object, assuming the user has permission to use it
 */
function currency_load($currcode = NULL) {
  $currencies = currencies_load();
  if (empty($currencies))currencies_load();//filters
  if ($currcode && isset($currencies[$currcode])) {
    return $currencies[$currcode];
  }
  watchdog('mcapi', "Nonexistent currency '@currcode' requested from: @list",
    array('@currcode' => $currcode, '@list' => print_r(array_keys($currencies), 1))
  );
  return current($currencies);
}

/**
 * TODO: Remove this function in favour of the entity_load_multiple() and entity_load_multiple_by_properties().
 * Load all the currencies from cache filter
 * then optionally return them filtered for which ones an account has membership i.e. can use
 * wish I understood ctools better. not sure I need to cache here
 */
function currencies_load($account = NULL) {
  $currencies = &drupal_static(__FUNCTION__);
  if (empty($currencies)) {//first time this function is running
    if ($cache = \Drupal::cache()->get('currencies')) {
      $currencies = $cache->data;
    }
    else {
      module_load_include('admin.inc', 'mcapi');
      foreach (currencies_load_all() as $currcode => $currency) {
        $currencies[$currcode] = $currency->data;
      }
      cache()->set('currencies', $currencies);
    }
  }
  if (!$account) return $currencies;//having set the $currencies static

  $filtered = array();
  module_load_include('inc', 'mcapi');
  foreach ($currencies as $currcode => $currency) {
    if ($account->uid && currency_access('membership', $currcode, $account)) {
      //we're actually stripping the ctools metadata wrapper of the currency away here for convenience everywhere else
      $filtered[$currcode] = $currency;
    }
  }
  return $filtered;
}

function currencies_filter() {
  $currencies = currencies_load();
  $output = array();
  $args = func_get_args();
  foreach ($currencies as $currcode => $currency) {
    if (property_exists($currency, 'issuance') && in_array($currency->issuance, $args)) $output[$currcode] = $currency;
  }
  return $output;
}

/**
 * returns some or all of the operations, from hook_transaction_operations
 */
function transaction_operations($localize = '1', $all = '0') {
  $all_operations = &drupal_static(__FUNCTION__);
  static $preloaded = array();
  $key = strval($localize).strval($all);
  if (empty($all_operations)) {
    $data = cache()->get('transaction_operations');
    if (is_object($data)) {
      $all_operations = $data->data;
    }
    else {
      module_load_include('admin.inc', 'mcapi');
      $all_operations = _transaction_operations();
    }
  }
  if (!isset($preloaded[$key])) {
    $t = 't'; //this prevents potx.module from noticing these non-literal strings
    //we're caching up to 4 versions of this array based on the incoming args
    $preloaded[$key] = $all_operations;
    foreach ($preloaded[$key] as $op => $info) {
      if (array_key_exists('weight', $info)) {
        //translate the title and description of all (non-internal) operations
        if ($localize) {
          foreach (array('title', 'description') as $prop) {
            if (array_key_exists($prop, $info)) {
              $preloaded[$key][$op][$prop] = $t($info[$prop]);
            }
          }
        }
      }
      elseif (!$all) {
        //remove internal operations which have no weight
        unset($preloaded[$key][$op]);
      }
    }
  }
  return $preloaded[$key];
}

/**
 * default form for configuring access to operations, per currency
 */
function operations_config_default_access($op_info, $currency) {
  static $access_callbacks;
  if (!$access_callbacks) {
    $access_callbacks = module_invoke_all('transaction_access_callbacks');
  }
  $element = array(
    '#title' => $op_info['title'],
    '#description' => array_key_exists('description', $op_info) ? $op_info['description'] : '',
    '#type' => 'checkboxes',
    '#options' => $access_callbacks,
    '#default_value' => array(),//this will be overwritten
    '#weight' => @$op_info['weight'],
  );
  $callback = $op_info['op'];
  if (property_exists($currency, 'access_operations') && array_key_exists($callback, $currency->access_operations)) {
    $element['#default_value'] = $currency->access_operations[$callback];
  }
  return $element;
}

/*
 * implements hook_trigger_info().
 * we need a trigger for each transaction_operation
 * TODO convert these into rules, or something
 */
function __mcapi_trigger_info() {
  $triggers['mcapi']['transaction_cluster_alter']['label'] = t('Create dependent transactions before inserting.');
  $triggers['mcapi']['transaction_undo']['label'] = t('Respond to transaction deletion.');
  $triggers['mcapi']['transaction_update']['label'] = t('Respond to transaction changing.');
  $triggers['mcapi']['transaction_post_insert']['label'] = t('Respond to a new transaction.');
  return $triggers;
}

/*
 * pull trigger transaction_cluster_alter().
 * will only fire if the trigger module is enabled
 * sends the volitional transaction to the action callbacks where it can be changed.
 * Action callbacks may return a new transaction to be added to the $transactions
 */
function trigger_transaction_cluster_alter(&$cluster) {
  foreach (trigger_get_assigned_actions('transaction_cluster_alter') as $aid => $info) {
    module_load_include('admin.inc', 'mcapi');
    //each action might return ONE transaction object
    $volitional_transaction = reset($cluster);
    $result = actions_do($aid, $volitional_transaction, $info);
    if (is_object($result[$aid])) {
      $cluster[] = $result[$aid];
    }
  }
}

/*
 * pull trigger transaction_update().
 * if the $old_state is set, that indicates this was a workflow operation
 */
function trigger_transaction_update($op, $transaction, $old_state = NULL) {
  foreach (trigger_get_assigned_actions('transaction_update') as $aid => $info) {
    actions_do($aid, $transaction, $info, $old_state);
  }
}

/*
 * pull trigger transaction_undo().
 * if the $old_state is set, that indicates this was a workflow operation
 */
function trigger_transaction_undo($serial) {
  foreach (trigger_get_assigned_actions('transaction_undo') as $aid => $info) {
    actions_do($aid, transaction_load($serial), $info);
  }
}


/*
 * Everything below here concerns the 'worth' fieldAPI field and the 2 elements which it uses
 * A multiple cardinality field modified to store amounts in each currency
 * It's not a perfect solution
 * The field stores a decimal, so for hour currencies, divisble by 60, it only stores with a granularity of quarters
 * According to the currency settings, the widget can show main_quant and a div_quant for the one value
 *
 */


/*
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  return array(
    //this is used by the field API for mixed transaction forms
    'worths' => array(
      '#title' => t('Worth'),
      '#input' => TRUE,
      '#title_display' => 'before',
      '#element_validate' => array('mcapi_worths_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#process' => array('mcapi_worths_element_process'),
      '#tree' => TRUE,
      '#value_callback' => 'mcapi_form_type_worths_value',
      //custom properties, used for configuration
      '#preset' => FALSE,//ensures all currencies are showing
      '#calc' => FALSE,//allow a formula
    ),
    //this one is used internally only,
    //although you could probably use it to build a form if you wanted to ignore all multicurrency functionality
    'worth' => array(
      '#input' => TRUE,
      '#title_display' => 'attribute',
      '#process' => array('mcapi_worth_element_process'),
      '#element_validate' => array('mcapi_worth_element_validate'),
      '#theme' => 'worth_element',
      //custom properties, used for configuration
      '#calc' => FALSE,
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/mcapi.worth-widget.css',
        )
      ),
    )
  );
}

/*
 * element process callback
 * is called once for each $item
 */
function mcapi_worth_element_process($element, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  return _worth_element_process($element, $form_state);
}

/*
 * element process callback
 * break up the worths values into individual fields
 * According to the mixed currency mode,
 * either one widget with a currency chooser
 * or many widgets with fixed currencies
 * $element['default_value'] is an array of all the currencies to be rendered as keys against quantitites
 */
function mcapi_worths_element_process($element, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  return _worths_element_process($element, $form_state);
}

/*
 * implements form_type_ELEMENT_NAME_value
 * default value_callback for worths
 */
function mcapi_form_type_worths_value(&$element, $edit = FALSE, &$form_state) {
  if ($edit == FALSE) {
    return;
  }

  $value = array();

  foreach ($edit as $delta => $item) {
    $value[$delta]['currcode'] = $item['currcode'];

    if (!strlen($item['main_quant']) && empty($item['div_quant'])) {
      $value[$delta]['quantity'] = '';
    }
    elseif (is_numeric($item['main_quant']) || empty($item['main_quant'])) {
      $value[$delta]['quantity'] = floatval($item['main_quant']);
      if (!empty($item['div_quant'])) {
        $value[$delta]['quantity'] += ($item['div_quant'] + 0) / 100;
      }
    }
    elseif ($element['#calc']) {
      $value[$delta]['quantity'] = $item['main_quant'];
    }

    //set the value to zero if the field is empty and the currency allows it
    $currency = entity_load('mcapi_currencies', $item['currcode']);
    //we can remove the @ when everybody has upgraded to RC6
    if (empty($value[$delta]['quantity']) && $currency->display['zero']) {
      $value[$delta]['quantity'] = '0';
    }
    elseif(empty($value[$delta]['quantity']) && empty($element['#preset'])) {
      unset($value[$delta]);
    }
  }

  return $value;
}

/*
 * implements hook_field_validate().
 * check if the current user has permission to use the currency in this flow.
 * if $entity is not set that means the field was used in configuration somewhere
 */
function mcapi_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $currencies = currencies_load();
  foreach ($items as $delta => $item) {
    if ($entity_type == 'transaction' && $entity) {
      $currency = $currencies[$item['currcode']];
      //check that each user has permission to use the currency in each item
      foreach (array('payer', 'payee') as $uid) {
        if (currency_access('membership', $item['currcode'])) continue;
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'currency_access_membership',
          'message' => t('User @name cannot use @currency', array('@name' => user_load($entity->$uid)->name, '@currency' => $currency->name))
        );
      }
    }
  }
  //this must be the final check in this function
  //checks that at least one of the $items is populated
  if (!empty($entity) && $instance['required']) {
    if (count($items)) return;
    $errors[$field['field_name']][$langcode][][] = array(
      'error' => 'mcapi_empty_worth',
      'message' =>  t('!name field is required.', array('!name' => $instance['label']))
    );
  }
}

/**
 * Implements hook_field_widget_error().
 * values come from mcapi_field_validate
 * $element here is always worths_element
 */
function mcapi_field_widget_error(&$element, $error, $form, &$form_state) {
  return form_error($element, $error['message']);
}
/*
 * implements field hook_field_is_empty().
 * allows zero values to be saved, but not NULL
 */
function mcapi_field_is_empty($item) {
  return !(array_key_exists('quantity', $item) && strlen($item['quantity']));
}


/*
 * implements hook_form_field_ui_field_edit_form_alter().
 * remove the default 'worth' setting from the field settings form i.e. cardinality
 * tell the widget that it is in config mode
 */
/*
function mcapi_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'worth_field') {
    unset($form['field']['#type']);
    $form['field']['cardinality'] = array(
      '#type' => 'hidden',
      '#value' => $form['#field']['cardinality'] //leave this value unchanged, it is manipulated elsewhere
   );
  }
  $form['instance']['default_value_widget']['worth'][LANGUAGE_NONE]['#preset'] = TRUE;
}
*/
/*
 * Imlements hook_form_form_ID_alter().
 * prevents editing of the worth field attached to the transaction entity.
 */
function mcapi_form_field_ui_field_overview_form_alter(&$form, $form_state) {
  if ($form['#entity_type'] == 'transaction' && isset($form['fields']['worth'])) {
    //TODO: we need to make these pages innaccessible
    //tricky because the paths use variables I think
    $form['fields']['worth']['type']['#type'] = 'markup';
    $form['fields']['worth']['widget_type']['#type'] = 'markup';
    $form['fields']['worth']['delete']['#type'] = 'markup';
  }
}


//this is a property callback for the worth field in mcapi_field_info
function worthfield_property_info_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$field['field_name']];
  $property['type'] = ($field['cardinality'] != 1) ? 'list<worthfield>' : 'worthfield';
  $property['getter callback'] = 'entity_metadata_field_verbatim_get';
  $property['setter callback'] = 'entity_metadata_field_verbatim_set';
//  $property['auto creation'] = 'worthfield_default_values';
  $property['property info'] = worthfield_data_property_info();
  unset($property['query callback']);
}

function _currcode_options() {
  foreach (currencies_load(\Drupal::currentUser()) as $currcode => $currency) {
    $options[$currcode] = $currency->name;
  }
  return $options;
}




function _worthitems_to_worths(array $worthitems) {
  $currencies = currencies_load();
  $worths = array();
  foreach ($worthitems as $worth_item) {
    if (isset($currencies[$worth_item['currcode']])) {
      $worths[$worth_item['currcode']] = $worth_item['quantity'];
    }
  }
  return $worths;
}


/*
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, they can only be blocked, not deleted
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  form_load_include($form_state, 'admin.inc', 'mcapi');
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/*
 * implements alter hook_user_cancel_methods().
 * creates a new method
 */
function mcapi_user_cancel_methods_alter(&$methods) {
  module_load_include('admin.inc', 'mcapi');
  $methods['user_cancel_mcapi'] = array(
    'title' => t('Disable the account and delete its content.'),
    'description' => t('Your account will be blocked and you will no longer be able to log in. All of your content will be deleted.'),
  );
}

/*
 * Validate callback for transaction form 'type' element
 */
function mcapi_validate_ttype(&$element, $form_state) {
  $values = is_array($element['#value']) ? $element['#value'] : array($element['#value']);
  foreach ($values as $value) {
    if (!in_array($value, module_invoke_all('mcapi_info_types'))) {
      form_error($element, t('Invalid transaction type: @value', array('@value' => $value)));
    }
  }
}

/*
 * implements restws module's hook_restws_response_alter().
 * After creating a transaction return not the transaction enttity key,
 * as presumed by restws_resource_uri()
 * but the serial number, which is what the client needs to view the transaction.
 */
function mcapi_restws_response_alter(&$ref, $function) {
  if ($function != 'createResource') return;
  $ref['uri'] = str_replace($ref['id'], current(entity_load('mcapi_transaction', array($ref['id'])))->serial,  $ref['uri']);
}

function mcapi_operation_include($info) {
  $included = &drupal_static(__FUNCTION__, array());
  if (empty($included)) {
    //the default access control function _transaction_check_access_callbacks is in mcapi.inc
    module_load_include('inc', 'mcapi');
    $included['mcapi.inc'] = 1;
  }
  //array_key_exists is faster than in_array()
  if (array_key_exists('filepath', $info)) {
    if (!array_key_exists($info['filepath'], $included)) {
      require_once DRUPAL_ROOT . '/' . drupal_get_path('module', $info['module']) ."/". $info['filepath'];
      $included[$info['filepath']] = 1;
    }
  }
}

function mcapi_toolbar() {
  if (\Drupal::currentUser()->hasPermission('manage all transactions')) {
    drupal_add_css(drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css');
  }
}

/*
 * form field validate callback
 * used in operations settings form for the cc addresses
 */
function mcapi_validate_emails(&$element, &$form_state) {
  $mails = $element['#value'];
  foreach(explode(',', $mails) as $mail) {
    $element['#value'] = trim($mail);
    form_validate_email($element, $form_state);
  }
}

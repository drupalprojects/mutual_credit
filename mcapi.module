<?php


use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\mcapi\Plugin\Field\FieldType\Worth;

define('CURRENCY_WIDGET_SINGLEFIELD', 1);
define('CURRENCY_WIDGET_TEXT', 2);
define('CURRENCY_WIDGET_SELECT', 3);

define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//

define('TRANSACTION_STATE_UNDONE', 0);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {

    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorageController('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * implements hook_menu()
 */
function mcapi_menu() {
  $items['admin/accounting'] = array(
    'title' => 'Accounting',
    'description' => "Manage all aspects of your community's money system",
    'route_name' => 'mcapi.admin',
    'position' => 'right',
  );
  $items['admin/accounting/config'] = array(
    'title' => 'Settings',
    'description' => 'Miscellaneous settings which effect the system globally.',
    'route_name' => 'mcapi.admin_misc',
    'weight' => 20,
  );
  $items['admin/accounting/currencies'] = array(
    'title' => 'Currencies',
    'description' => 'Each currency implies a set of values and a community of users who economic fortunes are intertwined.',
    'route_name' => 'mcapi.admin_currency_list',
  );
  $items['admin/accounting/mass'] = array(
    'title' => 'Mass payments',
    'description' => 'Pay between one account and many.',
    'route_name' => 'mcapi.admin_mass',
  );
  $items['admin/accounting/workflow'] = array(
    'title' => 'Transaction workflow',
    'description' => 'Configuration around transaction states, types and operations.',
    'weight' => 2,
    'route_name' => 'mcapi.workflow',
  );
  $items['admin/accounting/workflow/operations'] = array(
    'title' => 'Transaction workflow operations',
    'description' => 'Configure the user experience for transaction operations.',
    'weight' => 2,
    'route_name' => 'mcapi.workflow.operations',
  );
  /*
  $items['transact/admin'] = array(
    'title' => 'Record transaction',
    'description' => 'Log a transaction in the database',
    'route_name' => 'mcapi.transaction_admin',
  );
  */
  return $items;
}

function mcapi_transaction_load($serial) {
  return current(entity_load_multiple('mcapi_transaction', array('serial' => $serial)));
}

/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($path, $arg) {
  switch ($path) {
    case 'admin/accounting':
      return implode(' ', array(
        t("The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital."),
        t("This software has been five years in the conceiving and making and has been supported only by informal donations.")
      ));
    case 'admin/accounting/currencies':
      return implode(' ', array(
        t('Most community projects now have only one currency.'),
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.')
      ));
    case 'admin/accounting/workflow':
      //TODO how do we make this show at the top of a menu page without help module?
      module_load_include('inc', 'mcapi');
      $renderable = _workflow_help();
      return drupal_render($renderable);
      return implode(' ', array(
        t('Different transaction user stories can be configured here, although the actual structure has to be defined in code.')
      ));
    case 'admin/accounting/workflow/operations':
      return implode(' ', array(
        t("The workflow is about moving transactions between states. This is always done with a 'confirm' form."),
        t("The confirm forms are configured on this page.")
      ));
  }
}

/**
 * get a transaction operation plugin or array of all plugins
 *
 * @param string $op_name
 *   the plugin id of the operation
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 */
function transaction_operations($op_name = NULL) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_operation');
    foreach ($manager->getDefinitions() as $op => $info) {
      $plugins[$op] = $manager->createInstance($op);
    }
  }
  if ($op_name) return $plugins[$op_name];
  else return $plugins;
}

/**
 * get a transaction access plugin or array of all plugins
 *
 * @param string $options
 *   return just the plugin names, suitable for a formAPI select widget #options
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 */
function transaction_access_plugins($options = FALSE) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_access');
    foreach ($manager->getDefinitions() as $plugin => $info) {
      $plugins[$plugin] = $manager->createInstance($plugin);
    }
  }
  if ($options) {
    $names = array();
    foreach ($plugins as $key => $info) {
      $names[$key] = $info->label();
    }
    return $names;
  }
  else return $plugins;
}


/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'mcapi_transaction' => array(
      'render element' => 'transaction',
      'template' => 'transaction',
      'file' => 'mcapi.inc'
    ),
    //the above is the theme wrapper for the below
    //so they both take the same render_element
    'certificate' => array(
      'render element' => 'transaction',
      'template' => 'certificate',
      'pattern' => 'certificate__',
      'file' => 'mcapi.inc'
    ),
    'mcapi_twig' => array(
      'variables' => array(
    	  'mcapi_transaction' => NULL,
        'twig' => '',
        'showlinks' => FALSE
      ),
      'file' => 'mcapi.inc'
    ),
    'worth_element'=> array(
      'render element' => 'element',
    ),
    'mcapi_summary' => array(
      'template' => 'mcapi_summary',
      //might be appropriate to have a per-currency pattern here
      'variables' => array(
        'account' => NULL,
        'currency' => NULL,
        'balance' => 0,
        'gross_in' => 0,
        'gross_out' => 0,
        'volume' => 0,
        'count' => 0,
        'partners' => 0,
      ),
    ),
    //TODO
    'balance_bars' => array(
      'template' => 'balance_bars',
      'variables' => array(
        'account' => '',
        'currency' => '',
      ),
      'file' => 'mcapi.inc'
    ),
    'balance_histories_gchart' => array(
      'template' => 'balance_histories_gchart',
      'variables' => array(
        'account' => NULL,
        'currcodes' =>array(),
        'width' => 250,
        'resample' => 'simple'
      ),
      'file' => 'mcapi.inc'
    )
  );
  return $items;
}

/**
 * implements hook_user_view().
 */
function mcapi_user_view($account, $mode, $language) {
  module_load_include('inc', 'mcapi');
  $account->content['mcapi_summary'] = mcapi_view_user_summary($account);
  $account->content['mcapi_summary']['#weight'] = 3;
}

/**
 * just gets the children and puts them side by side with the parent so they are easier to iterate through
 */
function mcapi_transaction_flatten($transaction) {
  $cluster = array($transaction);
  foreach ($transaction->children as $child) {
    $cluster[] = $child;
  }
  return $cluster;
}


/**
 * get all the transaction state entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The states, either full config entity objects, or just keys and names
 */
function mcapi_get_states($options = FALSE) {
  $states = entity_load_multiple('mcapi_state');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($states as $key => $state) {
      $pairs[$state->value] = $state->label;
    }
    return $pairs;
  }
  return $states;
}

/**
 * get all the transaction type entities
 *
 * @param boolean $options
 *   whether to return an array suitable for populating a formAPI select widget
 *
 * @return array
 *   The types, either full config entity objects, or just keys and names
 */
function mcapi_get_types($options = FALSE) {
  $types = entity_load_multiple('mcapi_type');
  //each state is an object with id, label, description & value
  if ($options) {
    foreach ($types as $key => $type) {
      $types[$key] = $type->label;
    }
  }
  return $types;
}
/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 */
function mcapi_get_state_descriptions() {
  foreach (mcapi_get_states() as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency')
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    )
  );
}

/**
 * implements hook_mail().
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transaction_mail_action') {//deprecated, probably
    // We do not sanitize the token replacement, since the output of this
    // replacement is intended for an e-mail message, not a web browser.
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['subject'], $params, $options);
    $message['body'][] =  token_replace($params['body'], $params, $options);
  }
  elseif ($key == 'operation') {
    $options = array('language' => $message['language'], 'sanitize' => FALSE);
    $message['subject'] =  token_replace($params['config']['subject'], $params, $options);
    $message['body'][] =  token_replace($params['config']['body'], $params, $options);
    $message['headers']['cc'] = $params['config']['cc'];
  }
}


/*
 * implements hook_field_extra_fields().
 */
function mcapi_field_extra_fields() {
  $extra = array(
    'user' => array(
      'user' => array(
        'display' => array(
          'mcapi_summary' => array(
            'label' => t('Trading summary'),
            'description' => t("Statistics from the user's transaction history"),
            'weight' => 0,
          )
        )
      )
    )
  );
  $props = \Drupal::entityManager()->getFieldDefinitions('mcapi_transaction');
  $fields = array('payer', 'payee', 'worths', 'description', 'state', 'type');
  $form = array('payer', 'payee', 'worths', 'description');
  foreach ($fields as $weight => $fieldname) {
    $extra['mcapi_transaction']['mcapi_transaction']['display'][$fieldname] = array(
      'label' => $props[$fieldname]['label'],
      'description' => $props[$fieldname]['description'],
      'weight' => $weight,
    );
    $extra['mcapi_transaction']['mcapi_transaction']['form'][$fieldname] = array(
      'label' => $props[$fieldname]['label'],
      'description' => $props[$fieldname]['description'],
      'weight' => $weight,
    );
  }
  return $extra;
}

/**
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 */
function mcapi_currency_load($id) {
  return entity_load('mcapi_currency', $id);
}

/**
 * get an #options list of all the currencies (for one account)
 *
 * @param array $currencies
 * @param AccountInterface $account
 * @param boolean $check_access
 *   TRUE to return only the currencies the $account can access
 * @return array
 *   of currencies
 */
function mcapi_currency_list(array $currencies = NULL, AccountInterface $account = NULL, $check_access = TRUE) {
  $list = array();

  if (!$account || $check_access) {
    $account = \Drupal::currentUser();
  }

  if (empty($currencies)) {
    if ($check_access) {
      $currencies = mcapi_get_available_currencies($account);
      $check_access = FALSE; // No need to check the access again, so set it to false;
    }
    else {
      $currencies = entity_load_multiple('mcapi_currency');
    }
  }
  foreach ($currencies as $currcode => $currency) {
    $list[$currcode] = $currency->label();
  }

  if ($check_access) {
    $list = array_intersect_key($list, mcapi_get_available_currencies($account));
  }
  return $list;
}
/**
 * Load currencies for a given user
 *
 * @param AccountInterface $account
 * @return array
 *   of currencies
 */
function mcapi_get_available_currencies(AccountInterface $account = NULL) {
  if (!isset($account)) {
    $account = \Drupal::currentUser();
  }
  $cid = 'currencies:' . $account->id();
  if (!$cache = \Drupal::cache()->get($cid.'k')) {
    $available = array();
    $cache_tags = array('mcapi.available_currency' => array());
    $currencies = entity_load_multiple('mcapi_currency');
    $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
    uasort($currencies, array($info['class'], 'sort'));
    foreach ($currencies as $currency) {
      if ($currency->status && $currency->access('membership', $account)) {
        $available[$currency->id()] = $currency;
        $cache_tags['mcapi.available_currency'] = $currency->id();
      }
    }
    //TODO this cache should be cleared whenever a currency is edited and whenever a user's entitlement to use a currency could be affected
    \Drupal::cache()->set($cid, $available, CacheBackendInterface::CACHE_PERMANENT, $cache_tags);
    return $available;
  }
  else {
    return $cache->data;
  }
}
/**
 * implements hook_mcapi_transaction_operated().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param object $plugin
 * @param TransactionInterface $transaction
 * @param array $context
 *   consists of id, the operation plugin id; config, the operation plugin configuration; old_state: the state of the transaction before the operation
 */
function mcapi_mcapi_transaction_operated($plugin, $transaction, $context) {
  //TODO invoke rules hook
  //make a note that the proper way to trigger mails is via each operations' settings
}

/**
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  return array(
    // this is used by the field API for mixed transaction forms
    'worths' => array(
      '#title' => t('Worth'),
      '#input' => TRUE,
      '#title_display' => 'before',
      '#element_validate' => array('mcapi_worths_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#process' => array('mcapi_worths_element_process'),
      '#tree' => TRUE,
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worths-element.css',
        )
      ),
      // custom properties, used for configuration
      '#currcodes' => array_keys(mcapi_get_available_currencies()),
      '#mixed_mode' => \Drupal::config('mcapi.misc')->get('mix_mode'),
      '#preset' => FALSE, //ensures all currencies are showing
      '#calc' => FALSE, //allow a formula
    ),
    // this one is used internally only,
    // although you could probably use it to build a form if you wanted to ignore all multicurrency functionality
    'worth' => array(
      '#input' => TRUE,
      '#title_display' => 'attribute',
      '#process' => array('mcapi_worth_element_process'),
      '#value_callback' => 'mcapi_form_type_worth_value',
      '#element_validate' => array('mcapi_worth_element_validate'),
      '#theme_wrappers' => array('form_element'),
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'mcapi') . '/css/worth-element.css',
        )
      ),
      // custom properties, used for configuration
      '#currcodes' => array_keys(mcapi_get_available_currencies()),
      '#calc' => FALSE,
    ),
    'mcapi_states' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_states', 'ajax_process_form'),
      '#theme_wrappers' => array('radios'),
      '#pre_render' => array('form_pre_render_conditional_form_element'),
    ),
    'mcapi_types' => array(
      '#input' => TRUE,
      '#title_display' => 'before',
      '#process' => array('mcapi_process_types', 'ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#theme' => 'select'
    ),
    'mcapi_currcodes' => array(
      '#input' => TRUE,
      '#title_display' => 'invisible',
      '#process' => array('mcapi_process_currcodes','ajax_process_form'),
      '#theme_wrappers' => array('form_element'),
      '#multiple' => TRUE,
      '#options' => array(),//array of currcodes and currency names
    ),
    'mcapi_summary' => array(
      '#pre_render' => array('mcapi_pre_render_summary'),
      //other themes are possible, like and balance_bars and google-ometer
      '#theme' => 'mcapi_summary',
      '#currcode' => 'credunit',
      '#account' => NULL,//needed
      '#filters' => array()
    )
  );
}

/**
 * process callback for worths form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worths_element_process($element, &$form_state) {
  $currencies = mcapi_get_available_currencies();

  //the default value also tells us which currencies are available
  //if no defaults are set then all currencies should be present
  if (!isset($element['#default_value']) || empty($element['#default_value']) || $element['#preset']) {
    $element['#default_value'] = isset($element['#default_value']) ? (array)$element['#default_value'] : array();
  }
  if ($element['#mixed_mode'] || $element['#preset']) {
    //construct one widget for each default, each with its own currcode
    foreach ($currencies as $currcode => $name) {
      $element[$currcode]['#title'] = $name;
      $element[$currcode]['#currcodes']= array($currcode);
      //some dispute about whether default_value should be a worths object or an array
      if (!is_object($element['#default_value'])){
        $element['#default_value'] = (object)$element['#default_value'];
      }
      $element[$currcode]['#default_value'] = $element['#default_value']->{$currcode};
    }
  }
  else {
    $keys = array_keys($currencies);
    $key = reset($keys);
    $element[$key] = array(
      '#title' => t('Worth'),
      '#currcodes' => $element['#currcodes'],
      '#default_value' => $element['#default_value']->$key,
    );
    if (array_key_exists('#max', $element) && $element['#max']) {
      $element['#description'] = $element['#description'] . t('Max: !num', array('!num' => $element['#max']));
    }
  }

  //now populate all the subwidgets with defaults
  foreach (element_children($element) as $delta) {
    $element[$delta]['#type'] = 'worth';
    $element[$delta]['#calc'] = $element['#calc'];
    $element[$delta]['#preset'] = $element['#preset'];
  }
  return $element;
}

/**
 * element_validate callback for worths field
 * @param array $element
 * @param array $form_state
 */
function mcapi_worths_element_validate($element, &$form_state) {
  if ($element['#required']) {
    $value_entered = FALSE;

    $currencies = $element['#currcodes'];
    if (!isset($element['#mixed_mode']) || !$element['#mixed_mode']) {
      $currencies = array(reset($currencies));
    }

    foreach ($currencies as $currcode) {
      $curr_element = $element[$currcode];
      $newcode = $curr_element['currcode']['#default_value'];
if (!$newcode) drupal_set_message('problem validating worths element', 'error');
      $currency = entity_load('mcapi_currency', $newcode);
      if ($curr_element[$currency->widget]['#value'] || $curr_element[$currency->widget]['#value'] === 0) {
        $value_entered = TRUE;
        break;
      }
    }

    if (!$value_entered) {
      $elements['#required_but_empty'] = TRUE;
      if (isset($elements['#required_error'])) {
        \Drupal::formBuilder()->setError($element, $elements['#required_error']);
      }
      // A #title is not mandatory for form elements, but without it we cannot
      // set a form error message. So when a visible title is undesirable,
      // form constructors are encouraged to set #title anyway, and then set
      // #title_display to 'invisible'. This improves accessibility.
      elseif (isset($elements['#title'])) {
        \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
      }
      else {
        \Drupal::formBuilder()->setError($element);
      }
    }
  }
}

/**
 * process callback for worth form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_worth_element_process($element, &$form_state, $form) {
  $typedDataManager = \Drupal::typedData();
  if (!is_object($element['#default_value'])) {
    $element['#default_value'] = $typedDataManager->create(array('type' => 'field_item:worth', 'list' => TRUE), $element['#default_value']);
  }
  $element['#title_display'] = 'attribute';
  //the element is aware of a set of currcodes
  if (empty($element['#currcodes'])) {
    //best not rely on this, supply your own currencies that the user is permitted to use.
    //this defaults to all
    $element['#currcodes'] = array_keys(mcapi_get_available_currencies());
  }
  $element['currcode'] = array(
    '#title' => t('Currency'),
    '#type' => 'mcapi_currcodes',
    '#currcodes' => $element['#currcodes'],
    '#default_value' => array($element['#default_value']->currcode),
  );

  $element['currcode'] = mcapi_process_currcodes($element['currcode']);

  $parents =  $element['#parents'];
  $parents[] = 'currcode';

  $name = array_shift($parents);
  if (count($parents)) {
    $name .= '[' . implode('][', $parents) . ']';
  }

  $element['value'] = array(
    '#type' => 'value',
    '#default_value' => $element['#default_value']->value,
  );

  $currencies = entity_load_multiple('mcapi_currency', $element['#currcodes']);
  $info = \Drupal::entityManager()->getDefinition('mcapi_currency');
  uasort($currencies, array($info['class'], 'sort'));

  foreach ($currencies as $currency) {
    $plugin = $currency->getWidgetPlugin();

    if (empty($element[$currency->widget])) {
      $element[$currency->widget] = array(
        '#title_display' => 'invisible',
      );
      if (count($element['#currcodes']) == 1) {
        $element[$currency->widget] += array(
          '#field_prefix' => $currency->prefix,
          '#field_suffix' => $currency->suffix,
        );
      }
      else {
        // Set up the dependent fields when the currency select box is changed.
        $element[$currency->widget]['#states'] = array(
          'visible' => array(
            ':input[name="' . $name . '"]' => array(
              array('value' => $currency->id()),
            ),
          ),
        );
      }

      $element[$currency->widget] = $plugin->formElement(array(0 => $element['#default_value']), 0, $element[$currency->widget], $form, $form_state);
    }
    else {
      // add the new additional currency.
      $element[$currency->widget]['#states']['visible'][':input[name="' . $name . '"]'][] = array('value' => $currency->id());
    }
  }
  return $element;
}

/**
 * element_validate callback for worth field
 * @param array $element
 * @param array $form_state
 */
function mcapi_worth_element_validate($element, &$form_state) {
//I don't like this...
  $currcode = empty($element['#value']['currcode']) ? $element['currcode']['#value'] : $element['#value']['currcode'];
if (!$currcode)drupal_set_message('problem validating worth element', 'error');

  if (!$currency = entity_load('mcapi_currency', $currcode)) {
    \Drupal::formBuilder()->setError($element, $form_state, t('%currcode is not a valid currency', array('%currcode' => $currcode)));
    return;
  }
  $plugin = $currency->getWidgetPlugin();

  $value = $element['#value'][$currency->widget];
  if (method_exists($plugin, 'asInteger')) {
    $value = $plugin->asInteger($value);
  }

  if ($element['#required'] && !$value && $value !== 0) {
    $elements['#required_but_empty'] = TRUE;
    if (isset($elements['#required_error'])) {
      \Drupal::formBuilder()->setError($element, $elements['#required_error']);
    }
    // A #title is not mandatory for form elements, but without it we cannot
    // set a form error message. So when a visible title is undesirable,
    // form constructors are encouraged to set #title anyway, and then set
    // #title_display to 'invisible'. This improves accessibility.
    elseif (isset($elements['#title'])) {
      \Drupal::formBuilder()->setError($element, t('!name field is required.', array('!name' => $elements['#title'])));
    }
    else {
      \Drupal::formBuilder()->setError($element);
    }
  }
  else {
    $values = array(
      'currcode' => $currcode,
      'value' => $value,
    );
    \Drupal::formBuilder()->setValue($element, $values, $form_state);
  }
}

/**
 * process callback for mcapi_state form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_get_states(TRUE);
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_get_types(TRUE);
  return $element;
}

/**
 * process callback for mcapi_currcodes form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  if (empty($element['#options']) && !empty($element['#currcodes'])) {
    $element['#options'] = array_intersect_key(mcapi_currency_list(NULL, NULL), drupal_map_assoc($element['#currcodes']));
  }
  else if (empty($element['#options'])) {
//TODO    Warning: array_intersect_key(): Argument #2 is not an array on admin/structure/block/add/mcapi_limits
    //limit the choice to the currencies available to this user
    $element['#options'] = array_intersect_key(mcapi_currency_list(NULL, NULL, TRUE), drupal_map_assoc($element['#currcodes']));
  }
  else if ($element['#options'] == 'all') {
    $element['#options'] = mcapi_currency_list(NULL, NULL);
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}


/**
 * element pre_render callback
 * adds the user account transaction summary to the render array
 *
 * @param array $element
 *   a renderable array
 * @return
 *   a more populated renderable array, ready for theming
 */
function mcapi_pre_render_summary($element) {
  static $results = array();//TODO should this be drupal_static?
  $uid = $element['#account']->id();
  //occasionally we'll appreciate a static result
  $result = &$results[$uid][$element['#currency']->id()];
  if (empty($result)) {
    $stats = \Drupal::entityManager()
    ->getStorageController('mcapi_transaction')
    ->summaryData($element['#account'], $element['#currency'], $element['#filters']);
    foreach ($stats as $key => $val) {
      $result['#'.$key] = $val;
    }
  }
  return $element + $result;
}

/**
 * implements alter hook_form_user_cancel_confirm_form().
 * if they have already traded, users can only be blocked, not deleted
 * TODO test this
 *
 * @param array $form
 * @param array $form_state
 */
function mcapi_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  $traded = db_query(
    "SELECT xid FROM {mcapi_transactions} WHERE (payer = :uid OR payee = :uid) AND state > 0",
    array(':uid' => $form['uid']['#value'])
  )->fetchfield();
  if ($traded) {
    unset($form['user_cancel_method']['user_cancel_reassign']);
    unset($form['user_cancel_method']['user_cancel_delete']);
  }
}

/*
 * implements hook_toolbar
 * adds the 'balances' icon
 */
function mcapi_toolbar() {
  if (\Drupal::currentUser()->hasPermission('manage all transactions')) {
    drupal_add_css(drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css');
  }
}


/*
 * what file should this be in? mcapi.views.inc doesn't seem to be included
 *
 * this modifies the query only to show the transactions visible to the user
 * according to currency view access settings per transaction state
 *
 * It seems that all the D7 views query building functions are still in use,
 * duplicating functions now in drupal core. Maybe this will improve before release
 *
 * For now though its not clear whether it is best to use hook_views_pre_execute
 * or hook_query_alter or hook_query_TAG_alter to catch all the queries on either transaction table.
 */
function ________mcapi_views_pre_execute(ViewExecutable $view) {
  if (!array_intersect(
    array('mcapi_transactions', 'mcapi_transactions_index'),
    array_keys($view->query->tables)
  )) return;
  //https://api.drupal.org/api/drupal/core!modules!views!lib!Drupal!views!Plugin!views!query!Sql.php/function/Sql%3A%3AaddTable/8
  //$view->query->addTable('mcapi_transactions_worths', 'mcapi_transactions_worths.xid = mcapi_transactions.xid');

  $currencies = mcapi_get_available_currencies();
  $states = array_keys(mcapi_get_states(TRUE));
  $transactionAccessPlugins = transaction_access_plugins();
  //get all the currencies a user can access INTERSECTED with all the currencies in this view
  //then we iterate through the currencies, saying for each state whether it is visible.
  //first check the argument and the filters, otherwise get a full list of currencies.
  $or_currcodes = db_or();//where ((currcode = A and (blah)) OR ((currcode = B and (blah))
  foreach ($currencies as $currcode => $currency) {
    $currency = mcapi_currency_load($currcode);
    //where (currcode = A and (state = x) OR (state = Y) )
    $state_or_state = db_or();//where state = A OR B
    foreach ($states as $state) {
      $plugin_names = (array)$currency->access_view[$state];
      foreach ($plugin_names as $plugin_name) {
        $plugin = $transactionAccessPlugins[$plugin_name];
        $state_and_callback = db_and()->condition('mcapi_transactions.state', $state);
        $plugin->ViewsAccess($view->query, $state_and_callback, $state);
        $state_or_state->condition($state_and_callback);
      }
    }
    if ($plugin_names) {
      $or_currcodes->condition(db_and()
        ->condition('mcapi_transactions_worths.currcode', $currcode)
        ->condition($state_or_state)
      );
    }
  }
  //to see this working, enable the sql preview in the views interface.
  $view->query->addWhere('', $or_currcodes);
}

function mcapi_entity_query_alter() {
  drupal_set_message('hook_entity_query_alter');
}

/*
 * implements hook_config_translation_info().
 * Introduce dynamic translation tabs for translation of configuration.
 * //TODO
 */
function mcapi_config_translation_info() {
  //dunno what to return here
  return array();
}
/*
 * implements hook_config_translation_type_info_alter().
 * //TODO
 */
function mcapi_config_translation_type_info_alter($info) {
  print_r($info);
}

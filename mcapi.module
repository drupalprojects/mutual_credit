<?php  // $Id: mcapi.module,v 1.1.2.6 2010/12/22 19:30:29 matslats Exp $: transactions.module,v 1.1.2.4 2009/10/14 10:03:54 matslats Exp $


$controller_mod = variable_get('mcapi_controller', 'mcapi');
include(drupal_get_path('module', $controller_mod) .'/'. $controller_mod.'.controller');

define('MCPI_CURRENCY_UNDO_DELETE', 0);
define('MCPI_CURRENCY_UNDO_ERASE', 1);
define('MCPI_CURRENCY_UNDO_REVERSE', 2);

define ('CURRENCY_DIVISION_MODE_NONE', 0);
define ('CURRENCY_DIVISION_MODE_CENTS_INLINE', 1);
define ('CURRENCY_DIVISION_MODE_CENTS_FIELD', 2);
define ('CURRENCY_DIVISION_MODE_CUSTOM', 3);

//states are mutually exclusive
//the convention is that states > 0 are counted (but sometimes you might want to count pending (-1) as well)
define('TRANSACTION_STATE_FINISHED', 1);
//There's a convention that says transactions are 'counted' towards the balance when their state is > 0
//when the delete mode is to write another transaction reversing the first,
//we don't actually want to discount the deleted transaction
//so its state constant will be > 0
//depending on the delete mode, erased transactions may or may not be counted
define('TRANSACTION_STATE_ERASED', 0);
//A reversed transaction cluster contains at least one pair of mirrored transactions.
//Reversed transactions are counted and visible
define('TRANSACTION_STATE_REVERSED', 2);

//the transaction form expects args in $form_state[build_info]
//This constant and another in the forms module ensures the argument position is not determined by chance
define('TRANSACTION_BUILD_INFO_ARG', 0);


/*
 * Entity load callback
 * Community Accounting API function, see transaction.api.php
 */
function transactions_load($xids = array(), $conditions = array(), $reset = FALSE) {
  $transactions = entity_get_controller('transaction')->load($xids, $conditions, $reset);
  module_invoke_all('entity_load', $transactions, 'transaction');

  return $transactions;
}

/*
 * Community Accounting API function, see transaction.api.php
 * return the serial number if $really is TRUE
 */
function transactions_insert(array &$cluster, $really = TRUE) {
  //put all the transactions side by side ready for the entity controller to validate and insert
  //instead of module_invoke_all, this allows us to pass by reference
  foreach (module_implements('accounting_validate') as $module) {
    $function = $module . '_accounting_validate';
    $function($cluster);
  }
  $serial = entity_get_controller('transaction')->insert($cluster, $really);
  if ($serial) {//this is only if the transaction was actually inserted
    foreach ($cluster as $transaction) {
      field_attach_insert('transaction', $transaction);
    }
    //all the transactions have the same serial, and the same state,
    //so we just get the last serial num of the last transaction used
    //tell the system that the new transaction is going from NULL to whatever the form specified
    transactions_state(array($transaction->serial), $transaction->state);
    return $serial;
  }
  else return $cluster;
}

/*
 * Community Accounting API function, see transaction.api.php
 * Undo according to the appropriate delete mode.
 */
function transactions_undo(array $serials) {
  $deletemode = variable_get('mcapi_controller_delete_mode', MCPI_CURRENCY_UNDO_REVERSE);
  if ($deletemode == MCPI_CURRENCY_UNDO_ERASE) {
    transactions_state($serials, TRANSACTION_STATE_ERASED);
  }
  else {
    if ($deletemode == MCPI_CURRENCY_UNDO_DELETE) {
      foreach ($serials as $serial) {
        $transaction = transaction_load($serial);
        //depending on the undo mode, we might want to do the whole entity_delete thing.
        field_attach_delete('transaction', $transaction);
        module_invoke_all('entity_delete', $transaction, 'transaction');
      }
      entity_get_controller('transaction')->undo($serials, TRUE);
      //no state change here
    }
    elseif ($deletemode == MCPI_CURRENCY_UNDO_REVERSE) {
      entity_get_controller('transaction')->undo($serials);
      transactions_state($serials, TRANSACTION_STATE_REVERSED);
    }
  }

  module_invoke_all('transactions_undone', $serials);
  if (module_exists('rules')) {
    rules_invoke_event('transactions_undone', array($serials));
  }
}

/**
 * Community Accounting API function, see transaction.api.php
 * change or set the state of a transaction, and pull triggers
 */
function transactions_state(array $serials, $new_state) {
  foreach ($serials as $serial) {
    //we can't assume all of these are in the same state, so they might be following different workflow paths, so we have to deal with them individually
    $old_clusters[$serial] = transaction_load($serial);
  }
  entity_get_controller('transaction')->state($serials, $new_state);
  //for the following hooks, we send the old transactions in full, and the new state
  module_invoke_all('transactions_state', $old_clusters, $new_state);
}

/**
 * Community Accounting API function, see transaction.api.php
 */
function transaction_totals($uid, $currcode = NULL, $conditions = array()) {
  if (!$currcode) {
    $currencies = &drupal_static('currencies');
    $currcode = key($currencies);
  }
  if (empty($conditions)) {
    $conditions = array(array('state', 0, '>'));
  }
  //convert it to an object for cleaner syntax in php5
  $totals = (object)entity_get_controller('transaction')->sums($uid, $currcode, $conditions);
  //just out of interest (needed for intertrading) we'll store the smallest balances
  if (module_exists('intertrading_client') && $currcode == variable_get('intertrading_currcode', '')){
    _save_smallest($totals->balance, $uid);
  }
  return $totals;
}

/*
 * Community Accounting API wrapper function, see transaction.api.php
 * this is used to as a menu loader, so can't be in an inc file
 */
function transaction_load($serial) {
  static $serials = array();
  //if no serial specified replace with the last transaction that this user created.
  if ($serial == 0) {
    static $last;
    if (!$last) {
      //this is not scalable
      $last = end(transactions_load(array(), array('creator' => $GLOBALS['user']->uid)))->serial;
    }
    $serial = $last;
  }
  //the menu system alone may call this function several times in one page request
  if (empty($serials[$serial])) {
    //if this isn't done globally, entity_crud_get_info in the contributed 'entity' module, tries to load the controller without loading the file
    $transactions = transactions_load(array(), array('serial' => $serial));
    if (empty($transactions)) {
      throw new Exception(t('Unable to load transaction @serial', array('@serial' => $serial)));
    }
    //take the first one off and make the rest its dependents, preserving their keys
    $transactions = array_reverse($transactions, TRUE);
    $transaction = array_pop($transactions);
    $transaction->dependents = $transactions;
    $serials[$serial] = $transaction;
  }
  return $serials[$serial];
}

/*
 * Community Accounting API wrapper function, see transaction.api.php
 * arguments:
 *   $transaction - an object, probably originally created by entity_metadata_create_transaction
 *   $really - Boolean whether to actually save this, or just test-write and revoke.
 *     Defaults to TRUE top be compatible with the Entity API 'save callback'
 */
function transaction_insert_new($transaction, $really = TRUE) {
  $transactions = array($transaction);
  //this is where the transaction is likely to acquire dependents,
  //and serial numbers set by contrib modules
  drupal_alter('transaction_cluster', $transactions);
  return transactions_insert($transactions, $really);
}
/*
 * Community Accounting API wrapper function, see transaction.api.php
 * For development ONLY
 */
function transactions_delete($serials) {
  drupal_set_message('Using undocumented API call to delete transactions');
  transactions_undo($serials, MCPI_CURRENCY_UNDO_DELETE);
}


/*
 * entity API callback, but used all over the place
 * takes some params and fills in some defaults to make a usable transaction object,
 * PRIOR to writing in the database
 * that means it does nothing with the xid and the serial number
 *   'values' can contain any of
 *   'payer' - user ID
 *   'payee' - user ID
 *   'creator' - User ID
 *   'created' - unixtime
 *   'type' - string defined in hook_mcapi_info_types
 *   'extra' -
 *   'state' - constant defined in hook_mcapi_info_states
 *   'worth' - fieldAPI array begining with LANGUAGE_NONE
 *     OR
 *   'quantity' (AND currcode) numeric value (AND currency identifier)
 *   'description' OR $description_field_name string describing purpose of transaction
 * N.B. This function knows nothing about the transaction fieldAPI fields,
 * it just passes on the values it is passed
 */
function entity_metadata_create_transaction($values = array(), $for_me = FALSE) {
  $defaults = array(
    'payer' => 0,
    'payee' => 0,
    'creator' => $GLOBALS['user']->uid,
    'created' => REQUEST_TIME,
    'type' => 'default',
    'extra' => array(),
    'state' => TRANSACTION_STATE_FINISHED
  );
  foreach ($defaults as $key => $val) {
    $transaction->$key = isset($values[$key]) ? $values[$key] : $val;
  }

  if ($for_me) $currencies =  currencies_load($GLOBALS['user']);
  else $currencies = drupal_static('currencies');
  //this callback doesn't normally deal with fieldAPI fields, but worth is special and description is special
  if (isset($values['worth'])) {//
    if (isset($values['worth'][LANGUAGE_NONE])) $values['worth'] = $values['worth'][LANGUAGE_NONE];
    $transaction->worth = array(LANGUAGE_NONE => $values['worth']);
  }
  elseif(isset($values['quantity'])) {
    $transaction->worth[LANGUAGE_NONE][0]['quantity'] = $values['quantity'];
    $transaction->worth[LANGUAGE_NONE][0]['currcode'] = $values['currcode'] ? $values['currcode'] : key($currencies);
  }
  else {
    $currcodes = array_keys($currencies);
    foreach ($currcodes as $currcode) {
      $transaction->worth[LANGUAGE_NONE][] = array(
        'quantity' => '',//blank means this value has never been saved
        'currcode' => $currcode
      );
    }
  }
  //allow the description to come in with various names
  if ($desc_fieldname = variable_get('transaction_description_field')) {
    //assumes that the description field is not called 'description'
    if (isset($values['description'])) {
      $transaction->{$desc_fieldname} = array(LANGUAGE_NONE => array(0 => array('value' => $values['description'])));
    }
    elseif (isset($values[$desc_fieldname])) {
      if (isset($values[$desc_fieldname][LANGUAGE_NONE])) $values[$desc_fieldname] = $values[$desc_fieldname][LANGUAGE_NONE];
      $transaction->{$desc_fieldname} = array(
        LANGUAGE_NONE => $values[$desc_fieldname]
      );
    }
  }
  $transaction->dependents = array();
  return $transaction;
}

/*
 * DRUPAL & CONTRIB HOOK IMPLEMENTATIONS
 */

/**
 * implements hook_help()
 * provides on-page advice and some configuration
 */
function mcapi_help($section, $arg) {
  switch ($section) {
    case 'admin/accounting':
      return implode(' ', array(
        t("The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital."),
        t("This software has been five years in the conceiving and making and has been supported only by informal donations.")
      ));
    case 'admin/accounting/fields':
      module_load_include('inc', 'mcapi');
      return drupal_render(drupal_get_form('mcapi_description_field'));
    case 'admin/accounting/currencies':
      $currencies = &drupal_static('currencies');
      if (count($currencies) > 1) {
        module_load_include('inc', 'mcapi');
        return drupal_render(drupal_get_form('mcapi_mixed_transactions'));
      }
    case 'admin/accounting/misc':
      return implode(' ', array(
        t("Send mail notifications for completed transactions using the action/trigger system: !link", array('!link' => l('admin/config/system/actions', 'admin/config/system/actions')))
      ));
  }
}


/**
 * implements hook_menu()
 */
function mcapi_menu() {
  module_load_include('inc', 'mcapi');
  //take this opportunity of an occaisional hook to check that the description field is set
  if (!variable_get('transaction_description_field', '')) {
    if (count(_mcapi_get_text_instances())) {
      drupal_set_message(t('Is the textfield on your transaction used for the description? !link', array('!link' => l('admin/accounting/fields', 'admin/accounting/fields'))));
    }
  }
  return mcapi_menu_inc();
}

/**
 * implements hook_permission
 * This hook can supply permissions that the module defines.
 * doing it with another hook allows us to collect all the mutual credit permissions in one section of the permissions page
 */
function mcapi_permission() {
  return module_invoke_all('mcapi_info_drupal_permissions');
}


/**
 * implements hook_theme
 */
function mcapi_theme($existing, $type, $theme, $path) {
  $items = array(
    'certificate' => array(
      'template' => 'certificate',
      'pattern' => 'certificate__',
      'variables' => array(
        'transaction' => NULL,
      )
    ),
    'worth_element'=> array(
      'render element' => 'element',
      'file' => 'mcapi.inc'
    ),
    'worths_element'=> array(
      'render element' => 'element',
      'file' => 'mcapi.inc'
    ),
    'worth_item'=> array(
      'variables' => array(
        'currcode' => NULL,
        'quantity' => '',
      ),
      'file' => 'mcapi.inc'
    ),
    'transaction_totals' => array(
      'variables' => array(
        'totals' => array()
      ),
      'file' => 'mcapi.inc'
    ),
  );
  return $items;
}

/**
 * Implements hook_search_info().
 */
function mcapi_search_info() {
  if (!variable_get('transaction_description_field', '')) return array();
  return array(
    'title' => 'Transactions',
    'path' => 'transaction',
  );
}

/**
 * Implements hook_search_access().
 * the reality is more complex since the transactions are visible according to currency settings
 */
function mcapi_search_access() {
  if (!variable_get('transaction_description_field', '')) return;
  return user_access('transact');
}

/**
 * Implements hook_search_reset().
 */
function mcapi_search_reset() {
  if (!variable_get('transaction_description_field', '')) return;
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'transaction')
    ->execute();
}

/**
 * Implements hook_search_status().
 * based on node_search_status()
 */
function mcapi_search_status() {
  if (!variable_get('transaction_description_field', '')) return;
  return array(
    'remaining' => db_query("SELECT COUNT(*) FROM {mcapi_transactions} x LEFT JOIN {search_dataset} d ON d.type = 'transaction' AND d.sid = x.xid WHERE d.sid IS NULL OR d.reindex <> 0")->fetchField(),
    'total' => db_query('SELECT COUNT(*) FROM {mcapi_transactions}')->fetchField()
  );
}

/**
 * Implements hook_search_execute().
 * based on node_search_execute()
 */
function mcapi_search_execute($keys = NULL, $conditions = NULL) {
  if (!variable_get('transaction_description_field', '')) return array();
  // Build matching conditions
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery')->extend('PagerDefault');
  $query->join('mcapi_transactions', 'x', 'x.serial = i.sid');
  $query
    ->addTag('transaction_access')
    ->searchExpression($keys, 'mcapi');

  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();
  $results = array();
  foreach ($find as $item) {
    // Render the node.
    $transaction = transaction_load($item->sid);//sid is actually the serial number
    if (!transaction_view_access($transaction)) continue;

    $uri = entity_uri('transaction', $transaction);
    $results[$item->sid] = array(
      'link' => url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE))),
      'title' => transaction_label($transaction),
      'transaction' => $transaction,
    );
  }
  krsort($results);
  return $results;
}


/**
 * Implements hook_update_index().
 */
function mcapi_update_index() {
  module_load_include('inc', 'mcapi');
  $xs = db_query("SELECT x.serial, x.xid
    FROM {mcapi_transactions} x
    LEFT JOIN {search_dataset} d ON d.type = 'transaction' AND d.sid = x.serial
    WHERE d.sid IS NULL OR d.reindex <> 0")->fetchAll();
  foreach($xs as $trans) {
    //is this achievable using GROUP BY?
    $xids[$trans->serial][] = $trans->xid;
  }
  foreach ($xids as $serial => $xids) {
    $text = array();
    foreach(_mcapi_get_text_instances() as $fieldname) {
      $info = field_info_field($fieldname);
      $table = 'field_data_'.$fieldname;
      $column = $fieldname.'_value';
      $text[] = db_query("SELECT $column FROM {$table} WHERE entity_id IN (".implode(',', $xids).") AND entity_type = 'transaction'")->fetchField();
    }
    search_index($serial, 'mcapi', implode(' ', $text));
  }
  // Save the changed time of the most recent indexed transaction, for the search results half-life calculation.
  // actually not doing this coz only updating new transactions since last cron.
  //variable_set('mcapi_cron_last', transaction_load($serial)->created);
}


/*
 * implements hook_block_info
 */
function mcapi_block_info() {
  $blocks['balances'] = array(
    'info' => 'MC '. t("Balances"),
  );
  return $blocks;
}
/*
 * implements hook_block_view
 */
function mcapi_block_view($delta) {
  module_load_include('inc', 'mcapi');
  if ($settings = _mcapi_block_settings($delta, 'user_aggregated_view')) {
    if (empty($settings['account']) || empty($settings['account']->uid)) return;
    return array(
      'subject' => $settings['account']->uid == $GLOBALS['user']->uid ?
        t('Trading status') :
        t("@user's account", array('@user' => strip_tags(format_username($settings['account'])))),
      'content' => mcapi_balances_view($settings['account']->uid, $settings['currcodes']),
      '#settings' => $settings,//this is read by mcapi_signatures_block_view_alter
    );
  }
}

/*
 * implements hook_block_configure
 */
function mcapi_block_configure($delta) {
  $currencies = &drupal_static('currencies');
  module_load_include('inc', 'mcapi');
  $settings = variable_get('block_'. $delta, array('currcodes' => array(), 'user_source' => 0));
  $form['currcodes'] = currency_picker_element(array_keys($currencies), @$settings['currcodes'], TRUE);
  $form['user_source'] = array(
    '#title' => t('User'),
    '#type' => 'radios',
    '#options' => array(
      0 => t('Show as part of profile being viewed'),
      1 => t('Show for logged in user')
    ),
    '#default_value' => intval(@$settings['user_source'])
  );
  return $form;
}

/*
 * implements hook_block_save
 * used by dependent modules - save these two values
 */
function mcapi_block_save($delta, $values) {
  variable_set('block_'. $delta,
    array(
      'currcodes' => (array)$values['currcodes'],
      'user_source' => $values['user_source']
    )
  );
}


/*
 * implements hook_init
 * make the drupal_static variable 'currencies' available
 */
function mcapi_init() {
  currencies_load();
  drupal_add_css(drupal_get_path('module', 'mcapi') .'/mcapi.css');
}

/**
 * Implements hook_entity_info()
 */
function mcapi_entity_info(){
  module_load_include('inc', 'mcapi');
  return mcapi_entity_info_inc();
}


/*
 * implements hook_uid_renum from uid_login module
 */
function mcapi_uid_renum($old, $new) {
  foreach(array('payer', 'payee') as $participant) {
    db_update('mcapi_transactions')->fields(array($participant => $new))->condition($participant, $old)->execute();
  }
}


/*
 * Implements ctools hook_ctools_plugin_api
 */
function mcapi_ctools_plugin_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi'),
  );
}
/*
 * Implements ctools hook_ctools_plugin_directory
 */
function mcapi_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/export_ui';//directory
  }
}
/*
 * Implements views hook_views_api
 */
function mcapi_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'mcapi') . '/views',
  );
}

/*
 * implements hook_hook_info
 * Mcapi hook implementations follow
 */
function mcapi_hook_info() {
  return array(
    //declare new transaction controllers
    'transaction_controller' => array(),
    //check the transactions and the system integrity after the transactions would go through
    'accounting_validate' => array(),
    //respond to the insertion of a transaction cluster
    'transactions_insert' => array(),
    //respond to the removal, or undoing of a transaction
    'transactions_undone' => array(),
    //preparing a transaction for rendering
    'transactions_view' => array(),
    //callbacks for determining users whoaccess to the currency and aggregated stats. See mcapi_user_segments
    'user_segments' => array(),
    //declare permissions for transaction access control, per currency per operation. See mcapi_transaction_access_callbacks
    'transaction_access_callbacks' => array(),
    //change of transaction state - takes serials
    'transactions_state' => array(),
    //declare transaction states
    'mcapi_info_states' => array(),
    //declare transaction types
    'mcapi_info_types' => array(),
    //declare permissions to go into the community accounting section of the drupal permissions page
    'mcapi_info_drupal_permissions' => array(),
  );
  //also note there is hook_transaction_cluster_alter to build up a transaction cluster
}


/*
 * entity callback for editing transaction entity
 */
function transaction_form($form, &$form_state) {
  form_load_include($form_state, 'inc', 'mcapi');
  $form['#transaction'] = isset($form_state['values']) ? (object)$form_state['values'] : (
    empty($form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]) ? entity_metadata_create_transaction() : $form_state['build_info']['args'][TRANSACTION_BUILD_INFO_ARG]);
  _transaction_form($form, $form_state);
  field_attach_form('transaction', $form['#transaction'], $form, $form_state);
  //this determines whether the function calls transaction_insert_new(), which includes drupal_alter
  // or transactions_insert() which writes the cluster
  $form['#skip_alter'] = FALSE;
  $form['#validate'] = array('transaction_form_validate');
  $form['#submit'] = array('transaction_form_submit');
  return $form;
}


/*
 * implements mcapi hook_info_controller
 * the presence of this hook indicates there is a .controller file
 * with the name MODULE.controller
 */
function mcapi_transaction_controller(){}

/*
 * implements mcapi hook_info_states
 * DON"T call this hook directly as the keys will be lost. use mcapi_get_states()
 */
function mcapi_mcapi_info_states() {
  return array(
    TRANSACTION_STATE_FINISHED => array(
      'name' => t('Cleared'),
      'description' => t('the last state of the workflow'),
      'default_access_callbacks' => array('mcapi_access_authenticated')
    ),
    TRANSACTION_STATE_ERASED => array(
      'name' => t('Erased'),
      'description' => t("marked deleted - not to be confused with 'reversal' transactions"),
      'default_access_callbacks' => array()
    ),
    TRANSACTION_STATE_REVERSED => array(
      'name' => t('Reversed'),
      'description' => t("cancelled by another reversed transaction in the same cluster"),
      'default_access_callbacks' => array()
    )
  );
}

/**
 * Implements hook_field_display_ENTITY_TYPE_alter().
 */
function mcapi_field_display_transaction_alter(&$display, $context) {
  // Hide field labels in search index.
  if ($context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}


/*
 * implements mcapi hook_info_types
 */
function mcapi_mcapi_info_types() {
  $types = array('default', 'child');
  if (variable_get('mcapi_controller_delete_mode', MCPI_CURRENCY_UNDO_REVERSE) == MCPI_CURRENCY_UNDO_REVERSE) {
    $types[] = 'reversal';
  }
  return $types;
}

/*
 * gather up all the transaction states from the hooks and present them in a given format
 * #options is suitable for choosing in a form element
 * #description is suitable for a chunk of description text explaining what the states mean
 * #full is the full array returned from the callback, keyed by constant value
 */
function mcapi_get_states($return_mode = '#options') {
  $states = array();
  foreach(module_implements('mcapi_info_states') as $module) {
    $function = $module . '_mcapi_info_states';
    $states += $function('states');
  }
  if ($return_mode == '#full') return $states;
  elseif ($return_mode == '#description') {
    foreach ($states as $key => $state) {
      $desc[] = $state['name'] .' - '. $state['description'] .'.';
    }
    return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
  }
  else {//suitable for a dropdown
    foreach ($states as $key => $state) {
      $options[$key] = $state['name'];
    }
    return $options;
  }
  return $states;
}
//returns the available transaction types in an associative array
function mcapi_get_types() {
  foreach (module_invoke_all('mcapi_info_types') as $type) {
    $types[$type] = $type;
  }
  return $types;
}


/*
 * implements mcapi hook_mcapi_info_drupal_permissions
 * make permissions appear altogether on the permissions page
 */
function mcapi_mcapi_info_drupal_permissions() {
  return array(
    'transact' => array(
      'title' => t('Transact'),
      'description' => t("Register exchanges with other members, subject each currency's permissions"),
    ),
    'manage all transactions' => array(
      'title' => t('Manage all transactions'),
      'description' => t('Retrospectively manage transactions'),
    ),
    'configure all currencies' => array(
      'title' => t('Configure all currencies'),
      'description' => t('Edit the properties of any currency')
    ),
    'declare currency' => array(
      'title' => t('Declare currency'),
      'description' => t('Create a new currency'),
    )
  );
}

/*
 * implements hook mcapi_permissions
 * each callback refers to 2 functions - itself and CALLBACK_views
 * Declare the access callbacks for (transactions in) currencies
 * each callback takes the following args
 * $transaction, $account
 * Multiple callbacks can be selected and access will be granted if any returns TRUE
 */
function mcapi_transaction_access_callbacks() {
  return array(
    'transaction_access_authenticated' => t('Authenticated users'),
    'transaction_access_accountant' => t("Accountants"),
    'transaction_access_anyone' => t('Anyone, including anonymous users'),
    'transaction_access_payee' => t('The payee in the transaction'),
    'transaction_access_payer' => t('The payer in the transaction'),
  );
}

/*
 * Implements hook_mcapi_user_segments
 * Callbacks which return a list of users
 */
function mcapi_user_segments() {
  return array(
    'user_segments_all' => t('Anyone, including anonymous users'),
    'user_segments_transact' => t("According to permission '@perm'", array('@perm' => t('transact'))),
    'user_segments_manage_all_transactions' => t("According to permission '@perm'", array('@perm' => t('Manage all transactions')))
  );
}
/*
 * implements hook_mail_alter
 * add the cc
 */
function mcapi_mail_alter(&$message) {
  if (isset($message['params']['cc'])) {
    $message['headers']['Cc'] = $message['params']['cc'];
  }
}

/**
 * special access function for transactions - NOT hook implementation
 * Grant view access to a transaction based on its state and the specified callback for that currency
 */
function transaction_view_access(stdClass $transaction) {
  module_load_include('inc', 'mcapi');
  foreach ($transaction->worth[LANGUAGE_NONE] as $item) {
    $currency = currency_load($item['currcode']);
    if (isset($currency->transaction_access[$transaction->state])) {
    //see hook_transaction_access_callbacks for a list of these functions
      foreach (array_filter($currency->transaction_access[$transaction->state]) as $function) {
        if ($function($transaction)) return TRUE;
      }
    }
  }
  return FALSE;
}

function transaction_undo_access($transaction) {
  module_load_include('inc', 'mcapi');
  if ($transaction->state == TRANSACTION_STATE_ERASED) return FALSE;
  foreach ($transaction->worth[LANGUAGE_NONE] as $item) {
    if (!currency_access('undo', $item['currcode'], $GLOBALS['user']->uid)) return FALSE;
  }
  return TRUE;
}

/*
 * transaction entity definition 'uri callback'
 */
function transaction_uri($transaction) {
  return array(
    'path' => 'transaction/' . $transaction->serial,
  );
}
/*
 * transaction entity definition 'label callback'
 */
function transaction_label($transaction){
  return t('Transaction #@serial', array('@serial' => $transaction->serial));
}

/*
 * block function a nice display of user balances in a currency
 */
function mcapi_balances_view($uid, $currcodes) {
  $render_array = array('#theme' => 'transaction_totals');
  foreach ($currcodes as $currcode) {
    $render_array['#totals'][$currcode] = transaction_totals($uid, $currcode);
  }
  return $render_array;
}

/*
 * ctools plugin callback for editing a currency, determined by the ctools export_plugin
 * The form_id is actually ctools_export_ui_edit_item_form
 */
function mcapi_currency_form(&$form, &$form_state){
  form_load_include($form_state, 'inc', 'mcapi', 'currencies');
  $currency = isset($form_state['values']) ? (object)$form_state['values'] :
    ($form_state['item']->data ? $form_state['item']->data : default_cur());
  //copy some settings from the default currency
  if (isset($currency->human_name)) {
    drupal_set_title( !empty($currency->human_name) ? $title = t("Edit currency '@name'", array('@name' => $currency->human_name)) : t('Declare currency') );
  }
  if (isset($form_state['values']['uid'])) {
    $currency->uid = $form_state['values']['uid'];
  }
  _mcapi_currency_form($form, $form_state, $currency);
}


/**
 * menu callback (also declared as $entity_info['view callback'])
 * build a render array for any number of transactions
 * first arg can be one or an array of transactions, WITH CHILDREN LOADED as in transaction_load
 */
function transaction_view($transactions, $view_mode = 'certificate') {
  if (!is_array($transactions)) {//we have been passed a single transaction
    $transactions = array($transactions->xid => $transactions);
  }
  foreach ($transactions as $transaction) {
    if ($view_mode == 'token') {
      global $language;
      $options = array('language' => $language, 'sanitize' => FALSE);
      foreach ($transactions as $transaction) {
        $params = array('transaction' => $transaction);
        $sentence = token_replace(variable_get('mcapi_sentence'), $params, $options);
        $renderable[] = array(
          '#view_mode' => 'token',
          '#prefix' => '<div class = "sentence">',
          '#markup' => $sentence,
          '#suffix' => '</div>',
        );
      }
    }
    else {
      $renderable[] = array(
        '#view_mode' => 'certificate',
        '#theme' => 'certificate',
        '#transaction' => $transaction,
      );
    }
  }
  $type = 'transaction';
  drupal_alter(array('transaction_view', 'entity_view'), $renderable, $type);
  return $renderable;
}


/*
 * theme implementation of template_preprocess_HOOK
 * make the transaction variables into something which can be nicely themed
 * $variables['transaction'] may have ->dependents from transaction_load
 * or it may be a simulated transaction with no xid and serial or dependents
 */
function template_preprocess_certificate(&$variables) {
  $cluster = &$variables['transaction'];
  $variables['payer'] = format_username(user_load($cluster->payer));
  $variables['payee'] = format_username(user_load($cluster->payee));
  $variables['state'] = $cluster->state;
  $variables['recorded'] = format_date($cluster->created, 'medium');
  $variables['type'] = $cluster->type;
  $variables['date'] = format_date($cluster->created, 'long');

  $variables['classes_array'] = array('transaction', 'certificate', $cluster->type, 'state-'.$cluster->state);
  if (empty($cluster->xid)) $variables['classes_array'][] = 'preview';

  //fieldAPI expects several at a time, keyed by entity key
  //NB in preview mode the xid hasn't been determined but it doesn't seem to matter
  $clusters = array($cluster->xid => $cluster);
  //note that the $cluster is changed by reference
  field_attach_prepare_view('transaction', $clusters, 'certificate');
  entity_prepare_view('transaction', $clusters);
  //this returns a render array
  $variables['additional'] = field_attach_view('transaction', $cluster, 'certificate');
  //this populates top level of variables with the render array
  field_attach_preprocess('transaction', $cluster, $variables['additional'], $variables);

  //move worth field to the top of $variables where we would expect to find it
  $variables['worth'] = drupal_render($variables['additional']['worth']);
  unset($variables['additional']['worth']);
  //choose the transaction theme template based on the first currency of the transaction
  $first_item = reset($cluster->worth[LANGUAGE_NONE]);
  $variables['theme_hook_suggestion'] = 'transaction__' . $first_item['currcode'];
  if (isset($cluster->dependents)) {
    foreach ($cluster->dependents as $child) {
      $variables['dependents'][] = transaction_view(array($child), 'sentences');
    }
  }
}

/*
 * return one currency object
 */
function currency_load($currcode = NULL) {
  $currencies = &drupal_static('currencies');
  if (empty($currencies))currencies_load();//filters
  if ($currcode && isset($currencies[$currcode])) {
    return $currencies[$currcode];
  }
  watchdog('mcapi', "Nonexistent currency '@currcode' requested from: @list",
    array('@currcode' => $currcode, '@list' => print_r(array_keys($currencies), 1))
  );
  return current($currencies);
}
/*
 * Load all the currencies from cache filter
 * then optionally return them filtered for which ones an account has membership i.e. can use
 * wish I understood ctools better. not sure I need to cache here
 */
function currencies_load($account = NULL, $refresh = FALSE) {
  $currencies = &drupal_static('currencies');
  if ($refresh) $currencies = array();
  $filtered = array();
  if (empty($currencies)) {//first time this page request.
    if (!$refresh && $cache = cache_get('currencies')) {
      $currencies = $cache->data;
    }
    else {
      module_load_include('inc', 'mcapi', 'currencies');
      foreach (currencies_load_all() as $currcode => $currency) {
        $currencies[$currcode] = $currency->data;
      }
      cache_set('currencies', $currencies);
    }
  }
  if (!$account) return;//having set the $currencies static

  module_load_include('inc', 'mcapi');
  foreach ($currencies as $currcode => $currency) {
    if (currency_access('membership', $currcode, $account->uid)) {
      //we're actually stripping the ctools metadata wrapper of the currency away here for convenience everywhere else
      $filtered[$currcode] = $currency;
    }
  }
  return $filtered;
}


/*
 * ====================================================
 * Implements hook_action_info
 * provides some simple actions, without conditions
 */
function mcapi_action_info() {
  module_load_include('inc', 'mcapi');
  return array(
    'mcapi_supplementary_transaction_action' => array(
      'type' => 'transactions',
      'label' => t('Charge one of the participants'),
      'configurable' => TRUE,
      'triggers' => array('transaction_cluster_alter'),
    ),
    'mcapi_transaction_mail_action' => array(
      'type' => 'transactions',
      'label' => t('Completed transaction notification'),
      'description' => t('Mail sent to the participants when the transaction completes'),
      'configurable' => TRUE,
      'triggers' => array('transactions_state'),
    )
  );
}

/*
 * implements hook_trigger_info
 */
function mcapi_trigger_info() {
  return array(
    //all mcapi hooks take variable $transactions.
    'mcapi' => array(
      'transaction_cluster_alter' => array(
        'label' => t('Modify a transaction cluster before saving'),
      ),
      'transactions_undone' => array(
        'label' => t('A transaction cluster was undone'),
      ),
      'transactions_state' => array(
        'label' => t('A transaction cluster was inserted or changed state'),
      )
    )
  );
}

/*
 * implements hook_form_trigger_assign_form_alter
 * adds a helpful comment to the transactions trigger
 */
function mcapi_form_trigger_assign_form_alter(&$form, $form_state) {
  $clarification = t('Actions which create new transactions will not fire the trigger recursively');
  $form['transaction_cluster_alter']['#description'] = $clarification;
}

/*
 * implements trigger hook_transaction_cluster_alter
 * sends the volitional transaction to the action callbacks where it can be changed.
 * Action callbacks may return a new transaction to be added to the $transactions
 */
function mcapi_transaction_cluster_alter(&$cluster) {
  if (module_exists('trigger')) {
    foreach (trigger_get_assigned_actions('transaction_cluster_alter') as $aid => $info) {
      //each action might return ONE transaction object
      $result = actions_do($aid, reset($cluster), $info);
      if (!empty($result[$aid])) {
        $cluster[] = $result[$aid];
      }
    }
  }
  if (module_exists('rules')) {
    rules_invoke_event('transaction_cluster_alter', array($cluster));
  }
}
/*
 * implement mcapi hook_transactions_state
 * triggers actions (and rules) whenever the state changes
 */
function mcapi_transactions_state($old_clusters, $new_state) {
  if (module_exists('trigger')) {
    foreach (trigger_get_assigned_actions('transactions_state') as $aid => $info) {
      foreach ($old_clusters as $cluster) {
        actions_do($aid, $cluster, $info, $new_state);
      }
    }
  }
  if (module_exists('rules')) {
    //shouldn't this fire autromatically?
    rules_invoke_event('transactions_state', $old_clusters, $new_state);
  }
}


/*
 * Everything below here concerns the 'worth' fieldAPI field
 *
 * it was a tough decision to use the field API rather than code my own, but I decided that
 * if went the Drupalish way
 * - it would be easier to maintain and
 * - we could have much greater flexibility and
 * - the B2B use case would be better supported with mixed transactions
 * However some custom code was still needed, and I'm not entirely happy with it.
 * First of all the field stores a decimal, but the widget can show two fields for the one number
 * these widget fields are called the main_quant and the div_quant
 * Secondly, each cardinal value must represent a different currency.
 * If cardinality == 1, then the user chooses the currency for that value. However
 * If cardinality > 1 then the system presents one $item for each currency, with the currcode preset.
 * This got too complicated when I wanted to be able to preset the worth in the forms module.
 * And things are a bit rough round the edges there.
 * Also I wanted, with single cardinality and multiple currencies,
 * for the widget to AJAX respond to the currency selection by showing the right divisions field.
 * This was a mistake and isn't wholly corrected yet!
 */

/*
 * Imlements entity module hook_field_info
 */
function mcapi_field_info() {
  return array(
    'worth_field' => array(
      'label' => t('Worth'),
      'description' => t("One or more values, each denominated in a currency"),
      'default_widget' => 'worths_widget',
      'default_formatter' => 'worth_field',
      'translatable' => FALSE,
      //following properties are for the entity API module. see mcapi.info.inc
      'property_type' => 'worth',//this is probably out of date
      'property_callbacks' => array('entity_metadata_field_worth_property_callback'),
    )
  );
}

/*
 * implements hook_field_formatter_info
 */
function mcapi_field_formatter_info() {
  return array(
    'worth_field' => array(
      'label' => t('Worth'),
      'field types' => array('worth_field'),
    )
  );
}

/*
 * implements hook_field_formatter_view
 * prepare a render array containing all (worth) $items
 */
function mcapi_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items) {
  $element = array();
  foreach($items as $delta => $item) {
    //if (empty($item['currcode'])) continue;
    $element[$delta] = array(
      '#theme' => 'worth_item',
      '#currcode' => $item['currcode'],
      '#quantity' => $item['quantity'],
    );
  }
  return $element;
}

/*
 * implements hook_field_widget_info
 */
function mcapi_field_widget_info() {
  return array(
    'worths_widget' => array(
      'label' => t('Worth'),
      'field types' => array('worth_field'),
      'behaviors' => array('multiple values' => FIELD_BEHAVIOR_CUSTOM)
    )
  );
}
/*
 * implements hook_field_widget_form
 * This is called once for ALL $items because the widget 'behavior' determines it, like checkboxes
 * See entity_metadata_create_transaction() for default $items
 */
function mcapi_field_widget_form($form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  module_load_include('inc', 'mcapi');
  $element += get_worths_element($items);
  return $element;
}


/*
 * implements hook_field_validate
 * check if the current user has permission to use the currency in this flow.
 * if $entity is not set that means the field was used in configuration somewhere
 */
function mcapi_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $currencies = &drupal_static('currencies');
  foreach ($items as $delta => $item) {
    if ($entity_type == 'transaction' && $entity) {
      $currency = $currencies[$item['currcode']];
      //check that each user has permission to use the currency in each item
      foreach (array('payer', 'payee') as $uid) {
        if ($currency->currency_access['membership']($entity->$uid)) continue;
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'mcapi_currency_access_membership',
          'message' => t('User @name cannot use @currency', array('@name' => user_load($entity->$uid)->name, '@currency' => $currency->human_name))
        );
      }
    }
  }
  //this must be the final check in this function
  //checks that at least one of the $items is populated
  if (!empty($entity) & $instance['required']) {
    foreach ($items as $item) {
      if (!mcapi_field_is_empty($item, $field)) return;
    }
    $errors[$field['field_name']][$langcode][$delta][] = array(
      'error' => 'mcapi_empty_worth',
      'message' =>  t('!name field is required.', array('!name' => $instance['label']))
    );
  }
}

/**
 * Implements hook_field_widget_error().
 * values come from mcapi_field_validate
 * $element here is the worths_element
 */
function mcapi_field_widget_error(&$element, $error, $form, &$form_state) {
  switch ($error['error']) {
    case 'mcapi_currency_access_membership':
    case 'mcapi_invalid_currency':
      return form_error($element, $error['message']);
    case 'mcapi_empty_worth':
      return form_error($element, $error['message']);
  }
}

function mcapi_field_is_empty($item) {
  return empty($item['quantity']);
}


/*
 * implements hook_form_field_ui_field_edit_form_alter
 * remove the default 'worth' setting from the field settings form
 */
function mcapi_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'worth_field') {
    unset($form['field']['#type']);
    $form['field']['cardinality'] = array(
      '#type' => 'hidden',
      '#value' => 1
   );
  }
}

/*
 * Imlements hook_form_form_ID_alter
 * prevents editing of the worth field attached to the transaction entity.
 */
function mcapi_form_field_ui_field_overview_form_alter(&$form, $form_state) {
  if ($form['#entity_type'] == 'transaction' && isset($form['fields']['worth'])) {
    //TODO: we need to make these pages innaccessible
    //tricky because the paths use variables I think
    $form['fields']['worth']['type']['#type'] = 'markup';
    $form['fields']['worth']['widget_type']['#type'] = 'markup';
    $form['fields']['worth']['delete']['#type'] = 'markup';
  }
}


/*
 * Utility functions
 */

//deficit is an array keyed by by uid, ordered asc
//this is awkward, but the variable is needed for the intertrading module to assess participation credentials
//and there's no easy way to get the lowest balances on this system
function _save_smallest($balance, $uid) {
  $deficits = variable_get('mcapi_deficit', array());
  $deficits[$uid] = $balance;
  sort($deficits);
  //save only the most extreme 3
  variable_set('mcapi_deficit', array_slice($deficits, 0, 3));
}


//returns an array of integer, hundredths, and minus sign if applicable
//if a the passed value is not a number, then pass it through
function currency_explode($number) {
  if (is_numeric($number)) {
    return array_merge(explode('.', number_format(abs($number), 2, '.', '')), array($number < 0 ? '-' : ''));
  }
  return array($number, 0, '');
}

/*
 * rounds a transaction quantity up or down, according to currency settings
 */
function mcapi_round($quant, $currcode, $up = FALSE) {
  $currency = currency_load($currcode);
  switch ($currency->display['divisions']) {
    case CURRENCY_DIVISION_MODE_CUSTOM:
      //calculate the number of hundredths from each division to the fraction, and choose the smallest
      list($int, $fraction) = array_pad(explode('.', $quant), 2, 0);
      foreach ($currency->display['divisions_allowed'] as $division) {
        $diffs[$division] = abs($fraction - $division);
      }
      asort($diffs);
      return "$int.". key($diffs);
      break;
    case CURRENCY_DIVISION_MODE_CENTS_FIELD:
    case CURRENCY_DIVISION_MODE_CENTS_INLINE:
      $quant = round($quant, 2);
    case CURRENCY_DIVISION_MODE_NONE:
      return $quant;
  }
}

/*
 * implements_hook_element_info
 */
function mcapi_element_info() {
  return array(
    'worth' => array(
      '#input' => TRUE,
      '#title_display' => 'attribute',
      '#process' => array('worth_element_process'),
      '#element_validate' => array('worth_element_validate'),
      '#theme' => 'worth_element',
      '#config' => FALSE, //bypasses value processing
      //defaults
      '#required' => TRUE,
    ),
    //this is only used by the field API for mixed transaction forms
    'worths' => array(
      '#title' => t('Worth'),
      '#input' => TRUE,
      '#title_display' => 'before',
      '#element_validate' => array('worths_element_validate'),
      '#theme' => 'worths_element',
      '#theme_wrappers' => array('form_element'),
      //defaults
      '#required' => TRUE,
    )
  );
}


/*
 * implements form_type_ELEMENT_NAME_value
 * return the two numeric fields in the element back as one float
 * Untidily, the main_quant and the div quant fields are also added to this element by the form builder
 * but they should be ignored.
 */
function form_type_worth_value(&$element, $edit = FALSE, &$form_state) {
  if ($edit == FALSE) return;
  $value = array(
    'currcode' => $edit['currcode'],
    'quantity' => $edit['main_quant']
  );

  if (empty($element['#config'])) {
    $value['quantity'] += 0; //ensure its a number
    //combine integer and division to get quantity
    if ($div = @$edit['div_quant'] + 0) {
      $value['quantity'] += $div/100;
    }
  }
  //decluttering
  unset($element['currcode'], $element['main_quant'], $element['div_quant']);
  //we have to set the form_state[values] here because they have probably already been set by the parent element
  //they are only set automatically if they haven't been set at all
  drupal_array_set_nested_value($form_state['values'], $element['#array_parents'], $value);
  return $value;
}


function currency_picker_element(array $currcodes, $default = NULL, $multiple = 0) {
  $currencies = &drupal_static('currencies');
  if (count($currcodes) > 1) {
    foreach ($currcodes as $currcode) {
      $options[$currcode] = $currencies[$currcode]->human_name;
    }
    return array(
      '#title' => t('Currency'),
      '#title_display' => 'attribute',
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => $default,
      '#multiple' => $multiple
    );
  }
  else {
    return array(
      '#type' => 'hidden',
      '#value' => current($currcodes)
    );
  }
}
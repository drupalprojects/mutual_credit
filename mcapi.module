<?php

/**
 * @file
 * mcapi.module
 */

use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
//use Drupal\Core\Cache\CacheBackendInterface;
//use Drupal\Core\Field\FieldItemList;
//use Drupal\mcapi\Plugin\Field\FieldType\Worth;//needed?
use Drupal\Core\Utility\Token;
use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\mcapi\Entity\TransactionInterface;
use \Drupal\field\Entity\FieldInstanceConfig;
use Symfony\Component\HttpFoundation\Request; //for hook_help
use Drupal\mcapi\Entity\WalletInterface;

//we could maybe do without these
define('CURRENCY_TYPE_ACKNOWLEDGEMENT', 'acknowledgement');
define('CURRENCY_TYPE_EXCHANGE', 'exchange');
define('CURRENCY_TYPE_COMMODITY', 'commodity');

//states are mutually exclusive
define('TRANSACTION_STATE_FINISHED', 'done');
define('TRANSACTION_STATE_UNDONE', 'undone');

//negative numbers are used here, and positive numbers represetn uids in the db
define('WALLET_ACCESS_OWNER', 'o');//this is replaced with a named user
define('WALLET_ACCESS_EXCHANGE', 'e');
define('WALLET_ACCESS_AUTH', '2');
define('WALLET_ACCESS_ANY', '1');
define('WALLET_ACCESS_USERS', 'u');

function mcapi_requirements($phase) {
  if ($phase == 'runtime') {
    $result = array(
      'title' => t('Transaction index table'),
    );
    //check that the index table is integral
    if (\Drupal::entityManager()->getStorage('mcapi_transaction')->indexCheck()) {
      $result['severity'] = REQUIREMENT_OK;
      $result['description'] = t('Index table adds up');
    }
    else {
      $result['severity'] = REQUIREMENT_ERROR;
      $result['description'] = t('Index table does not add up. Try rebuilding it at !link', array('!link' => l('admin/accounting/misc', 'admin/accounting/misc')));
    }
    return array($result);
  }
}

/**
 * wrapper around entity_load_multiple
 * load many transactions and key them by serial number instead of xid
 * @param mixed
 *   a serial number or array of serial numbers
 * @return mixed
 *   an array of transaction entities or one transaction entity, depending on the input
 *
 * @todo this is only used twice so far is it really needed?
 */
function mcapi_transaction_load_by_serial($serials) {
  $transactions = array();
  if ($serials) {
    $results = entity_load_multiple_by_properties('mcapi_transaction', array('serial' => (array)$serials));
    //put all the transaction children under the parents
    foreach ($results as $xid => $transaction) {
      if ($pxid = $transaction->get('parent')->value) {
        $results[$pxid]->children[] = $transaction;
        unset($results[$xid]);
      }
    }
    //I had a problem on uninstalling the tester module that all the parents were somehow deleted already
    //which rather screwed up this function.
    //change the array keys for the serial numbers
    foreach ($results as $transaction) {
      $transactions[$transaction->serial->value] = $transaction;
    }
  }

  if (is_array($serials)) return $transactions;
  else return reset($transactions);
}
/**
 * implements hook_help()
 * TODO shouldn't there be some in each page controller to inject help?
 */
function mcapi_help($route_name, Request $request) {
  switch ($route_name) {
    case 'mcapi.admin':
      return t('The intention of this package is to put the money creation power in the hands of the producers and users of money and to reduce dependence of ordinary people on rapacious global financial capital.');
    case 'mcapi.admin_currency_list':
      return implode(' ', array(
        t('Multiple currencies allow many, potentially overlapping communities to work in this Drupal instance, and for currencies to embody different values.'),
        t('Retired currencies can no longer be used, but transactions are still visible.'),
      ));
    case 'mcapi.admin.workflow':
      return implode(' ', array(
        t('Workflow transitions move transactions between states.'),
        t('Each transition presents the user with confirmation form, which is configured on this page')
      ));
  }
}

/**
 * get a transaction transition plugin or array of all plugins
 * N.B. transitions are NOT configurable entities, but plugins with a settings file each
 *
 * @param string $op_name
 *   the plugin id of the transition
 * @return $plugin or array of plugins
 *   depending on whether an op_name was passed
 * @todo allow transitions to be disabled to save processing.
 * @todo perhaps this function shoul be in the plugin manager?
 * @todo rename transitions to transitions because d8 now has entity transitions which are not configurable and not very extensible.
 */
function transaction_transitions($op_name = NULL) {
  //TODO when to use drupal_static and when to use drupal_static_fast?
  $plugins = &drupal_static(__FUNCTION__, array());
  if (empty($plugins)) {
    $manager = \Drupal::service('plugin.manager.mcapi.transaction_transition');
    $plugins = $manager->loadActive();
  }
  if ($op_name) return $plugins[$op_name];
  else return $plugins;
}

//shows the most common transitions
function show_transaction_transitions($view = TRUE) {
  $ops = transaction_transitions();
  unset($ops['create']);
  if (!$view) unset($ops['view']);
  return $ops;
}


/**
 * implements hook_permission().
 * we use another hook here to collect all the permissions together rather than spread all over the permission page
 */
function mcapi_permission() {
  return \Drupal::moduleHandler()->invokeAll('mcapi_info_drupal_permissions');
}

/**
 * implements hook_theme().
 */
function mcapi_theme($existing, $type, $theme, $path) {
  module_load_include('inc', 'mcapi');
  return _mcapi_theme();
}

/**
 * implements hook_entity_view().
 * add a wallet summary view to wallet-enabled entities
 */
function mcapi_entity_view(&$build, $entity, $mode, $language) {
  //check the entity is of a type which can own a wallet.
  $quants = \Drupal::config('mcapi.wallets')->get('entity_types');
  $key = $entity->getEntityTypeId() .':'. $entity->bundle();
  if (array_key_exists($key, $quants) && $quants[$key]) {
    module_load_include('inc', 'mcapi');
    $build['wallets_summaries'] = mcapi_view_wallets_summaries($entity);
  }
}


/**
 * Implements hook_form_alter();
 * Add a submit callback to ContentEntityForms for contentTypes which reference exchanges
 * to check for entities joining and leaving exchanges
 * Form_alter is rather a blunt instrument but it is the best available.
 * Would be better to use hook_entity_presave or postsave but the old values aren't available there
 */
function mcapi_form_alter(&$form, &$form_state, $form_id) {
  if (array_key_exists('controller', $form_state) && $form_state['controller'] instanceof \Drupal\Core\Entity\ContentEntityFormController) {
    $entity = $form_state['controller']->getEntity();
    module_load_include('inc', 'mcapi');
    $lookup = bundles_in_exchanges();
    $entity_type = $entity->getEntityTypeId();
    if (array_key_exists($entity_type, $lookup)) {
      if (array_key_exists($entity->bundle(), $lookup[$entity_type])) {
        form_load_include($form_state, 'inc', 'mcapi');
        array_unshift($form['actions']['submit']['#submit'], 'mcapi_exchanges_changed_submit');
      }
    }
  }
}

/**
 * just gets the children and puts them side by side with the parent
 * Makes it easier to iterate through
 *
 * @param TransactionInterface $transaction
 *
 * @return array
 *   transactions with the cloned parent transaction first and children property removed
 */
function mcapi_transaction_flatten(TransactionInterface $transaction) {
  $clone = clone($transaction);
  $flatarray = array($clone);
  if (!empty($clone->children)) {
    foreach ($clone->children as $child) {
      $flatarray[] = $child;
    }
  }
  return $flatarray;
}

/**
 * get a string suitable describing the states
 * @return string
 *   the label and description of every state.
 * NOT CURRENTLY USED
 */
function mcapi_get_state_descriptions() {
  foreach (entity_load_multiple('mcapi_state') as $state) {
    //we'll save the translators the effort...
    $desc[] = $state->label .' - '. $state->description .'.';
  }
  return t('State explanations: @explanations', array('@explanations' => implode(' | ', $desc)));
}


/**
 * implements mcapi hook_mcapi_info_drupal_permissions().
 */
function mcapi_mcapi_info_drupal_permissions() {
  $perms = array(
    'create own wallets' => array(
      'title' => t('Create own wallets'),
      'description' => t('Users can have as many wallets as they like.')
    ),
    'manage own exchanges' => array(
      'title' => t('Manage exchanges'),
      'description' => t('Accounting permissions in all exchanges of which the user is a member')
    ),
    'configure mcapi' => array(
      'title' => t('Configure community accounting'),
      'description' => t('Design and setup the accounting system')
    ),
    'manage mcapi' => array(
      'title' => t('Manage community accounting'),
      'description' => t('Suitable for accountants')
    )
  );
  if (\Drupal::config('mcapi.misc')->get('editable')) {
    $perms['edit transactions'] = array(
    	'title' => t('Edit transactions'),
      'description' => t('Use the Edit transition on transactions in your exchange. See config for details.')
    );
  }
  return $perms;
}

/**
 * implements hook_mail().
 * @todo remove this when we have rules
 */
function mcapi_mail($key, &$message, $params) {
  if ($key == 'transition') {
//    echo 'mcapi_mail seems to have no language';print_r(array_keys($message));print_r(array_keys($params));
    $options = array('language' => $message['langcode'], 'sanitize' => FALSE);
    $message['subject'] =  \Drupal::Token()->replace($params['subject'], $params, $options);
    $message['body'][] =  \Drupal::Token()->replace($params['body'], $params, $options);
    $message['headers']['cc'] = $params['cc'];
  }
}


/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_entity_extra_field_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_entity_extra_field_info();
}

/**
 * Machine name callback
 * Load a currency, from its id
 *
 * @param string $id
 *
 * @returns CurrencyInterface
 *
 * @todo is this still needed?
 */
function mcapi_currency_load($id) {
  return entity_load('mcapi_currency', $id);
}

/**
 * Helper function to populate a form widget's options with entity names
 *
 * @param string $entity_type_id
 *
 * @param array $data
 *   either entities of the given type, entity ids, or $conditions for entity_load_multiple_by_properties
 *
 * @return array
 *   The entity names, keyed by entity id
 */
function mcapi_entity_label_list($entity_type_id, array $data = array()) {
  if (empty($entities)) {
    $entities = entity_load_multiple($entity_type_id);
  }
  elseif(is_string(key($entities))) {
    $entities = entity_load_multiple_by_properties($entity_type_id, $data);
  }
  elseif(is_integer(reset($entities))) {
    $entities = entity_load_multiple($entity_type_id, $entities);
  }
  $list = array();
  foreach ($entities as $entity) {
    $list[$entity->id()] = $entity->label();
  }
  //TODO sort these entities by weight but how?
  return $list;
}

/**
 * return a list of exchanges from an entity_reference field in an entity
 * If an exchange is passed, it returns itself
 *
 * @param ContentEntityInterface $entity
 *   any Content Entity which has a reference field pointing towards mcapi_exchange entities
 * @return array
 *   of entities, keyed by exchange id
 * @todo cache this
 */
function referenced_exchanges(ContentEntityInterface $entity = NULL, $enabled = FALSE, $open = FALSE) {
  $exchanges = array();
  if (is_null($entity)) {
    $entity = entity_load('user', \Drupal::currentUser()->id());
  }
  $entity_type = $entity->getEntityTypeId();
  if ($entity_type == 'mcapi_exchange') {
    //an exchange references itself only
    $exchanges[$entity->id()] = $entity;
  }
  else{
    $fieldnames = get_exchange_entity_fieldnames();
    if ($fieldname = @$fieldnames[$entity_type]) {
      //TODO I wouldn't be surprised if there was a better way to iterate through these
      foreach($entity->get($fieldname)->getValue(TRUE) as $item) {
        if ($item['entity']) {//an empty $item means the exchangeItemList is empty
          if ($enabled && !$item['entity']->status->value) continue;
          if ($open && !$item['entity']->open->value) continue;
          $exchanges[$item['target_id']] = $item['entity'];
        }
      }
    }
  }
  return $exchanges;
}

/**
 * get a list of all the entity types which have an entity reference field pointing to mcapi_exchange
 *
 * @param string $type
 *   (optional) the name of the entity type
 *
 * @return array
 *   a mapping of entityTypeId to the name of the exchanges entity_reference
 *   field or the fieldname for the given entitytype
 *
 * @todo cache and static this. cache should be cleared whenever fieldInfo changes
 *
 * for every bundle get the name of any entity reference field linked to mcapi_exchanges
 */
function get_exchange_entity_fieldnames() {
  $types = array();
  //get all the instances of these fields
  foreach (entity_load_multiple_by_properties('field_config', array('type' => 'entity_reference')) as $field) {
    if ($field->settings['target_type'] == 'mcapi_exchange') {
      $types[$field->entity_type] = $field->name;
    }
  }
  return $types;
}

/**
 * get all the currencies from (common to) the given exchanges, sorted
 * @param array $exchanges
 * @param boolean $ticks
 *   filter out currencies with no exchange rate
 * @param boolean $status
 *   filter out disabled currencies
 * @return array
 *   the filtered currencies
 */
function exchange_currencies(array $exchanges, $ticks = FALSE) {
  $currencies = array();
  foreach ($exchanges as $exchange) {
    //TODO is there a shorter way to iterate through these referenced entities
    foreach ($exchange->get('currencies')->getValue(TRUE) as $item) {
      if (empty($item))continue;//this should never happen because an exchange can't have no currencies
      $currency = $item['entity'];
      if ($ticks && !$currency->ticks) continue;
      $currencies[$item['target_id']] = $currency;
    }
  }
  uasort($currencies, array('\Drupal\Component\Utility\SortArray', 'sortByWeightProperty'));
  return $currencies;
}

/**
 * Load currencies for a given wallet, or common to 2 given users
 * A list of all the currencies in the marketplaces of which the user is a member.
 *
 * @param AccountInterface $account
 *   an entity which might be in an exchange
 * @return array
 *   of currencies
 * @todo move this to where it is needed
 */
function mcapi_currencies_for_user(AccountInterface $account = NULL, $status = FALSE, $ticks = FALSE) {
  return exchange_currencies(referenced_exchanges($account, $status), $ticks);
}

/**
 * implements hook_mcapi_transaction_operated().
 * This invokes rules, if installed, but can be used by any module
 *
 * @param TransactionInterface $transaction
 * @param array $context
 *   consists of op_plugin_id; config, the transition plugin configuration; old_state: the state of the transaction before the transition
 */
function mcapi_mcapi_transaction_operated($transaction, $context) {
  //TODO invoke rules hook
  //make a note that the proper way to trigger mails is via each transitions' settings
  drupal_set_message('Ran hook_transaction_operated');
}

/**
 * implements_hook_element_info().
 */
function mcapi_element_info() {
  module_load_include('inc', 'mcapi');
  return _mcapi_element_info();
}

/**
 * process callback for worth form element
 * This single element processes multiple currencies as one value, like the checkboxes widget
 */
function mcapi_worth_element_process($element, &$form_state, $form) {
  form_load_include($form_state, 'inc', 'mcapi');
  return _mcapi_worth_element_process($element, $form_state, $form);
}


/**
 * process callback for mcapi_state form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_states($element) {
  $element['#options'] = mcapi_entity_label_list('mcapi_state');
  $element = form_process_radios($element);
  return $element;
}

/**
 * process callback for mcapi_types form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_types($element) {
  $element['#options'] = mcapi_entity_label_list('mcapi_type');
  return $element;
}

/**
 * process callback for mcapi_currency_select form element
 *
 * @param array $element
 * @param array $form_state
 * @return array
 *   the processed $element
 */
function mcapi_process_currcodes($element) {
  $conditions = array();
  if ($element['#status']) {
    $conditions['status'] = TRUE;
  }
  if (empty($element['#options']) && !empty($element['#curr_ids'])) {
    //shows the intersection of all currencies and currencies provided
    $element['#options'] = array_intersect_key(
      mcapi_entity_label_list('mcapi_currency', $element['#curr_ids']),
      entity_load_multiple_by_property('mcapi_currency', $conditions)
    );
  }
  elseif (empty($element['#options'])) {
    $element['#options'] = $element['#options'] = mcapi_entity_label_list('mcapi_currency', $conditions);
  }
  elseif ($element['#options'] == 'all') {
    $element['#options'] = mcapi_entity_label_list('mcapi_currency');
  }

  if (count($element['#options']) == 1) {
    //$element['#type'] = 'value';
    $element['#type'] = 'value';
    $element['#theme_wrappers'] = array();
    $element['#default_value'] = key($element['#options']);
  }
  elseif ($element['#multiple']) {
    //have to do some of the checkbox processing manually coz we missed it
    $element['#type'] = 'checkboxes';
    $element['#value'] = array_filter($element['#default_value']);
    $element = form_process_checkboxes($element);
  }
  else {
    $element['#theme'] = 'select';
  }
  return $element;
}

/**
 * select_wallet element callbacks
 * these could all go in a different file
 */
/**
 * process callback for wallet_select element
 */
function mcapi_process_select_wallet($element, &$form_state) {
  $element['#autocomplete_route_name'] = $element['#local']
    ? 'mcapi.wallets.autocomplete'
    : 'mcapi.wallets.autocomplete_all';
  return $element;
}

/**
 * value callback for wallet widget
 * takes from the autocomplete select_wallet field and returns an integer candidate wallet id.
 */
function form_type_select_wallet_value(&$element, $input, &$form_state) {
  if (empty($input)) return;
  if (is_numeric($input) && is_integer($input + 0)) {
    return $input;
  }
  //get the number after the last hash
  return substr($input, strrpos($input, '#')+1);
}

/**
 * element_validate callback for select_wallet
 * ensure the passed value is a wallet id, not of an intertrading wallet
 */
function local_wallet_validate_id(&$element, &$form_state) {
  $message = '';
  if (is_numeric($element['#value'])) {
    $wallet = entity_load('mcapi_wallet', $element['#value']);
    if (!$wallet) {
      $message = t('Invalid wallet id: @value', array('@value' => $element['#value']));
    }
    elseif($wallet->name->value == '_intertrading') {
      $message = t('You cannot trade with wallet #@value directly', array('@value' => $element['#value']));
    }
  }
  if ($message) {
    \Drupal::formBuilder()->setError($element, $form_state, $message);
  }
}

/**
 * element_prerender callback for select_wallet
 * convert the #default value from a wallet id to the autocomplete format
 * ensure the autocomplete address is going to the right place
 */
function mcapi_prerender_wallet_field($element) {
  if (is_numeric($element['#default_value'])) {
    $wallet = entity_load('mcapi_wallet', $element['#default_value']);
    if ($wallet) {
      //this label contains the #id which is picked up by the value callback
      $element['#default_value'] = $wallet->label(NULL, FALSE);
    }
    else {
      drupal_set_message(t("Wallet preset '@num' does not exist", array('@num' => $element['#default_value'])), 'warning');
    }
  }
  return $element;
}


/**
 * load the transaction states and filter them according to the misc settings
 *
 * @param boolean $counted
 *
 * @return Drupal\Core\Config\Entity\ConfigEntityInterface[]
 *
 * @todo later we might want to provide a fuller interface for editing states
 * types, esp the name and description e.g. admin/accounting/workflow/states
 *
 * @todo cache this
 *
 */
function mcapi_states_counted($counted = TRUE) {
  $counted_states = \Drupal::config('mcapi.misc')->get('counted');
  $states = entity_load_multiple('mcapi_state');
  foreach ($states as $state) {
    if (array_key_exists($state->id, $counted_states)) {
      if ($counted_states[$state->id] == $counted) {
        $result[$state->id] = $state;
      }
    }
    else {
      if ($state->counted == $counted) {
        $result[$state->id] = $state;
      }
    }
  }
  return $result;
}

/**
 * implements hook_element_info_alter().
 * adds the 'balances' icon via css
 */
function mcapi_element_info_alter(&$items) {
  $items['toolbar']['#attached']['css'][] = drupal_get_path('module', 'mcapi') . '/css/mcapi.icons.css';
}

/**
 * field api default value callback
 * when creating a new user, populate the exchanges field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 * @param ContentEntityInterface $entity,
 * @param array $field_definition,
 * @param string $langcode
 * @return string
 *   The uuid of the exchange
 * //TODO an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_exchange_id(ContentEntityInterface $entity, $field_definition, $langcode) {
  $output = array();
  foreach (referenced_exchanges($entity, TRUE) as $exchange) {
    $output[]['target_uuid'] = $exchange->get('uuid')->value;
  }
  return $output;
}

/**
 * field api default value callback
 * TEMP...
 * when creating a new exchange, populate the currencies field
 * with the currentuser's values.
 * N.B. in FieldItemList::setValue
 *
 * @param ExchangeInterface $entity,
 * @param array $field_definition,
 * @param string $langcode
 * @return
 *   an array of uuids whose keys I haven't understood yet
 */
function mcapi_default_currency_id(ExchangeInterface $entity, $field_definition, $langcode) {
  $output = array();
  //temporary until we work out what the default should be.
  $output[]['target_uuid'] = entity_load('mcapi_currency', 1)->get('uuid');
  return $output;
}

/**
 * implements hook_entity_insert()
 * give a new wallet to new entities, if the settings require
 */
function mcapi_entity_insert($entity) {
  $type = $entity->getEntityTypeId();
  if (!\Drupal::config('mcapi.wallets')->get('autoadd')) return;
  $entity_bundle = $type .':'. $entity->bundle();
  $max = \Drupal::config('mcapi.wallets')->get('entity_types.'.$entity_bundle);
  if (!$max) return;
  //no need to check what the max is, since this is the first wallet created for this entity
  $wallet = array(
    'entity_type' => $type,
    'pid' => $entity->id(),
    'viewers' => 'dunno',
    'payers' => 'dunno',
    'payees' => 'dunno',
  );
  if ($type == 'mcapi_exchange') {
    $wallet['name'] = '_intertrading';
    $wallet['details'] = WALLET_ACCESS_AUTH;
    $wallet['summary'] = WALLET_ACCESS_AUTH;
    $wallet['payin'] = WALLET_ACCESS_AUTH;
    $wallet['payout'] = WALLET_ACCESS_AUTH;
  }
  $wallet = entity_create('mcapi_wallet', $wallet);
  $wallet->save();
}

/**
 * implements hook_entity_delete()
 * ensure any wallets belonging to the entity are moved to their parent's exchange
 * @todo this should be pre-deletion
 */
function mcapi_entity_delete($entity) {
  //see Exchange::preDelete();
  if ($entity instanceof ContentEntityInterface && $exchanges = referenced_exchanges($entity)) {
    $exchange = current($exchanges);//if the parent entity was in more than one exchange, this will pick a random one to take ownership
    if ($wids = \Drupal\mcapi\Storage\WalletStorage::getOwnedWalletIds($entity)) {
      foreach (entity_load_multiple('mcapi_wallet', $wids) as $wallet) {
        $wallet->orphan($exchange);
      }
    }
  }
}

/**
 * get the entity from a Request object, whatever the entitytype
 * this is quite hacky
 *
 * @param Request $request
 * @return ContentEntityInterface object
 */
function mcapi_request_get_entity($request) {
  foreach ($request->attributes->get('_route_params') as $key => $value) {
    if (substr($key, 0, 1) == '_')continue;
    return $value;
  }
}

/**
 * developer-friendly wrapper around the wallet storage controller function, getOwnedWalletIds().
 * @param Drupal\Core\Entity\ContentEntityInterface $entity
 * @return array
 *   wallet ids belonging to the passed entity
 */
function mcapi_get_wallet_ids(ContentEntityInterface $entity) {
  return \Drupal::EntityManager()->getStorage('mcapi_wallet')->getOwnedWalletIds($entity);
}

/**
 * implements hook_block_view_BLOCK_BASE_ID_alter
 * Add a links to the menu block, one for each exchange the current user is in.
 * The alternative, to create many links and give them all access control would be
 * rather expensive, I think
 * @todo second opinion?
 */
function _mcapi_block_view_system_menu_block_alter(&$build, $block) {
  if($block->getPluginId() == 'system_menu_block:tools') {
    if (!array_key_exists('content', $build)) {
      $build['content'] = array();
    }
    foreach (referenced_exchanges(NULL, TRUE) as $exchange) {
      //does a menu link really require all of these properties
      $renderable = array(
      	'#theme' => 'menu_link',
        '#title' => $exchange->label(),
        '#href' => $exchange->url(),
        '#weight' => -100,
        '#localized_options' => array(),
        '#below' => array(),
        '#attributes' => array(),
        '#original_link' => array('menu_name' => 'tools'),//required by menu_block_view_system_menu_block_alter
      );
      array_unshift($build['content'], $renderable);
    }
    //@todo exchange admins links to their currency(s) OR a link to admin/accounting/currencies
  }
}

/**
 * implements hook_local_tasks_alter().
 * prevent the three fixed transaction display modes from being edited
 * this function will fail if mcapi is not heavier than field_ui module
 */
function mcapi_local_tasks_alter(&$tasks) {
  $names = array('certificate_mcapi_transaction', 'twig_mcapi_transaction', 'sentence_mcapi_transaction');
  foreach ($names as $name) {
    unset($tasks['field_ui.fields:field_display_'.$name]);
  }
}

/**
 * implements hook_entity_operation_alter();
 * prevent the transaction view modes from being tampered with
 */
function mcapi_entity_operation_alter(&$operations, $entity) {
  $ids = array(
    'mcapi_transaction.certificate',
    'mcapi_transaction.twig',
    'mcapi_transaction.sentence'
  );
  if (in_array($entity->id(), $ids)) $operations = array();
}

/**
 * get the Transition links for a transaction
 * @param TransactionInterface $transaction
 * @param boolean $view_link
 *
 * @return array
 *   a renderable array
 */
function mcapi_get_links(TransactionInterface $transaction, $view_link = FALSE) {
  static $transactionViewBuilder;
  if (!$transactionViewBuilder) {
    $transactionViewBuilder = \Drupal::EntityManager()->getViewBuilder('mcapi_transaction');
  }
  return $transactionViewBuilder->renderLinks($transaction, 'sentence');
}

/**
 * Delete all transaction entities
 * For development only!
 * @TODO move this to be a drush command
 */
function mcapi_wipeslate() {
  $conf = \Drupal::config('mcapi.misc');
  $indelible = $conf->get('indelible');
  $conf->set('indelible', TRUE)->save();
  $controller = \Drupal::entityManager()->getStorage('mcapi_transaction');
  $entities = $controller->loadMultiple();
  $controller->delete($entities, TRUE);
  $conf->set('indelible', $indelible)->save();
}

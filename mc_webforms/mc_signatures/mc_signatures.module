<?php
//// $Id$

/*
 * 'Signatories' is an added property of pending exchanges
 *  mc_webforms module half expects this to be present.
 */

function mc_signatures_menu() {
  $items['exchange/%node/sign/%user_uid_optional'] = array(
    'title' => 'Sign this exchange to finalise it',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mc_sign_form', 1),
    'access callback' => 'sign_exchange_access',
    'access arguments' => array(1,3),
    'type' => MENU_CALLBACK,
  );
  $items['exchange/%/signoff'] = array(
    'title' => 'Sign off exchange',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mc_signall_confirm_form', 1),
    'access arguments' => array('edit all exchanges'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}


//access callback
//does the current user have permission to remove the signatory from the given exchange?
//on if they have 'edit all exchanges' or they are named signatory.
function sign_exchange_access($node, $signatory_account) {
  if ($node->state != EXCHANGE_STATE_PENDING) {
    return FALSE;
  }
  if (user_access('edit all exchanges')) {
    return TRUE;
  }
  return $GLOBALS['user']->uid == $signatory_account->uid;
}


/*
 * Needed for the views 2 module
 */
function mc_signatures_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'mc_signatures') .'/views',
  );
}

/*
 * Implementation of hook_nodeapi
 * (broken up, ready for drupal 7)
 *
 * this is used for modifying the node, mostly with regard to unsigned.
   */

function mc_signatures_nodeapi(&$node, $op) {
  if ($node->type != 'exchange') return;
  switch($op) {
    case 'load':
      mc_signatures_node_load($node);
    break;
    case 'delete':
      mc_signatures_node_delete($node);
    break;
    case 'insert':
    case 'update':
      mc_signatures_require($node);
  }
}


function mc_signatures_node_load(&$node) {
  if ($node->state == EXCHANGE_STATE_PENDING) {
    //override the stored data with the actual data form the 'unsigned' table
    $result = db_query("SELECT uid FROM {mc_unsigned} WHERE nid = %d", array(':nid' => $node->nid));
    while($uid = db_result($result)) {
      $node->mc_unsigned[] = $uid;
    }
  }
}

function mc_signatures_node_delete($node) {
  switch ($node->type) {
    case 'exchange':
      _clear_unsigned('nid', $node->nid);
  }
}


//shows a confirm form and/or completes the exchange
function mc_sign_form(&$form_state, $exchange) {
  if (!variable_get('mc_signatures_sure', TRUE)) {
    mc_one_signing($exchange, arg(3));
    drupal_goto(variable_get('mc_webform_destination', 'user'));
  }
  $form = array();
  $form['#node'] = $exchange;
  $form['#signer'] = arg(3);
  $form['#prefix'] = theme('node', $exchange, FALSE, TRUE);
  $form['#redirect'] = 'node/'. $exchange->nid;
  return confirm_form(
    $form,
    t('Are you sure you want to sign this exchange?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}


function mc_sign_form_submit($form, &$form_state) {
  mc_one_signing($form['#node'], $form['#signer']);
}
function mc_one_signing($node, $signer_uid){
  $result = db_query("SELECT uid FROM {mc_unsigned} WHERE nid = %d", array(':nid' => $node->nid));
  while ($uid = db_result($result)) {
    if ($uid == $signer_uid) {
      db_query("DELETE FROM {mc_unsigned} WHERE nid = %d AND uid = %d", array(':nid' => $node->nid, ':uid' => $uid));
      drupal_set_message(t('!signer signed the exchange', array('!signer' => theme('username', user_load($uid)))));
    }
    else {
      $unfinished = TRUE;
    }
  }
  if (!isset($unfinished)) {
    $node->state = EXCHANGE_STATE_FINISHED;
    node_save($node);
    module_invoke_all('after_transaction', 'update', $node);
    drupal_set_message(t('The exchange is now finished'));
  }
}

/*
 * Implementation of hook_exchange_record
 * add the signatories
 */
function mc_signatures_require(&$node) {
  if ($node->state != EXCHANGE_STATE_PENDING) return;
  //based on the exchange_type, we know which signatories to add
  switch($node->exchange_type) {
    case '3rdparty':
    case 'many2one':
    case 'one2many':
    case 'few2one':
    case 'one2few':
      $node->mc_unsigned = array($node->payer_uid, $node->payee_uid);
    break;
    case 'incoming signed':
      $node->mc_unsigned = array($node->payer_uid);
    break;
    case 'outgoing signed':
      $node->mc_unsigned = array($node->payee_uid);
    break;
  }
  //this module assumes that every pending exchanges is awaiting at least one signature
  //clear all the completers ready for re-adding
  if (isset($node->nid)) {
    _clear_unsigned('nid', $node->nid);
  }
  $rows = array();
  if (!count($node->mc_unsigned)) {
    drupal_set_message(t("This exchange is pending, but has no signatories"), 'error');
    return;
  }
  foreach ($node->mc_unsigned as $uid) {
    $rows[] = '('. $node->nid .', '. $uid .')';
  }
  db_query("INSERT INTO  {mc_unsigned} (nid, uid) VALUES %s",
    array(':values' => implode(', ', $rows))
  );
}

function _clear_unsigned($field, $id) {
  db_query("DELETE FROM {mc_unsigned} WHERE $field = $id");
  if ($field == 'nid') {
    db_query("UPDATE {node} SET changed = %d WHERE nid = %d", array(':mod' => time(), ':nid' => $id));
  }
}

/**
 * http://api.drupal.org/api/function/hook_link/6
 * Add the 'sign' links to each exchange node
 */
function mc_signatures_link($type, $exchange) {
  //ignore comments, nodes which aren't created yet, or nodes which aren't exchanges
  if ($type != 'node' || !$exchange->nid || $exchange->type != 'exchange') return array();

  //sign buttons
  if ($exchange->state == EXCHANGE_STATE_PENDING) {
    if (!isset($exchange->mc_unsigned)) {
      drupal_set_message(t("This exchange is pending, but has no signatories"), 'error');
      return;
    }
    mc_append_sign_links($exchange, $links);
  }
  if (isset($links)) {
    return $links;
  }
}

function mc_signatures_form_alter($form, $form_state, $form_id) {
  switch ($form_id) {
    case 'mc_3rdparty_form':
    case 'mc_edit_form':
      if ($form_state['storage']['step'] == 1) {
        //change state to checkbox corresponding to EXCHANGE_STATE constants
        $form['state']['#type'] = 'checkbox';
        $form['state']['#title'] = t('Require signatures');
        unset($form['state']['#description']);
      }
      $form['state']['#element_validate'][] = 'mc_signature_validate_state';
  }
}

//in many cases, we rely on this function to set the value of the field, which is often hidden
function mc_signature_validate_state(&$element, $form_state) {
  //set this to pending if the exchange type expects it AND the node isn't created yet
  //however on form stage 2, '$form_state['values'] doesn't contain most fields
  if (isset($form_state['values']['exchange_type']) && strpos($form_state['values']['exchange_type'], 'signed') && !isset($form_state['values']['nid'])) {
    $form_state['values']['state'] = EXCHANGE_STATE_PENDING;
  }
  //the value is changed as the node is signed
}


//this function has been pulled out of hook_links so views can access it
function mc_append_sign_links($exchange, &$links) {
  if (!isset($exchange->mc_unsigned)) return;
  foreach ($exchange->mc_unsigned as $uid) {
    $signatory_account = user_load($uid);
    if (sign_exchange_access($exchange, $signatory_account)) {
      if ($uid == $GLOBALS['user']->uid) {
        $link_title = t('Sign this exchange');
      }
      else{
        $link_title = t('Sign for @user', array('@user' => strip_tags(theme('username', $signatory_account))));
      }
      $links['sign '.$uid] = array(
        'title' => $link_title,
        'href' => 'exchange/'. $exchange->nid .'/sign/'.$uid,
        'weight' => -1
      );
    }
  }

  if (user_access('edit all exchanges') && count($exchange->mc_unsigned) > 1) {
    $links['signall'] = array(
      'title' => t('Sign for all'),
      'href' => 'exchange/'. $exchange->nid .'/signoff',
      'weight' => 25
    );
  }
}

function mc_signall_confirm_form($form_state, $nid) {
  $form = array();
  $form['#redirect'] = 'node/'. $nid;
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $nid
  );
  return confirm_form(
    $form,
    t('Are you sure you want to sign this exchange on behalf of all the remaining signatories?'),
    'user',
    '',
    t('Sign'), t('Cancel'),
    'sign'
  );
}

function mc_signall_confirm_form_submit($form, $form_state) {
  if (user_access('edit all exchanges')){
    $nid = $form_state['values']['nid'];
    _clear_unsigned('nid', $nid);
    db_query("UPDATE {mc_exchanges} SET state = %d WHERE nid = %d", array(':state' => EXCHANGE_STATE_FINISHED,':nid' => $nid));
    drupal_set_message(t("Transaction #@nid is signed off.", array('@nid' => $nid)));
    module_invoke_all('after_transaction', 'update', array(node_load($nid)));
  }
}


function mc_signatures_form_mc_mail_template_alter(&$form) {
  $form['mc_signatures_wrapper'] = array(
    '#title' => t('Request to sign template'),
    '#type' => 'fieldset',
    '#weight' => -2,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE
  );
  $form['mc_signatures_wrapper']['mc_signatures_notification_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Mail subject'),
    '#default_value' => variable_get('mc_signatures_notification_subject', ''),
    '#description' => t('If set, overrides default subject.') .' '. t('Tokens may be used.'),
    '#weight' => 1
  );
  $form['mc_signatures_wrapper']['mc_signatures_notification_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Request to sign'),
    '#default_value' => variable_get('mc_signatures_notification_body', t("Click here to add your signature and finalise the exchange: !sign_link")),
    '#description' => t("This will be added to notification mails.") .' '. t('Tokens may be used as above, plus !sign_link'),
    '#required' => TRUE,
    '#weight' => 2
  );
  $form['buttons']['#weight'] = 2;
}

function mc_signatures_form_mc_webform_settings_alter(&$form, $form_state) {
  $form['mc_signatures_sure'] = array(
    '#type' => 'checkbox',
    '#title' => t('Signature confirmation page'),
    '#description' => t("Display an 'Are you sure?' page when signing an exchange"),
    '#default_value' => variable_get('mc_signatures_sure', TRUE),
    '#weight' => -5,
  );
}

/*
 * Adds to the exchange notification mail
 */
function mc_signatures_mail_alter(&$message) {
  if ($message['id'] != 'mcapimail_notify') return;
  $params = &$message['params'];
  if (!is_array($params['exchange']->mc_unsigned)) return;
  $variables = mc_mail_tokens($params['recipient'], $message['language'], $params['exchange']);
  //alter only messages where the recipient is one of the remaining signatories
  if (!in_array($params['recipient']->uid, $params['exchange']->mc_unsigned)) return;
  //handle only messages if they are required to be sent
  if ($params['recipient']->mc_notification_throttle == 0) return;

  $params['send'] = TRUE;
  $footer = array_pop($message['body']);
  $variables['!sign_link'] = url('exchange/'. $params['exchange']->nid . '/sign/'. $params['recipient']->uid, array('absolute' => TRUE));
  if (variable_get('mc_signatures_notification_subject', '')) {
    $message['subject'] = strtr(variable_get('mc_signatures_notification_subject', ''), $variables);
  }
  $message['body']['sign_link'] = strtr(variable_get('mc_signatures_notification_body', ''), $variables);
  $message['body']['footer'] = $footer;
}

//on the admin/mc page just check that mail templates are filled in
function mc_signatures_form_cforge_report_form_alter() {
  if (!variable_get('mc_signatures_notification_subject', 0) || !variable_get('mc_signatures_notification_body', 0)) {
    drupal_set_message(t('Mail notification templates need to be written: !link', array('!link' => l('admin/mc/notification', 'admin/mc/notification'))), 'warning');
  }
}


function mc_convert_state_checkbox(&$form) {
  //change state from radios (set in mcapi.module) to checkbox
  $form['state']['#type'] = 'checkbox';
  $form['state']['#title'] = t('Require signatures');
  unset($form['state']['#description']);
}

<?php

use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\Entity\Type;
use Drupal\mcapi_signatures\Signatures;
use Drupal\user\UserInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;

define ('TRANSACTION_STATE_PENDING', 'pending');

function mcapi_signatures_help($route_name, $route_match) {
  switch ($route_name) {
    case 'mcapi.admin.signatures':
      return implode(' ', [
        t('Each transaction type determines the initial workflow state of the transaction.'),
        t('Any types here with at least one checkbox will override that state and put the transaction into pending state'),
        t("When all of the specified relatives have signed the transaction moves automatically into 'finished' state.")
      ]);
  }
}

/**
 * implements hook_ENTITY_TYPE_load().
 * alter the start_state of transaction types according to this module's settings
 */
function mcapi_signatures_mcapi_type_load($entities) {
  foreach($entities as $type_id => $entity) {
    $signatory_relatives = $entity
      ->getThirdPartySetting('mcapi_signatures', 'signatures');
    if(!empty($signatory_relatives)) {
      $entity->start_state = 'pending';
    }
  }
}

/**
 * implements hook_ENTITY_TYPE_presave().
 * add the signatures to a new transaction object and sign for the current user
 */
function mcapi_signatures_mcapi_transaction_presave($transaction) {
  //the start state has already been set in transaction::validate
  if ($transaction->state->target_id == 'pending' && $transaction->isNew()) {
    $relatives = Type::load($transaction->type->target_id)
      ->getThirdPartySetting('mcapi_signatures', 'signatures');
    $user_ids = \Drupal::service('mcapi.transaction_relative_manager')
      ->getUsers($transaction, $relatives);
    foreach ($user_ids as $uid) {
      $transaction->signatures[$uid] = 0;
    }
    //sign for the current user
    Signatures::sign($transaction, \Drupal::currentUser());
    //we can't save the signatures until we have the serial number
  }
}

/**
 * implements hook_ENTITY_TYPE_load
 * put the signatories into the transaction entity
 */
function mcapi_signatures_mcapi_transaction_load($entities) {
  $xids = [];
  foreach ($entities as $xid => $e) {
    if ($e->parent->value == 0) {
      $xids[$e->serial->value] = $xid;
    }
  }
  //we load these regardless of settings, just in case settings have changed
  //leaving some transactions invisibly pending.
  //no matter everything will be cached
  $signatures = db_select('mcapi_signatures', 's')
    ->fields('s', ['serial', 'uid', 'signed'])
    ->condition('serial', array_keys($xids), 'IN')
    ->execute()->fetchAll();
  foreach ($signatures as $sig) {
    $entities[$xids[$sig->serial]]->signatures[$sig->uid] = $sig->signed;
  }
}

/**
 * implement mcapi hook_ENTITY_delete
 * this doesn't happen with the undo transition, which merely changes the state.
 * delete the signature data when a transaction is deleted
 */
function mcapi_signatures_mcapi_transaction_delete($transaction) {
  db_delete('mcapi_signatures')
    ->condition('serial', $transaction->serial->value)
    ->execute();
}

/**
 * implements hook_ENTITY_insert().
 * writes the signatures after the transaction is written
 */
function mcapi_signatures_mcapi_transaction_insert($transaction) {
  //we're only interested in parent transactions which have signatures
  if (isset($transaction->signatures) && !$transaction->parent->value) {
    $q = db_insert('mcapi_signatures')
      ->fields(['serial', 'uid', 'signed']);

    foreach ($transaction->signatures as $uid => $signed_unixtime) {
      $q->values([$transaction->serial->value, $uid, $signed_unixtime]);
    }
    $q->execute();
  }
}

/**
 * implements hook_ENTITY_update().
 * rewrites the signatures after the transaction is updated
 */
function mcapi_signatures_mcapi_transaction_update($transaction) {
  if (!isset($transaction->signatures)) return;
  if (empty($transaction->parent)) return;
die('merging');
  foreach ($transaction->signatures as $uid => $signed) {
    $q = db_merge('mcapi_signatures')
      ->keys([
        'serial' => $transaction->serial->value,
        'uid' => $uid
      ])->fields([
        'signed' => $signed
      ])->execute();
  }
}

/**
 * implements hook_theme().
 */
function mcapi_signatures_theme() {
  $items['mcapi_signatures'] = [
    'template' => 'mcapi_signatures',
    'variables' => [
      'transaction' => NULL,
    ]
  ];
  return $items;
}

/**
 * implements hook_ENTITY_TYPE_view().
 * show the signatures on the transaction certificate.
 */
function mcapi_signatures_mcapi_transaction_view(array &$build, $transaction, $display, $view_mode, $langcode) {
  if ($view_mode == 'certificate' && isset($transaction->signatures) && in_array('mcapi_signatures', $display->getComponents())) {
    $build['mcapi_signatures'] = [
      '#theme' => 'mcapi_signatures',
      '#transaction' => $build['#mcapi_transaction'],
      '#attached' => [
        'library' => [
          //@todo check this is included and doesn't overwrite
          'css' => 'mcapi_signatures/signatures.css'
        ]
      ]
    ];
    $build['watermark'] = t('Pending');
  }
}

/**
 * implements hook_entity_extra_field_info().
 */
function mcapi_signatures_entity_extra_field_info() {
  return [
    'user' => [
      'user' => [
        'display' => [
          'mcapi_signatures' => [
            'label' => t('Pending transactions'),
            'description' => t("Transactions awaiting others' signatures"),
            'weight' => 3,
          ],
        ]
      ]
    ],
    'mcapi_transaction' => [
      'mcapi_transaction' => [
        'display' => [
          'mcapi_signatures' => [
            'label' => t('Signatures'),
            'description' => t('List of signatures needed and obtained'),
            'weight' => 5,
          ]
        ]
      ]
    ]
  ];
}

/**
 * Implements hook_ENTITY_TYPE_view() for user entities.
 * add the extraField
 */
function mcapi_signatures_user_view(array &$build, UserInterface $account, EntityViewDisplayInterface $display) {
  if ($display->getComponent('mcapi_signatures')) {
    $build['mcapi_signatures'][] = views_embed_view(
      'mcapi_pending_signatures',
      'other_sig_needed',
      $account->id()
    );
  }
}


function mcapi_signall($form, $form_state, $account) {
  $serials = Signatures::transactions_needing_sig_of_user($account);
  $form['preview'][] = \Drupal::entityManager()
    ->getViewBuilder('mcapi_transaction')
    ->viewMultiple(Transaction::loadBySerials($serials), 'sentence');

  $form['account'] = array(
    '#type' => 'value',
    '#value' => $account
  );
  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Sign all')
  );
  return $form;
}

function mcapi_signall_submit($form, $form_state) {
  $values = $form_state->getValues();
  foreach (Signatures::transactions_needing_sig_of_user($values['account']) as $serial) {
    $transaction = current(Transaction::loadBySerials(array($serial)));
    Self::sign($transaction, $values['account']);
  }
  $transaction->save();
  drupal_set_message($message);
  $form_state->setRedirect('user.page');
}


function transactions_needing_sig_of_user($uid) {
  //assumes data integrity that all transactions referenced are in pending state
  return db_select("mcapi_signatures", 's')
    ->fields('s', array('serial'))
    ->condition('uid', $uid)
    ->condition('signed', '')
    ->execute()
    ->fetchCol();
}

/**
 * implements template_preprocess_THEMEHOOK
 */
function template_preprocess_mcapi_signatures(&$vars) {
  foreach ($vars['transaction']->signatures as $uid => $signed) {
    $account = User::load($uid);
    $vars['signatures'][$uid] = array(
      'account' => $account,
      'class' => 'signature '. (empty($signed) ? 'pending' : 'signed'),
      'name' =>  $account->getUsername(),
    );
  }
}

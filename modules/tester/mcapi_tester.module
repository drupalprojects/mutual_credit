<?php

use Drupal\mcapi\Exchange;
use Drupal\mcapi\Entity\Currency;
use Drupal\mcapi\Entity\Transaction;
use Drupal\mcapi\Entity\Wallet;
use Drupal\mcapi_exchanges\Entity\Exchanges;
use Drupal\user\Entity\User;


/**
 * implements hook_mcapi_exchange_view()
 * adds extra_fields
 */
function __mcapi_tester_mcapi_exchange_view(&$build, $entity, $mode, $language) {
  //@todo this role should be an og role
  if ($roles = user_role_names(TRUE, 'exchange helper')) {
    $helpernames = [];
    //get all the helper users in this exchange
    $query = db_select('users_roles', 'ur')->fields('ur', array('uid'));
    $query->join('user__exchanges', 'f', 'f.entity_id = ur.uid');
    $query->condition('ur.rid', array_keys($roles))
    ->condition('f.exchanges_target_id', $entity->id());

    foreach (User::loadMultiple($query->execute()->fetchCol()) as $account) {
      $helpernames[] = $account->label();//what's the best way to make this a link?
    }
    if (empty($helpernames)) {
      $helpernames = array(t('None'));
    }
    $build['people']['helpers'] = array(
      '#prefix' => '<br />',
      '#markup' => t('Helpers: !names', array('!names' => implode(', ', $helpernames)))
    );
  }
}

function mcapi_tester_make_transactions($num, $exchange = NULL, &$sandbox) {
  //choose an exchange and get the wids in it
  $exchange_ids = [];
  if ($exchange) {//assume the mcapi_exchanges module is enabled
    $all_exchanges = Exchange::loadMultiple();
    $exchange_ids = array_keys($all_exchanges);
    $key = array_rand($all_exchanges);
    $exchange = $all_exchanges[$key];
    //get all the wallets in this exchange
    $q = db_select('og_membership', 'g');
    $q->join('mcapi_wallet', 'w', 'w.wid = g.etid');
    $q->fields('g', array('etid'));
    $q->condition('w.name', '_intertrading', '<>');
    $q->condition('g.group_type', 'mcapi_exchange');
    $q->condition('g.gid', $exchange->id());
    $q->condition('g.entity_type', 'mcapi_wallet');
    $wids = $q->execute()->fetchCol();
    if (count($wids) < 2) {
     throw new \Exception('Not enough wallets to trade: in exchange '.$exchange);
    } 
  }
  else {
    $wallets = \Drupal::EntityManager()->getStorage('mcapi_wallet')->loadByProperties(['entity_type' => 'user']);
    //quick way to select non-intertrading wallets
    $wids = array_keys($wallets);
    if (count($wids) < 2) {
      throw new \Exception('Not enough wallets to trade.');
    }
  }

  for ($i = 1; $i <= $num; $i++) {
    $temp = $wids;
    shuffle($temp);
    $props = array(
      'payer' => array_pop($temp),
      'payee' => array_pop($temp),
      'type' => 'test',
      'creator' => 1,
      'description' => 'autogenerated'
    );

    $props['worth'] = array(
      0 => array(
        'value' => rand(1, 100)*5,
        'curr_id' => 'cc'
      ),
      1 => array(
        'value' => rand(1, 6)*30,
        'curr_id' => 'hhrs'
      )
    );
    $transaction = Transaction::create($props)->save();
  }
  //change the created time of the transactions, coz they mustn't be all in the same second
  //one per day
  db_query('UPDATE {mcapi_transaction} SET created = created-(serial*3600*12)');
  db_query('UPDATE {mcapi_transactions_index} SET created = created-(serial*3600*12)');
  $days = $num/2;
  db_query(
    'UPDATE {mcapi_wallet} SET created  = :created', 
    ['created' => strtotime(-$days.' days')]
  );
}

function mcapi_tester_make_inter_transactions($num) {
  $exchanges = Exchange::loadbyProperties(array('status' => 1, 'open' => 1));
  foreach($exchanges as $exchange) {
    $wids[$exchange->id()] = get_mcapi_wallets_in_exchanges(array($exchange->id()));
  }

  //remove wallet 2, belonging to user 1, because of a caching problem - very uncomfortable hack
  //$pos = array_search('2', $wids);
  //unset($wids[$pos]);
  //get two random different wallets - the first one...
  for ($i = 1; $i <= $num; $i++) {
    $wids1 = $wids;
    shuffle($wids1);
    $e1 = reset($wids1);
    $e2 = next($wids1);
    $k1 = array_rand($e1);
    $k2 = array_rand($e2);

    $props = array(
      'payer' => $e1[$k1],
      'payee' => $e2[$k2],
      'type' => 'test',
      'creator' => 1,
      'description' => 'autogenerated intertrade'
    );
    reset($wids1);
    //does key() advance the array cursor?
    $currencies = Exchanges::currencies(array(key($wids1), key($wids1)), $ticks = FALSE);
    if (empty($currencies)) {
      continue;
    }
    $props['worth'] = array(
      0 => array(
        'value' => rand(5, 100)*10,
        'curr_id' => reset($currencies)->id()
      )
    );
    $transaction = Transaction::create($props)->save();
  }
}

function mcapi_tester_firstparty_editform_load($entities) {
//  debug($entities);
  foreach ($entities as &$firstpartyform) {
  //  if
  }
}


/**
 * Create up to 26 users and put them EACH IN ONE exchange
 * Note that users will have a wallet created automatically according to the wallet settings
 *
 * @param integer $num
 *   the number of users to create, max 26
 * @param array $exchange_ids
 *   the ids of exchanges the new members can join.
 * @return array
 *   the $account->id()s created
 */
function mcapi_tester_make_users($num = 26) {

  //create users
  $first = array('Alice', 'Bobby', 'Carry', 'Dave', 'Ebeneezer', 'Fanny', 'Garry', 'Harry', 'Isa', 'Josephine', 'Kerry', 'Larry', 'Mathieu', 'Nancy', 'Oliver', 'Perry', 'Quentin', 'Ruby', 'Sylvester', 'Trudy', 'Ursula', 'Veronica', 'William', 'Xanadu', 'Yuri', 'Zoe');
  $last = array('Arachnid', 'Boulder', 'Castaway', 'Deathwish', 'Emerald', 'Frogleg', 'Golden', 'Handiman', 'Indignado', 'Janitor', 'Kant', 'Landrover', 'Mandrake', 'Nakomoto', 'Orwell', 'Python', 'Quarkson', 'Rhodes', 'Smythe', 'Trenchfoot', 'Ustinov', 'Victor', 'Wellington', 'X', 'Ypres', 'Zenithson');
  shuffle($last);
  for ($i = 0; $i < $num; $i++) {
    $props = array(
      'name' => $first[$i] .' '. $last[$i],
      'mail' => 'test_'.strtolower($first[$i]).'@matslats.net',
      'pass' => 'a',
      'status' => 1,
    );
    $u = User::create($props);
    $u->save();
    $uids[] = $u->id();
  }
  return $uids;
}

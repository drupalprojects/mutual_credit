<?php

/*
 * This file is included using the function mcapi_controller();
 */

define ('TRANSACTION_STATE_VALIDATING', -2);

/*
 * The transaction entity has its own CRUD operations
 */
class TransactionEntityController extends DrupalDefaultEntityController {
  /*
   * Throws an error if a transaction doesn't exist
   */
  public function load($xids = array(), $conditions = array()) {
    $transactions = parent::load($xids, $conditions);
    if (!count($transactions)) {
      throw new Exception(t('Invalid transaction ID: @ids', array('@ids' => implode(', ', $xids))));
    }
    return $transactions;
  }

  /*
   * This controller actually writes the transaction during validation
   * with a special state: TRANSACTION_STATE_VALIDATING
   * When written, the transaction has a unique ID, so we
   * indicate that the transaction is actually a new transaction with the new property, 'is_new'
   */
  public function validate($transaction){
    $currency = currency_load($transaction->cid);
    $state = $transaction->state;
    $transaction->validating = TRUE;
    if (empty($transaction->xid)) {
      $transaction->is_new = TRUE;
      //temporarily change the transaction state so that validated transaction left hanging DO leave a trace.
      $transaction->state = TRANSACTION_STATE_VALIDATING;
    }
    $t = db_transaction();
    try {
      entity_get_controller('transaction')->save($transaction);
    }
    catch (Exception $e){
      //if the validation fails, we add the error message to the transaction object
      //THIS IS NOT TESTED BECAUSE VALIDATION SHOULDN'T FAIL AT THIS LATE STAGE
      $transaction->data['error'] = $e->getMessage();
      throw $e;
    }
    if (empty($transaction->is_new)) {
      $t->rollback();
    }
    unset($transaction->validating);
    $transaction->state = $state;
    return $transaction;
  }

  /*
   * update or insert the saved transaction
   * expects a single, validated transaction object
   * what the user thinks of as inserting and updating isn't actually what the controller is doing.
   * because the transaction was actually 'inserted' during the validation phase
   * So we use the 'is_new' property and run insert a second time
   * The transaction is only really processed if the state isn't TRANSACTION_STATE_VALIDATING
   */
  public function save($transaction) {
    //this is only used to fix what I think is a Drupal bug, see mcapi_field_attach_presave
    //removes the 'add more' item from fields with infinite cardinality
    $instances = array();
    $instances = _field_invoke_get_instances('transaction', 'transaction', array('deleted' => FALSE));
    foreach($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == -1 && isset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more'])) {
        unset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more']);
      }
    }//end of bugfix

    $transaction->modified = REQUEST_TIME;
    $transaction->modifier = $GLOBALS['user']->uid;
    //clear any Exception traces which from validation, which should no longer apply
    unset ($transaction->data['error']);
    $t = db_transaction();
    //the transaction is actually written during the validation phase, but we still want to run
    $function = empty($transaction->is_new) ? 'update' : 'insert';
    try {
      entity_get_controller('transaction')->$function($transaction);
    }
    catch (Exception $e) {
      $t->rollback();
      watchdog_exception('mcapi', $e);
      throw $e;
    }
    if (isset($transaction->validating)) return;

    balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
    module_invoke_all('entity_'.$function, 'transaction', $transaction);
    return $transaction;
  }

  /*
   * merely set the state of the exchange, not delete the row
   * there is no error checking on this.
   */
  public function erase($transaction) {
    $currency = currency_load($transaction->cid);
    switch ($currency->delete_mode) {
      case '0':
        throw new Exception(t('Deletions not allowed'));
        break;
      case '1':
        $transaction = $this->change_state($transaction, TRANSACTION_STATE_ERASED);
        break;
      case '2':
        $query = db_delete('mcapi_transactions')
        ->condition('xid', $transaction->xid)
        ->execute();
        try {
          balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
        }
        catch (Exception $e) {
          drupal_set_message($e->getMessage(), 'warning');
        }
    }
    module_invoke_all('entity_delete', 'transaction', $transaction);
    return $transaction;
  }

  public function change_state($transaction, $new_state) {
    $transaction->state = $new_state;
    $transaction->modified = REQUEST_TIME;
    $transaction->modifier = $GLOBALS['user']->uid;
    try{
      drupal_write_record('mcapi_transactions', $transaction, 'xid');
      balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
    }
    catch (Exception $e) {
      drupal_set_message(t('Problem changing state of transaction #@xid to @state', array('@xid' => $transaction->xid, '@state' => $new_state)));
    }
    return $transaction;
  }

  /*
   * Get a list of transactions, filtered by $conditions
   * keys in $conditions array are:
   * * states - the transaction state constant
   * * cid - the currency id
   * * uid (the owner of the transaction)
   * * id a participant in the transaction
   */
  public function transaction_list($conditions = array()){
    $query = db_select('mcapi_transactions', 'x');
    if (isset($conditions['states'])){
      $query->condition('state', $conditions['states']);
    }
    if (isset($conditions['cid'])) {
      $query->condition('cid', $conditions['cid']);
    }
    if (isset($conditions['creator'])) {
      $query->condition('creator', $conditions['c']);
    }
    if (isset($conditions['id'])) {
      $query->condition(
         db_or()
         ->condition('payer_uid', $conditions['id'])
         ->condition('payee_uid', $conditions['id'])
       );
    }
    return $query->fields('x')->execute()->fetchAll();
  }
  /*
   * retrieve all the cached balances for a user, in all the currencies cached.
   * it's not clear what it means if a row doesn't exist here
   * $cids can be an array or a currency id
   * every cid asked for will return list of values, even if it doesn't exist in the db.
   */
  public function get_cache($uid) {
    return db_select('mcapi_cache', 'c')
    ->fields('c')
    ->condition('uid', $uid)
    ->execute()
    ->fetchAllAssoc('cid', PDO::FETCH_ASSOC);
  }

  /*
   * create a transaction, either the first moment at validation
   */
  function insert($transaction) {
    $transaction->creator = $GLOBALS['user']->uid;
    $transaction->created = REQUEST_TIME;
    if (empty($transaction->xid)) {
      $success = drupal_write_record('mcapi_transactions', $transaction);
      field_attach_insert('transaction', $transaction);
    }
    else {
      $success = drupal_write_record('mcapi_transactions', $transaction, 'xid');
      field_attach_update('transaction', $transaction);
    }
    if (!$success) {
      throw new Exception(t('failed to write to table @tablename', array('@tablename' => $table)));
    }
  }

  /*
   * This controller makes no use of the entity revision control facility
   */
  function update($transaction) {
    $currency = currency_load($transaction->cid);
    //special case. This prevents writing a new row on validation
    //instead we validate by updating the row
    $mode = intval(isset($transaction->validating) && $currency->update_mode == 1 ? 2 : $currency->update_mode == 1);
    switch($mode) {
      case 0:
        throw new Exception(t('Updates not allowed'));
      case 1:
        $old = transaction_load($transaction->xid);
        $transaction->data['formerly'] = $transaction->xid;
        //remove the xid and insert the transaction anew
        unset($transaction->xid);
        $this->insert($transaction); //will give a new xid
        $old->data['became'] = $transaction->xid;
        //then erase the old one
        $this->erase($old);
        break;
      case 2:
        drupal_write_record('mcapi_transactions', $transaction, 'xid');
        field_attach_update('transaction', $transaction);
        break;
    }
  }
}

/*
 * The currency entity has its own CRUD operations
 */
class CurrencyEntityController extends DrupalDefaultEntityController {

  public function load($cids = array(), $conditions = array()) {
    $currencies = parent::load($cids, $conditions);
    foreach($currencies as $key => $currency) {
      $data = unserialize($currencies[$key]->data);
      foreach ($data as $name => $value) {
        $currencies[$key]->$name = $value;
      }
      //does this need to be done here, for every currency on every page_load?
      $currencies[$key]->divisions = currency_divisions_array($currency->divisions_conf);
    }
    return $currencies;
  }

  public function save($currency) {
    $function = isset($currency->cid) && $currency->cid ? 'update' : 'insert';
    cache_clear_all('currencies', 'cache');
    $currency = $this->$function($currency, TRUE);
    module_invoke_all('entity_'.$function, 'currency', $currency);
  }
  
  function insert($currency) {
    $table = 'mcapi_currencies';
    $success = drupal_write_record($table, $currency);
    if (!$success) {
      throw new Exception(t('failed to write to @name table', array('@name' => $table)));
    }
    field_attach_insert('currency', $currency);
  }

  function update($currency) {
    drupal_write_record('mcapi_currencies', $currency, array('cid'));
    field_attach_update('currency', $currency);
  }
}


/*
 * When we need to know the currency divisions, this function converts them
 * from the multiline string of the configuration to a nice array
 */
function currency_divisions_array($string) {
  if (strpos($string, '|')) {
    $lines = explode("\n", $string);
    foreach($lines as $line) {
      $array = explode('|', $line);
      $allowed[$array[0]] = $array[1];
    }
    return $allowed;
  }
  elseif ($string == '00') {
    return '00';
  }
}


//refreshes a cache of all the transactions,
function balances_recalc($cid, $uids, $test = FALSE) {
  foreach($uids as $uid) {
    //$in = db_select('mcapi_transactions', 't')->fields('c', array());
    $in = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $out = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $in['total'] = floatval($in['total']);
    $out['total'] = floatval($out['total']);

    $pend_out = floatval(db_query("SELECT sum(quantity)  from {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $pend_in = floatval(db_query("SELECT sum(quantity) from {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $query = db_merge('mcapi_cache')
    ->key(array('cid' => $cid, 'uid' => $uid));
    
    $query->fields(array(
      'cleared_balance' => $in['total'] - $out['total'],
      'gross_in' => $in['total'],
      'gross_out' =>$out['total'],
      'count' => intval($in['count'] + $out['count']),
      'pending_dif' => $pend_in - $pend_out,
    ));
    $query->execute();
  }
}


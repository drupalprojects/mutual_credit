<?php

/*
 * This file is included using the function mcapi_controller();
 */

define ('TRANSACTION_STATE_VALIDATING', -2);

/*
 * The transaction entity has its own CRUD operations
 */
class TransactionEntityController extends DrupalDefaultEntityController {
  /*
   * Throws an error if a transaction doesn't exist
   */
  public function load($xids = array(), $conditions = array()) {
    $transactions = parent::load($xids, $conditions);
    if (!count($transactions)) {
      throw new Exception(t('Invalid transaction ID: @ids', array('@ids' => implode(', ', $xids))));
    }
    return $transactions;
  }

  /*
   * Validation ideally would happen by using the save function with $write set to FALSE
   * Instead we just check the balances here/
   */
  public function validate($transaction){
    $currency = currency_load($transaction->cid);
    $key = isset($transaction->xid) ? $transaction->xid : NULL;
    try {
      //temporarily change the transaction type so that validated transaction left hanging DO leave a trace.
      $state = $transaction->state;
      $transaction->state = TRANSACTION_STATE_VALIDATING;
      entity_get_controller('transaction')->save($transaction, $currency->write_validate);
      $transaction->state = $state;
    }
    catch (Exception $e){
      //if the validation fails, we add the error message to the transaction object
      //THIS IS NOT TESTED BECAUSE VALIDATION SHOULDN'T FAIL AT THIS LATE STAGE
      $transaction->data['error'] = $e->getMessage(); 
    }
    //the db rolled back but the allocated transaction ID persists in the transaction object
    if (!$currency->write_validate) {
      $transaction->xid = $key;
    }
  }

  /*
   * update or insert the saved transaction
   * expects a single, validated transaction object
   */
  public function save($transaction, $write = FALSE) {
    //this is only used to fix what I think is a Drupal bug, see mcapi_field_attach_presave
    //removes the 'add more' item from fields with infinite cardinality
    $instances = array();
    $instances = _field_invoke_get_instances('transaction', 'transaction', array('deleted' => FALSE));
    foreach($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == -1) {
        unset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more']);
      }
    }//end of bugfix

    //clear any error messages which were created in validation
    unset ($transaction->data['error']);
    //somebody should tell me if the methodology is good here.
    $t = db_transaction();
    //unfortunately the rollback doesn't roll back the auto-increment.
    $function = isset($transaction->xid) && $transaction->xid ? 'update' : 'insert';
    try {
      entity_get_controller('transaction')->$function($transaction, TRUE);
    }
    catch (Exception $e) {
      $t->rollback();
      watchdog_exception('mcapi', $e->getMessage());
      throw $e;
    }
    if (!$write) {
      $t->rollback();
      //for some reason these public functions all have their arguments passed by reference
      //so we must be careful to unset the xid if we were only testing
    }
    else {
      balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
      module_invoke_all('entity_'.$function, 'transaction', $transaction);
    }
  }

  /*
   * merely set the state of the exchange, not delete the row
   * there is no error checking on this.
   */
  public function erase($transaction) {
    $currency = currency_load($transaction->cid);
    switch ($currency->delete_mode) {
      case '0':
        throw new Exception(t('Deletions not allowed'));
        break;
      case '1':
        $transaction->state = TRANSACTION_STATE_ERASED;
        //db_query("UPDATE {mcapi_transactions} SET state = :state, data = :data WHERE xid = :xid",
        //  array(':state' => $transaction->state, ':data' => serialize($transaction->data), ':xid' => $transaction->xid)
        //);
        drupal_write_record('mcapi_transactions', $transaction, 'xid');
        break;
      case '2':
        $query = db_delete('mcapi_transactions')
        ->condition('xid', $transaction->xid)
        ->execute();
        break;
    }
    try {
      balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
    }
    catch (Exception $e) {
      drupal_set_message($e->getMessage(), 'warning');
    }
    module_invoke_all('entity_delete', 'transaction', $transaction);
  }


  /*
   * Get a list of transactions, filtered by $conditions
   * keys in $conditions array are:
   * * states - the transaction state constant
   * * cid - the currency id
   * * uid (the owner of the transaction)
   * * id a participant in the transaction
   */
  public function transaction_list($conditions = array()){
    $query = db_select('mcapi_transactions', 'x');
    if (isset($conditions['states'])){
      $query->condition('state', $conditions['states']);
    }
    if (isset($conditions['cid'])) {
      $query->condition('cid', $conditions['cid']);
    }
    if (isset($conditions['uid'])) {
      $query->condition('uid', $conditions['uid']);
    }
    if (isset($conditions['id'])) {
      $query->condition(
         db_or()
         ->condition('payer_uid', $conditions['id'])
         ->condition('payee_uid', $conditions['id'])
       );
    }
    return $query->fields('x')->execute()->fetchAll();
  }
  /*
   * retrieve all the cached balances for a user, in all the currencies cached.
   * it's not clear what it means if a row doesn't exist here
   * $cids can be an array or a currency id
   * every cid asked for will return list of values, even if it doesn't exist in the db.
   */
  public function get_cache($uid) {
    return db_select('mcapi_cache', 'c')
    ->fields('c')
    ->condition('uid', $uid)
    ->execute()
    ->fetchAllAssoc('cid', PDO::FETCH_ASSOC);
  }

  /*
   * write an transaction (and its dependents) to the database, refreshing the balances
   */
  function insert($transaction) {
    $table = 'mcapi_transactions';
    $success = drupal_write_record($table, $transaction);
    if (!$success) {
      throw new Exception(t('failed to write to @name table', array('@name' => $table)));
    }
    field_attach_insert('transaction', $transaction);
    //make a unique list of all the affected and update their balances
    //it is conceivable that we might be processing other
    $refreshers[] = $transaction->payer_uid;
    $refreshers[] = $transaction->payee_uid;

    //assumes all the transactions were in the same currency
  }

  /*
   *
   * The GVA engine will erase and create a new record rather that actually updating a record
   * This update function copies that
   * An alternative would be to use the revision control provided by the entity
   * Transactions with derived transactions, do not update, but automatically erase and insert,
   * TODO We could use the versions table here, since it is included already
   */
  function update($transaction) {
    $currency = currency_load($transaction->cid);
    switch($currency->update_mode) {
      case 0:
        throw new Exception(t('Updates not allowed'));
        break;
      case 1:
        //delete the old, remove the xid and insert it
        $old = clone $transaction;
        //$transaction->data['was'] = $transaction->xid;//this is where we link the new to the old.
        unset($transaction->xid);
        $this->insert($transaction); //will give a new xid
        $old->data['became'] = $transaction->xid;
        $this->erase($old);
        break;
      case 2:
        //while there are no 'derived' transactions, we are dealing with one only
        drupal_write_record('mcapi_transactions', $transaction, 'xid');
        field_attach_update('transaction', $transaction);
        break;
    }
  }
}

/*
 * The currency entity has its own CRUD operations
 */
class CurrencyEntityController extends DrupalDefaultEntityController {

  public function load($cids = array(), $conditions = array()) {
    $currencies = parent::load($cids, $conditions);
    foreach($currencies as $key => $currency) {
      $data = unserialize($currencies[$key]->data);
      foreach ($data as $name => $value) {
        $currencies[$key]->$name = $value;
      }
      //does this need to be done here, for every currency on every page_load?
      $currencies[$key]->divisions = currency_divisions_array($currency->divisions_conf);
    }
    return $currencies;
  }

  public function save($currency) {
    $function = isset($currency->cid) && $currency->cid ? 'update' : 'insert';
    $currency = $this->$function($currency, TRUE);
    module_invoke_all('entity_'.$function, 'currency', $currency);
  }
  
  function insert($currency) {
    $table = 'mcapi_currencies';
    $success = drupal_write_record($table, $currency);
    if (!$success) {
      throw new Exception(t('failed to write to @name table', array('@name' => $table)));
    }
    field_attach_insert('currency', $currency);
  }

  function update($currency) {
    drupal_write_record('mcapi_currencies', $currency, array('cid'));
    field_attach_update('currency', $currency);
  }
}


/*
 * When we need to know the currency divisions, this function converts them
 * from the multiline string of the configuration to a nice array
 */
function currency_divisions_array($string) {
  if (strpos($string, '|')) {
    $lines = explode("\n", $string);
    foreach($lines as $line) {
      $array = explode('|', $line);
      $allowed[$array[0]] = $array[1];
    }
    return $allowed;
  }
  elseif ($string == '00') {
    return '00';
  }
}

/*
 * This is where the settings specific to the controller are added to the currency form
 */
function mcapi_form_currency_form_alter(&$form, $form_state, $form_id) {
  $currency = $form['cid']['#default_value'] ? currency_load($form['cid']['#default_value']) : NULL;
  $form['accounting'] = array(
    '#title' => t('Accounting standards'),
    '#description' => t('More or less formal accounting standards can be determined.') .' '. 
      t('Not all combinations are meaningful!') .' '.
      t('The first fields take precedence') .' '.
      t('YOU SHOULD TEST THAT YOUR SETTINGS WORK AS INTENDED!'),
    '#type' => 'fieldset',
    '#weight' => 0,
    '#group' => 'additional_settings',
    'delete_mode' => array(
      '#title' => t('Delete mode'),
      '#type' => 'radios',
      '#options' => array(
        0 => t("Can't delete"),
        1 => t('Mark deleted'),
        2 => t('Remove all traces from the database (not from backups)'),
      ),
      '#default_value' => isset($currency->delete_mode) ? $currency->delete_mode : 0,
      '#weight' => 1
    ),
    'update_mode' => array(
      '#title' => t('Update mode'),
      '#description' => t("Changing the state of a transaction doesn't count as editing it"),
      '#type' => 'radios',
      '#options' => array(
        0 => t("Can't update"),
        1 => t("Delete and create a new transaction"),
        2 => t("Update same record"),
        //3 => t("Use entity versioning the same transaction (not available)"),
      ),
      '#default_value' => isset($currency->update_mode) ? $currency->update_mode : 0,
      '#weight' => 2,
      '#element_validate' => array('mcapi_currency_validate_update_mode')
    ),
    'write_validate' => array(
      '#title' => t('Write transaction during validation'),
      '#description' => t('Transactions that are abandoned between validation and saving will leave a trace in the database.'),
      '#type' => 'checkbox',
      '#default_value' => isset($currency->write_validate) ? $currency->write_validate : 1,
      '#weight' => 3,
    ),
  );
  $form['#entity_builders'][] = 'currency_entity_builder_default';
}

function currency_entity_builder_default($entity_type, $entity, $form, $form_state) {
  $entity->data['delete_mode'] = $entity->delete_mode;
  $entity->data['update_mode'] = $entity->update_mode;
  $entity->data['write_validate'] = $entity->write_validate;
}


//refreshes a cache of all the transactions,
function balances_recalc($cid, $uids) {
  foreach($uids as $uid) {
    $in = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $out = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $in['total'] = floatval($in['total']);
    $out['total'] = floatval($out['total']);

    $pend_out = floatval(db_query("SELECT sum(quantity)  from {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $pend_in = floatval(db_query("SELECT sum(quantity) from {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $query = db_merge('mcapi_cache')
    ->key(array('cid' => $cid, 'uid' => $uid));
    
    $query->fields(array(
      'cleared_balance' => $in['total'] - $out['total'],
      'gross_in' => $in['total'],
      'gross_out' =>$out['total'],
      'count' => intval($in['count'] + $out['count']),
      'pending_dif' => $pend_in - $pend_out,
    ));
    $query->execute();
  }
}


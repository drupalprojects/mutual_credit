<?php

/*
 * This file is included using the function mcapi_controller();
 */


/*
 * The transaction entity has its own CRUD operations
 */
class MCAPIEntityController extends DrupalDefaultEntityController {
  /*
   * Adapted from the default entity controller.
   * no support for revisions
   * switches database to load transactions
   * returns an error if the transaction id is invalid
   */
  public function load($ids = array(), $conditions = array()) {
    $entities = array();
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;

    //get from cache where available
    if ($this->cache) {
      $entities += $this->cacheGet($ids, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }


    if ($ids === FALSE || $ids || ($conditions && !$passed_ids)) {
      db_set_active(variable_get('mcapi_db_read', 'default'));
      $query = db_select($this->entityInfo['base table'], 'base');
      db_set_active();
      $query->fields('base', $this->entityInfo['schema_fields_sql']['base table']);
      // Build the query.
      if ($ids) {
        $query->condition("base.{$this->idKey}", $ids, 'IN');
      }
      foreach ($conditions as $field => $value) {
        $query->condition('base.' . $field, $value);
      }
      $queried_entities = $query->execute()->fetchAllAssoc($this->idKey);
      //extract the serialized data into 'extra' property
      foreach ($queried_entities as $key => $entity) {
        $queried_entities[$key]->extra = unserialize($queried_entities[$key]->data);
        unset($queried_entities[$key]->data);
      }
    }

    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities);
      $entities += $queried_entities;
    }
    if ($this->cache) {
      if (!empty($queried_entities)) {
        $this->cacheSet($queried_entities);
      }
    }
    if (!count($entities)) {
      throw new Exception(t('Invalid entity ID: @ids', array('@ids' => implode(', ', $ids))));
    }
    return $entities;
  }
}

class TransactionEntityController extends MCAPIEntityController {
  /*
   * This controller actually writes the transaction during validation
   * with a special state: TRANSACTION_STATE_VALIDATING
   * When written, the transaction has a unique ID, so we
   * indicate that the transaction is actually a new transaction with the new property, 'is_new'
   */
  public function validate($transaction){
    $currency = currency_load($transaction->cid);
    $state = $transaction->state;
    $transaction->validating = TRUE;
    if (empty($transaction->xid)) {
      $transaction->is_new = TRUE;
      //temporarily change the transaction state so that validated transaction left hanging DO leave a trace.
      $transaction->state = TRANSACTION_STATE_VALIDATING;
    }
    $t = db_transaction();
    try {
      entity_get_controller('transaction')->save($transaction);
    }
    catch (Exception $e){
      //if the validation fails, we add the error message to the transaction object
      //THIS IS NOT TESTED BECAUSE VALIDATION SHOULDN'T FAIL AT THIS LATE STAGE
      $transaction->extra['error'] = $e->getMessage();
      throw $e;
    }
    if (empty($transaction->is_new)) {
      $t->rollback();
    }
    unset($transaction->validating);
    $transaction->state = $state;
    return $transaction;
  }

  /*
   * update or insert the saved transaction
   * expects a single, validated transaction object
   * what the user thinks of as inserting and updating isn't actually what the controller is doing.
   * because the transaction was actually 'inserted' during the validation phase
   * So we use the 'is_new' property and run insert a second time
   * The transaction is only really processed if the validating property is NOT set
   */
  public function save($transaction) {
    //this is only used to fix what I think is a Drupal bug, see mcapi_field_attach_presave
    //removes the 'add more' item from fields with infinite cardinality
    $instances = array();
    $instances = _field_invoke_get_instances('transaction', 'transaction', array('deleted' => FALSE));
    foreach($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == -1 && isset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more'])) {
        unset($transaction->{$instance['field_name']}[LANGUAGE_NONE]['add_more']);
      }
    }//end of bugfix

    $transaction->modified = REQUEST_TIME;
    $transaction->modifier = $GLOBALS['user']->uid;
    $transaction->data = $transaction->extra;
    $t = db_transaction();
    //the transaction is actually written during the validation phase, but we still want to run
    $function = empty($transaction->is_new) ? 'update' : 'insert';
    try {
      $this->$function($transaction, !empty($transaction->validating));
    }
    catch (Exception $e) {
      $t->rollback();
      watchdog_exception('mcapi', $e);
      throw $e;
    }
    if (isset($transaction->validating)) return;

    balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
    module_invoke_all('entity_'.$function, 'transaction', $transaction);
    return $transaction;
  }

  /*
   * merely set the state of the exchange, not delete the row
   * there is no error checking on this.
   */
  public function erase($transaction) {
    $currency = currency_load($transaction->cid);
    switch ($currency->extra['delete_mode']) {
      case '0':
        throw new Exception(t('Deletions not allowed'));
        break;
      case '1': //mark deleted
        debug($transaction);
        $transaction->state = TRANSACTION_STATE_ERASED;
        $transaction->modified = REQUEST_TIME;
        $transaction->modifier = $GLOBALS['user']->uid;
        try{
          mcapi_write_record('mcapi_transactions', $transaction, array('xid'));
          balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
        }
        catch (Exception $e) {
          $e->message .= t('Problem changing state of transaction #@xid to @state', array('@xid' => $transaction->xid, '@state' => $new_state));
          throw $e;
        }
        break;
      case '2': //actually delete
        try {
          $query = db_delete('mcapi_transactions')
          ->condition('xid', $transaction->xid)
          ->execute();
          balances_recalc($transaction->cid, array($transaction->payer_uid, $transaction->payee_uid));
        }
        catch (Exception $e) {
          throw $e;
        }
        module_invoke_all('entity_delete', 'transaction', $transaction);
    }
    return $transaction;
  }

  /*
   * Get a list of transactions for a user, between unixtimes
   */
  public function statement($uid){
    db_set_active(variable_get('mcapi_db_read', 'default'));
    $query = db_select('mcapi_transactions', 'x');
    db_set_active();
    $query->condition(db_or()
      ->condition('payer_uid', $uid)
      ->condition('payee_uid', $uid)
    )->condition(db_or()
      ->condition('state', TRANSACTION_STATE_FINISHED)
      ->condition('state', TRANSACTION_STATE_PENDING)
    );
    return $query->fields('x')->execute()->fetchAll();
  }
  /*
   * retrieve all the cached balances for a user, in all the currencies cached.
   * it's not clear what it means if a row doesn't exist here
   * $cids can be an array or a currency id
   * every cid asked for will return list of values, even if it doesn't exist in the db.
   */
  public function get_cache($uid) {
    db_set_active(variable_get('mcapi_db', 'default'));
    return db_select('mcapi_cache', 'c')
    ->fields('c')
    ->condition('uid', $uid)
    ->execute()
    ->fetchAllAssoc('cid', PDO::FETCH_ASSOC);
    db_set_active();
  }

  public function count($conditions = array()) {
    $query = db_select('mcapi_transactions');
    foreach ($conditions as $field => $value) {
      $query->condition($field, $value);
    }
    return $query->countquery()->execute()->fetchField();
  }

  /*
   * create a transaction, either the first moment at validation
   */
  function insert($transaction) {
    $transaction->creator = $GLOBALS['user']->uid;
    $transaction->created = REQUEST_TIME;
    $table = 'mcapi_transactions';
    if (empty($transaction->xid)) {
      $success = mcapi_write_record($table, $transaction);
      field_attach_insert('transaction', $transaction);
    }
    else {
      $success = mcapi_write_record($table, $transaction, array('xid'));
      field_attach_update('transaction', $transaction);
    }
    if (!$success) {
      throw new Exception(t('failed to write to table @tablename', array('@tablename' => $table)));
    }
  }

  /*
   * This controller makes no use of the entity revision control facility
   */
  function update($transaction, $force_replace = FALSE) {
    $currency = currency_load($transaction->cid);
    //special case. This prevents writing a new row on validation
    //instead we validate by updating the row
    $mode = $currency->extra['update_mode'];
    if ($force_replace && $mode == 1) $mode = 2;
    switch($mode) {
      case 0:
        throw new Exception(t('Updates not allowed'));
      case 1:
        $old = transaction_load($transaction->xid);
        $transaction->extra['formerly'] = $transaction->xid;
        $old->extra = $transaction->extra;
        //remove the xid and insert the transaction anew
        unset($transaction->xid);
        $this->insert($transaction); //will give a new xid
        $old->extra['became'] = $transaction->xid; debug($old);
        //then erase the old one
        $this->erase($old);
        break;
      case 2:
        try {
          mcapi_write_record('mcapi_transactions', $transaction, array('xid'));
        }
        catch (Exception $e) {
          //getting an error: Cannot access protected property Exception::$message
          //$e->message .= ' '. t('Database failed to update transaction record.');
          throw $e;
        }
        field_attach_update('transaction', $transaction);
        break;
    }
  }
}

/*
 * The currency entity has its own CRUD operations
 */
class CurrencyEntityController extends MCAPIEntityController {

  public function load($cids = array(), $conditions = array()) {
    $currencies = parent::load($cids, $conditions);
    module_load_include('inc', 'mcapi');
    foreach($currencies as $key => $currency) {
      //does this need to be done here, for every currency on every page_load?
      $currencies[$key]->divisions = _currency_divisions_array($currency->divisions_conf);
    }
    return $currencies;
  }

  public function save($currency) {
    $function = isset($currency->cid) && $currency->cid ? 'update' : 'insert';
    cache_clear_all('currencies', 'cache');
    $currency = $this->$function($currency, TRUE);
    module_invoke_all('entity_'.$function, 'currency', $currency);
  }

  public function delete($currency) {
    //check that there are no transactions in this currency
    if (db_query("SELECT xid FROM {mcapi_transactions} WHERE cid = :cid", array(':cid' => $currency->cid))->fetchField()) {
      throw new Exception(t('Cannot delete currency without first deleting all transactions using that currency'));
    }
    db_query("DELETE FROM {mcapi_currencies} WHERE cid = :cid", array(':cid' => $currency->cid));
    field_attach_delete('currency', $currency);
  }
  
  function insert($currency) {
    $table = 'mcapi_currencies';
    $success = mcapi_write_record($table, $currency);
    if (!$success) {
      throw new Exception(t('failed to write to @name table', array('@name' => $table)));
    }
    field_attach_insert('currency', $currency);
  }

  function update($currency) {
    mcapi_write_record('mcapi_currencies', $currency, array('cid'));
    field_attach_update('currency', $currency);
  }
}


//refreshes a cache of all the transactions,
function balances_recalc($cid, $uids, $test = FALSE) {
  foreach($uids as $uid) {
    $in = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $out = db_query("SELECT sum(quantity) total, count(quantity) count FROM {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_FINISHED, ':cid' => $cid))
      ->fetchAssoc();
    $in['total'] = floatval($in['total']);
    $out['total'] = floatval($out['total']);

    $pend_out = floatval(db_query("SELECT sum(quantity)  from {mcapi_transactions} WHERE payer_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $pend_in = floatval(db_query("SELECT sum(quantity) from {mcapi_transactions} WHERE payee_uid = :uid AND state = :state AND cid = :cid",
      array(':uid' => $uid, ':state' => TRANSACTION_STATE_PENDING, ':cid' => $cid))
      ->fetchField());
    $row = (object)array(
      'cid' => $cid,
      'uid' => $uid,
      'cleared_balance' => $in['total'] - $out['total'],
      'gross_in' => $in['total'],
      'gross_out' =>$out['total'],
      'count' => intval($in['count'] + $out['count']),
      'pending_dif' => $pend_in - $pend_out,
    );
    foreach (variable_get('mcapi_db_write', array('default')) as $connection) {
      db_set_active($connection);
      mcapi_write_record('mcapi_cache', $row, array('cid', 'uid'));
    }
  }
  db_set_active();
}



/*
 */
function mcapi_write_record($table, &$record, $primary_keys = array()) {
  //we need to ensure the schema is cached before calling mcapi_write_record
  //Otherwise it may try to retrieve the schema from the wrong database
  drupal_get_schema($table);
  foreach (variable_get('mcapi_db_write', array('default')) as $connection) {
    db_set_active($connection);
    try{
      $ts[] = db_transaction();
      $success = drupal_write_record($table, $record, $primary_keys);
    }
    catch (Exception $e) {
      foreach ($ts as $db_transaction) {
        $db_transaction->rollback();
      }
      db_set_active();
      foreach ($primary_keys as $keyname) {
        $keys[$keyname] = $record->$keyname;
      }
      $newmessage = t("Failed to write to table '@table' on database '@database', using keys: @keys",
        array(
          '@table' => $table,
          '@database' => $connection,
          '@keys' => '<pre>'.print_r($keys, 1).'</pre>'
        )
      );
      throw new Exception ($newmessage);
    }
  }
  db_set_active();
  return $success;
}